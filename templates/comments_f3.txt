Comments from https://www.reddit.com/r/CodingandBilling/comments/1ctki3z/starting_my_first_day_of_volunteer_coding_and_am/:
Edit: I have received confirmation on the codes my teammates and I decided on (they admitted this particular note was a doozy for a newbie like me). So in case it helps anyone else, I will include a picture of my written notes that my senior teammates consider correct and thorough!
I need help before I let myself feel stupid in front of my new coworkers lol.. I'm doing volunteer coding for a non profit that sees people in low resource communities.. so the documentation is not exactly proper. I'm already struggling with my first case LOL.
Since you're talking about a pregnant patient, I would suggest doing a quick review of the ICD-10-CM guidelines for Chapter 15 and pull out your book to review the instructions at the beginning of Chapter 15.
Remember to look in the Alphabetic Index under "pregnancy > complicated by (care of) (management affected by)" to see if there are pregnancy-specific codes for any of the symptoms and conditions you'd want to code. Always look for an O code from Chapter 15 before using codes from other chapters - coding illness during pregnancy can be tricky.
Another resource you can review is Coding Guidance from the ACOG: https://www.acog.org/practice-management/coding
(I rarely have to code cases for pregnant patients in the real world, so I'm hesitant to speculate on what codes you should use. Some of the resources I linked above should get you started though!)
Z3A code as well. Query number of weeks.
i've added a picture of my approved codes! SOO much more convoluted than I would have imagined. But my very helpful teammates told me that coding for a pregnant woman can become really complex. Especially in a setting like this where I somewhat have to make assumptions
I do not have my book in front of me; but this is how I would code the chart:
complications of pregnancy + secondary codes for diarrhea (unless documentation states she has probable or current dysentery, if it has already been treated, I would use history code)
Maternal care for previous c-section (specify low transverse, etc or unspecified)
-z code for weeks of gestation
Suspected or possible conditions should only be coded from inpatient visits and in accordance with the ICD-10 guidelines. You can search the guidelines for "uncertain" to review them specifically.
Why not "dysentery"?
I don't see language in the dx statement indicating uncertainty.
my thoughts too. so if I were to code dysentery, would I omit the symptom of mucusy diarrhea?
Query for hyperemesis gravidarum? You can use the R codes and O codes for other specified if need be
The doctor should be coding no inexperience coder should be coding. The doctor is responsible for what‚Äôs submitted on the claim form. It‚Äôs a legal document. The doctor can be audited on this and if it‚Äôs wrong, it appears he is making a false diagnosis/procedure.
Well all of these encounters occur in different countries, so I believe it is mainly for research purposes as this is a non profit.

Comments from https://www.reddit.com/r/learnpython/comments/1fk9u9d/horribly_confused_by_a_lesson/:
Okay, so I'm somewhat new to Python, and somewhat familiar, but completely awful, at programming. I've been trying off and on for 20 years to learn it but I don't think my brain bends in the direction it needs to in order to learn programming. But I've decided to give it another go, this time with Python.
Right now I'm using the site futurecoder and it's pretty good because it walks me through everything step by step like the stupid idiot baby that I am. However, one lesson has me totally confused in a way that should make my ineptness at programming apparent.
There's a lesson called "Using break to end a loop early" https://futurecoder.io/course/#UsingBreak I'm familiar with the concept of a "break command" in that it's used to get out of a loop early should a certain condition be met. No problem, but this lesson doesn't actually use the command. Instead, well, just look at it.
Exercise: write a program which takes a list and a value and checks if the list contains the value. For example, given:
This is a horrible lesson/assignment.
I understand the intent of teaching what break does, but this is not the right way to go about it.
Better way to explain break:
output:
this would never count past 3 and would end execution of the loop.
For your assignment of "If thing_to_find in things":
that prints True if the word you're looking for is in that list, and prints False if it's not in that list.
This is a bit of a weird assignment because the most straightforward way to do this in Python doesn't use a loop at all, but you have to write one because the exercise tells you to.
Here's a hint about where you might use a break. Imagine that the list things has 100 million elements in it. The first element of the list just coincidentally happens to be your match. You already have the answer to your question, so do you need to be checking the other 99,999,999 things, or can you just stop there?
print the matching condition‚Ä¶ and then exit the loop :)
Also, in Python, you don‚Äôt have to instantiate a bool variable - you can just print(True)
This is sort of a strange way to teach break in my opinion. The break isn't really necessary and doesn't change the program output, so it's not obvious why you need it here (because you kinda don't).
What's worse is that Python already has a function that just...does this. You could replace all of the code above with this:
Determining if a value or object is contained in a list is such a common operation that there is a built-in in operator that does this for you (among other things). Doing this in a loop with break is actually teaching bad Python programming habits.
I checked the website, and it does indeed give an answer without a break, although it lacks the syntax errors in your post. Not only is this a poor way to teach using break, it's so poor they forgot to include break in their own official solution!
Instead, an easier way to think of break is "this exits the loop." For example:
If you run this, you'll get this:
Without the break, it would continue all the way to 9, but the condition forces it to exit early. This is often used for loops you want to happen until a specific condition is met, i.e.:
Without the break, this loop would go forever, since True is, well, always true. But once the user types a 'y' the break statement forces it to immediately end. Note that the print statement will not print after typing y, even though there's no else, because the loop ends immediately after the break, so any additional code that might be run in the loop is skipped.
Hopefully that makes more sense than the lesson!
They intended you to use a for loop to iterate the list and compare each element of the list to your target (thing_to_find)... When you find it, it should break, so you don't spend resources looping to the end of the list, and print whether the thing_to_find was found or not.
This code will print the exact same thing with or without the 'break', but let's say you have a list of 1 million items, and what you are looking for is the third item in the list... why would you want to go to the end? There are use cases, but it's good to know you can 'break' if necessary...
'break' is also good for breaking custom command line interface interactions, for example... it has many use cases.
Of course you could solve the problem proposed in many other ways, a lot of them more simple, but it's a good thought process for a student, in my opinion...
When I first learned Python, one of the exercises I did was creating sorting algorithms... I mean, why would I do that if I can just type in 'sorted(variable)'? It helps with algorithmic thinking.
I'm going to address your bullet points in order:
you can print a Boolean value just like you can any other value. Try it: print(True)
you're way over thinking. If a given word is in the list, print True. if that given word isn't in the list, print False.
yes, that solution doesn't meet the requirements of the exercise because it doesn't use break. Imagine you're using a loop to iterate over the list and the very first item in the list is the word you're looking for. Do you need to keep iterating the list?
What are people making this so complicated?
things = ['This', 'is', 'a', 'list']
thing_to_find = 'is'
thing_to_find in things
True
thing_to_find = 'other'
thing_to_find in things
False
well .. if they want you to use ..break .. THEN .. use .. a .. loop .. so you can break from?
so what to loop over.. well .. you have a list right?
so ..loop over the list.. then what .. if item equal to whatever break?
hope this made sense.

Comments from https://www.reddit.com/r/learnprogramming/comments/1dbhp9p/advice_people_who_finds_coding_and_logic_confusing/:
One thing some people learn before programming is Pseudo Code, which is actually writing the code in your language in sequential steps, then you write that as a code.
Even though you don‚Äôt right it as a code, just writing Pseudo Codes helps you a lot developing the way you think and write your code.
A simple example:
You need a program that adds two integers, Pseudo Code will look like something like this:
Yes helps a lot especially when you‚Äôre coming back to something next day you just read over logic and if you also comment on each line what you‚Äôve completed helps you jump back into what you need to work on next
Adding to that, I feel like a lot of beginners have difficulty separating the "algorithm" from the "code" --- it's useful to be able to know what you want your code to do, how you want to solve the problem, vs how you actually write it down in a programming language.
You should be able to ask yourself "do I need to figure out how to solve this problem, or do I just need to figure out how to write the solution in this programming language?"
Just to tack on to this. The ‚Äúpseudo-code‚Äù approach of writing out what you need to accomplish works for more things than just code. Work as a systems admin and I don‚Äôt care if it‚Äôs a daily task, new issue, new project, troubleshooting, write out what you need to accomplish and what you think you need to achieve it.
Give yourself a roadmap or a step-by-step approach. Your brain/you will have a nearly insurmountable task of approaching anything new/troubling if you approach it head on. Break things down as much as you can and tackle it on manageable chunks.
Pseudo code is a game changer, it helped me massively when I was struggling!
You just need to come up with a set of symbols to represent the decisions that must happen to get the outcome you seek.
If you're struggling with moving data around or accessing data then get a whiteboard and draw it all out in boxes/memory too.
When you, for example, want to swap two values, you can visualise that problem clearly and see that an extra variable is needed in some languages.
I‚Äôm pretty sure this post is a stolen response from a question posted earlier on this same sub by another user‚Ä¶

Comments from https://www.reddit.com/r/csharp/comments/1f9xfis/im_kind_of_confused/:
I love C# and I hear that I can do some many things with it (I‚Äôm about 1.5 years into programming) and when I go to look up projects I want to do with it it‚Äôs so hard to find certain things I‚Äôm looking for and wind up being suggested other languages. For example, I‚Äôd love to make a chrome extension in C#/.Net and there‚Äôs a few videos out there on it but not as in depth as say JavaScript. Of course we all have to be well versed in other languages but as a C# lover (and beginner in general) what can I REALLY make with it? I know just about anything but I‚Äôm not sure why I struggle to find all its capabilities and where to start. I do blame a lot of it on my lack of experience/newness to coding in general though. So if anything, a better understanding of it would help. Thank you all in advance.
Chrome extentions can't be written in C# as they are primarily a zip file containing Javascript which the browser executes. Chrome can not execute C# as an extention.
I would say that first and foremost, C# was designed to make applications. So when you are in a situation where you do not have a thing, and you want to make the thing yourself from the ground up.
Use the right tool for the right job. Trying to make an extension with C# is like trying to chop trees with a knife. Surely it will work somehow, but how about picking a chainsaw (js) instead ?
I am c# developer I have to say c# shines in API service and game development, but for web better use C# combine with react and angular and for desktop applications electron is pretty good but for quick development use winforms
Learning c sharp will teach you proper programming. JavaScript will not. If you want to code the insides of web pages, you are using the wrong language. If you were trying to do just about anything else.. you are using the right language
How about an ms teams bot? They are fun.

Comments from https://www.reddit.com/r/learnprogramming/comments/3sn6re/so_how_hardconfusingoverwheling_was_learning_to/:
I've tried a few times now and stopped. A big factor has been my work schedule and not having enough time to keep motivated. Of course that is kind of an excuse because if I try hard enough of course I could but it's hard and i've failed.
Anyway..I'll be off work for like 5 weeks now and I want to give this another go and see how far into it I can get.
My goal would be to build smartphone apps, and I laos want to learn web development.
What was you learning experience like? Smooth sailing or what?
It was hard for me. I didn't get a lot of things. I was following tutorials and being told the "whats" but not the "whys". I spent a lot of time trying to learn the "whys" not realising that I wasn't told them for a reason.
The deeper you go, the more you realise you don't know. If you just want to code and have a visual output. It's actually quite easy to learn. You can utilise libraries, tutorials and more.
Once I got over the initial hump, I fell in love with it. It's changed my entire thought process for the better, I'm a much better problem solver, much more wary of my time, proud of what I do, etc. I now zoom in on all those whys and even have opinions on them now, often causing me to write my own libraries based around another - as programming does partially come down to preference.
Five weeks might not be enough though. Without any real motivation it will be difficult. It's a human problem, with any skill, that it's easy to let yourself trail off as you'd rather do something more instantly gratifying.
Real satisfaction and the feeling of accomplishment you get from sticking to a task and seeing it through far outweighs the small pleasures of watching tv, playing games, etc. You've gotta pay the upfront cost if you want to see fruits of your investment.
I'm addicted to programming (I still make time for games of course) as a result and have found happiness in myself thanks to it.
You never finish learning programming. There's always lots more to learn and you'll have to re-learn stuff. Although I think that it's a lot easier once you learn your first languages.
In the end, you'll just have to start learning, whether you're motivated or not. Once you've learnt the basics you'll start coming up with ideas which will get you motivated.
I struggled quite a big in the same way in the beginning but now when i've learnt the first languages, i feel a lot more motivated and find new small problems/projects to solve/make quite often.
A tip is to try to work on something that will solve a problem for you or that will visually show you the progress you make.
Some things that got me very motivated was when I learnt how to use the Mechanize ruby gem. I was sick of downloading lots of pictures by hand (right-click, save as, click on next picture, etc). So I wrote a small Ruby script that would log me into the site and download all the pictures in the album which was around 300. It took a while to write with my limited knowledge but it was worth it. 300 pictures downloaded in a few seconds instead of hours (and it was a lot more fun and educational).
Another thing is when I learnt SQL and a bunch of Ruby web-gems like Sinatra, Datamapper and Bcrypt which allowed me to make a small website that had a database with encrypted passwords, I could sign up, log in and visit restricted pages when logged in.
Try to set aside a time when you force yourself to learn but make sure that you have time over after the "forced" time because once you've started to get into and solve a problem, you can't just stop. :P
I personally think web development is one of the easier programming disciplines, also one of the most enjoyable if you like to see visual changes as you code. There are a few different ways you can tackle web development. Code academy has great courses on the subject to get you started, starts off at beginner friendly level so you should find easy to pick up again.
In my current job 80% of my time goes into web development as a full stack developer(i do everything from the backend to the html/css) when i first started the job i had zero experience in web programming as i come from a c/c++ background, but i managed to pick up php/js fluently in around 2 months. Might take you a bit longer if you havnt done much programming before, but i found it an enjoyable learning curve.
If you have any questions about web related stuff feel free to drop me a pm, on a train currently.
I learnt out of love, back in the IRC boom of the late 90s/early 2000's when every kid used mIRC, to me it was quite easy getting started. These days its quite a bit harder learning the new ways everything works since i havent done too much for a while. Best advice i can give is to learn how to do something back to front, then you can replicate it in any new language you learn using their techniques (for me, irc making an irc bot :p)
Front-end is as easy as daisies for a person with a decent categorical memory ( this thing does that ). Back-end programming is something I've just started doing on a curricular level and I'm scared I won't be able to pull it off.. Shia...I need you
Tbh, the biggest issue I had was learning that knowing the language isnt the key to programming but learning the concepts is. Also, not having a project or end goal makes it impossible. I didn't really start to pick it up full bore until I started doing it where I work. I had projects, goals, and reasons to know X. That drove me more than doing anything on my own and it also forced me to learn the concepts because without them what I was doing or trying to do would never happen. But I may not be the typical case as I did a lot of learning on the job and then went out on my own after I knew what/why/how. Its weird to say nothing really clicked until I was forced to do it.
I think the most useful skill or trait to have in programming (other than a logical/rational mind) is persistence to figure out what's going wrong.
Unfortunately, programming is still at the stage where determining what's wrong is not that easy. Sometimes you can make an error within a language (for example, a syntax error in Java) and a good IDE will let you know where that error is.
Other times, however, the errors are harder to track down because you don't have an accurate big picture of what's going on. For example, you want to program in Java, but you don't realize you need to install a JDK, or you don't know where this JDK is stored, or you know you need a JDK, but you don't know which version you should pick, or which platform. There are dozens of choices, and yet you, the human, has to figure it out. Ideally, you'd download a generic installer, and if you couldn't decide, it would recommend and install for you.
Then, there are a gazillion tools and frameworks out there. Why do I need Maven? Why do I need an IDE? Do I need any of them? Why do I need to learn a debugger?
Or what happens when it's not working? My debugger doesn't show source code? Why doesn't the IDE figure out why that's failing? How can it be that stupid?
Many setups require things to be in the correct folder, and if they're not, it simply doesn't work, and there's often no tool to tell you that the setup is wrong.
And that's just setup.
There's the actual act of knowing what the programming language can do, and then knowing how to think in that language. That's also tough.
I've been suggesting people write journals to get themselves past their mental blocks. Write down where you're getting stuck, and at least then someone might be able to help.
It's very comparable to learning a musical intrument. Some people can pick up a guitar and for some reason it all clicks super fast and they're playing at a professional level in no time.
But for most people you don't get good picking up a guitar once. You need to pick it up again. And again. And again. You need to push yourself to try new things. And chances are if you don't pick up the guitar in awhile you will lose progress.
Programming is exactly the same. Sure there are some people who just get it. But for most people it's tough. And you only get good and stay good through constant practice.
For the 6 months I learnt self-taught, the 3 years I learnt under school tuition, and the 3.5 years I've been programming professionally, it's been consistently hard, confusing, and overwhelming. It's also been incredibly rewarding, and taught me a number of cross-domain skills, such as problem-solving.
It's gonna be hard. The first skill you have to learn, is how to make a problem you have no idea about, into many problems you might have an idea about. This is about 20% of the actual meaningful work that I do, at an estimate.
Took me three attempts till I finally stuck with it so I feel you. I am still pretty novice at it (doing web dev specifically) so there is of course a ton I have yet to learn, but I feel really proud of how far I've come, especially considering my first few attempts to pick up programming that failed pretty hard.
On attempt 1 I think I started trying to learn C++. That was really short lived. Attempt 2 I tried C#, went through a few videos about data types and loops etc., then quit out of a lack of motivation, and probably a lack of understanding, I guess. Many months later, I found this free online course from MIT that uses Python and though I went really slowly, I had a great time learning and this eventually lead to me finding freeCodeCamp (which I cannot recommend enough) and learning web development, which I found I have a real genuine interest in.
If you're interested in web stuff then I would definitely say go for it :D I failed pretty hard a few times before it finally took off, so don't be afraid that your past failures will dictate how it pans out in the future!

Comments from https://www.reddit.com/r/unrealengine/comments/1d0yphu/i_am_just_confused/:
so i am a highschool student in a computer science class and i am doing an independent study on unreal engine and i am just a little bit confused on something. How did people not only learned but know how to code in unreal engine, and yes i know it uses c++ but i mean with unreal's configuration? Like is there some sort of cheat sheet or something or did unreal put out there own classes to teach their audience? Or did people just use their common knowledge and reversed engineered it?
As one of the people you're referring to, ie. an unreal c++ developer - i can tell you that documentation is pretty poor, and it's most often a matter of searching the engine sourcecode to find out how to do things. Fortunately most things you might want to do have been done, it's a massive codebase, but it does take time and experience to read the code and figure things out. Advanced ue c++ dev is not for the lighthearted.
Delving into Unreal's sample projects can help a lot as well, although it's more like a self-guided investigation / piecing everything together on your own, and can feel daunting if you've just started learning about the engine.
I had been making games for 15 or 16 years prior. 
When switched to Unreal, it was like switching from a 1996 automobile to a 2022 automobile.  I knew what the pedals were for and how to adjust my seats and mirrors. I just had to get acquainted with all the features in the dash display and computer.
There is common practical knowledge to making games. Common practical systems. You just have to relearn a little lexicon and a little new tribal knowledge.  
When Unreal introduces a new way to approach some integral gameplay system, like motion matching for locomotion, we have so much historical and foundational knowledge that the new system feels like an invention aimed at our common pain points. So we adapt pretty quickly. 
So, the short of it is, this comes from progressive training and experience over time. Start small, layer complexity into your skillset over time.
Unreal has a pretty large amount of documentation and tutorials provided directly by epic games. Check it out: Programming with c++ in unreal engine
Otherwise you have the good ol' youtube tutorials and blog posts that you can find all over the internet.
For me it's mostly official documentation first, searching appropriate communities (forums, reddit, etc.) second, reading the source code third, and asking questions last. I had some professional programming and gamedev knowledge prior to working with unreal. For this I had my masters degree (for general programming knowledge), and some books and online articles for the rest.
Nowadays finding good sources is rather hard, because many people try to capitalize on the little knowledge they have by doing YT tutorials before gaining hard experience making games. On the other hand, people searching for knowledge want to learn how to make an open-world action game fast, rather than learn from the ground up by making a Space Invaders or Arkanoid clones.
Documentation and source code
The source code is public. You can figure out how to do everything with 0 documentation just by reading the source code. But I‚Äôve been programming for 10+ years now. (Not unreal engine) I couldn‚Äôt imagine someone learning to program trying to read UE source code to figure out how it works 
chatGPT / copilot + reshaper + lot of coding = remember :)

Comments from https://www.reddit.com/r/learnprogramming/comments/11duuf7/is_it_normal_to_confuse_different_languages/:
Recently I started learning JavaScript, but it has happend to me a few times that when working with Python, I write console.log('Something') instead of using print, and the same in JS, I sometimes use print instead of console.log.
Are things like these normal when you just started learning a new language?
There‚Äôs a reason there are cheat sheets for languages. I can‚Äôt be bothered to remember if it‚Äôs print, printf, println, console.log, or something else.
Muscle memory is hard to break. Habits are strong. The fact you have strong muscle memory of Python is a good thing, and yes, it will take you a bit to break it. Soon you'll learn to context-switch easier, but it will take time, and that's normal.
Yes, that's completely normal.
There are dozens of ways to print in just as many languages. It's incredibly easy to get them mixed up.
And that's just for printing! You'll find just as many variations on how to do simple things like uppercase a string.
They're normal when you've been doing it for 20 years.
Source: I still do the same thing after 20 years.
Are things like these normal when you just started learning a new language?
Not just when learning ... unfortunately.
Normal.
Some people write little utility functions to do such things, where they change the implementation when they port the utility to the next language.
Don't do it. Such code will always announce that THIS GUY COULDN'T WRITE PYTHON/C/<insert language here>
Yes. It is just like codeswitching when talking.

Comments from https://www.reddit.com/r/learnjavascript/comments/1cxzigk/new_to_javascript_in_general_and_was_abit/:
Code I wrote: https://pastebin.com/nMgwbgEG
I am kind of new to Functional programming in general. I was told that to be good at Javascript, one has to be good in functional programming. That means no for() or while() loop and no if and else, which instead should be replaced by map(), filter(), reduce(), recursion, ternary operator for ifs and so on.
But I am confused in that I could have written those three seperate filter() followed by map() in a single for loop. Is there some kind of Javascript magic that will make those three calls run in the single loop?
Can you please let me know what else I can improve on? And/or general tips?
That means no for() or while() loop and no if and else
Who told you this?
Is there some kind of Javascript magic that will make those three calls run in the single loop?
No.
You could very well written all of it in one function and in a for-loop. I have no clue who told you that to be good at js you need to stop using those‚Ä¶
I use filters/map/find/sort because my job, like most SWE, deals with MANY objects and big JSON data and lots of functions to call. Especially when you start using promises and async, it will become apparent. It gets messy. Many many times still have to use for-loops
For simple things? Yep, still do for-loops. Hell when I feel lazy, I just go foreach, even whiles.
JavaScript isn't a functional programming language. It is a multi-paradigme language that has functional components. It takes into use functional concepts such as .map or .filter, but is not limited to this. Nearly everything in JavaScript is a prototype based object, and it's includeded the class object because it seeks to copy the benefits of object oriented programming. It is in large an imperative/ procedural language that uses objectoriented and functional concepts to further its reach. Don't listen to anyone who is telling you that using for or while loops is wrong. They were in the language before .map and .filter were. .map and .filter are also not tail recursive elimination functions which functional programming usually requires of these.
Your sources are basically incorrect and you're put a ineffective restriction on your coding. Just do what feels right and feels good. If you find something you are doing is tanking your performance then you can try figure it out by searching how others have achieved the same thing, but don't limit yourself to single paradigm thinking with JavaScript.
You could do all this in one reduce, but that doesn‚Äôt mean it‚Äôs necessarily better than just using for loops. Whoever told you that you HAVE to if/else, for, always use fp iterative methods, etc. was doing you a disservice. Yea, they‚Äôre useful tools to have under your belt, but if you only know how to write code that way and can‚Äôt write a for loop you‚Äôre probably not a very good programmer. A lot of this comes down to style and personal preference, and those things change in the general js community as well as in your work and personal projects over time. Adaptability and solid fundamental understanding is more important than writing the shortest block of code possible.
And this is coming from a girl who writes a LOT of fp-style code.
Why did you make names with underscore in them? Because maybe you used PHP or Python before?
That kind of info can be helpful in the way we may try to explain functional programming i.e. what kind of assumptions you already have.
Here is an example, you have an assumption that it‚Äôs about fors and whiles, but in fact, it‚Äôs about predictability, composability, testability, maintainability‚Ä¶.
To have a pure function, it doesn‚Äôt matter if you put a for inside it, most of the time, but it does matter if you‚Äôre doing IO or getting a random number from Math.random().
It's true that a functional style of programming does not use for loops (ifs are typically fine though). But to be good at JavaScript does not require you do strictly follow the functional paradigm, in fact, most people don't. I, for one, dislike .reduce() - I just find a regular loop to be more readable, almost every time.
That being said, it's still good to dabble in different paradigms to learn what you like and dislike about them.
To review your original code - here are some thoughts. (none of the code samples below are tested)
I'm going to ignore that you used a .sort(), since it seemed to be used inconsistently, and your for loop version didn't have it - I assume it was left in there by mistake.
Firstly, both your functional and imperative versions seem fine to me. I don't have a problem with using multiple .filter().map() like that.
I'd say that most of the complexity (in both your functional and imperative versions) comes from the fact that you're trying to cache your calculations so you don't have to redo them three times. But there aren't very expensive calculations to begin with - I wouldn't worry about that kind of optimization at this stage - there's so many other things that could be slightly improved in regards to performance that it doesn't make much sense to overly focus on this one aspect and not worry about others (e.g. what if, with a bit of work, it was possible to optimize that calculation you're worried about caching, so it ran four times faster?)
This can cause your functional version to be simplified to this:
Next - take a look at using Object.groupBy() - it's a relatively newer method that can be used to turn the three different loops into one.
Lastly - I'll just recommend using camelCase and not putting the opening curly bracket on its own line. The reason for camelCase is simply because everyone does it - you use the built in library or third-party library and it'll be in camelCase, you copy code from the internet and it'll be in camelCase, etc. For the curly brackets, similar thing, but also, I know the JavaScript committee is toying around with adding some new syntax, which if you use it, it'll require you to not have "{" on its own line (they have to do it this way to preserve backwards compatibility). Anyways - in the end its up to you and isn't a big deal, just my 2 cents.
I guess I'm a shit JS developer then, I use for loops all the time, along with if blocks.
You seem to be confused. You can definitely use for and while loops. I'm 90% sure array.map() is implemented using a for loop. Such as in this example.

Comments from https://www.reddit.com/r/careerguidance/comments/1baepcb/confused_about_career_as_a_coder/:
I have 3 yoe and even got my first promotion. I have been wanting to switch my company for 1.5-2 years now but couldn‚Äôt because i am not good at dsa and hence, leetcode. I am very very confused if i should stay in coding or switch to pm. My work involves mostly frontend. Whenever i get any implementation i get scared a little of how it will happen etc but i do it. But if i get a bug to resolve i do it but i dont remember the codebase and i am not able to help the juniors because i dont remember what comes after what, but i do have an overview but not the intricate details. Also, it is a very stressful job. So i am confused. Can anyone please share if they felt the same and what they did? Also, please share your advice regarding remembering the codebase and the intricate details. We are supposed to know the codebase via bug resolution but i never focused on learning i guess and only on completing the work. Please share your advice, thoughts and opinions. Thankyou :)
TLDR- confused software engineer, 3yoe, not able to learn the intricacies of my codebase via bug resolution, not good at dsa (maybe because i never tried being good at it)

Comments from https://www.reddit.com/r/C_Programming/comments/1cxoypb/very_new_to_c_and_confused_why_this_code_works/:
You've stumbled into undefined behavior. Writing outside the bounds of an array is undefined behavior, which means just what it says on the tin: the behavior of this action is undefined. It might work, it might not work, it might crash, it might not crash, it might launch nuclear missiles and end all humanity.
C has no way of telling that you wrote out of bounds of an array. It's up to you to check bounds and just not do that. This is just how things are in a programming language with no safety guards at all.
You did a bad thing, but segfaults is not a guaranteed thing.
That would be too easy.
I think you're asking why 7 is output when (in your mind) you made the string it contains longer? It's because you used sizeof(s1) which is the "size of" the variable s1 that you defined a few lines before as 7 chars. If you used strlen(s1) instead, it would return the length of the zero-terminated string contained in s1.
However you overwrote memory after wherever s1 sits in memory in your my_strcat function, and as others have pointed out that is undefined behavior. Failure to keep track of the size of your strings and buffers almost ruined C programming in the 90's when it was used for all kinds of exploits and caused all kinds of maddening problems in critical systems, because sometimes it would work okay, and sometimes not. You need to adopt solid defense C programming habits early on if you are going to do anything at all of substance in C or whatever project you eventually make will become a mess.
Why does it work? Mostly luck on your part.
In the olden days... space is allocated for s1 and s2. And if your case, s1 also happened to be the destination. And so, odds are you were overwriting s2. If you did something like
and then inspected s2, what do you see?
The length is shown as 7 because that's what you explicitly mentioned to the compiler. Now why is it printing hello world? That's got to do with how strings are stored and addressed. Strings are just arrays with a special character at the last position. Each string here is defined as length 7 but you can only give 6 characters. The last character is null character '\0'. It marks the end of a string.        
But in your function, you're overwriting the '\0' in S1 with W, o, r, l, d '\0'. The first while loop ends when the dest is pointing to '\0'. The second while loop ends when the src points out of '\0'. And the printf statement just prints every character till it reaches '\0' Note that you explicitly need to mention '\0' as well if you're writing the char array as {'h','e','l','l','o','\0'}. It is implied when written as string.    
Side note: there are so many things that can go wrong here. For example, if you use *++dest=*++src, your output will be different
Dangerous
It's UB. Probably the compiler decided that overwriting over s2' memory was ok, try printing s2. Don't do this on real codeüòâ
You only get SIGSEGV (segfault) when accessing unallocated memory because s2 already existed and is contiguous to s1 you didn't get the segfault.
Try changing s2 pointing  to a random address value and you will have your desired behavior or try swapping the order of arguments  passed to my_strcat and you will have a warning about the stack
Note: this being UB the compiler can do anything it wants 

Comments from https://www.reddit.com/r/learnprogramming/comments/13be1j3/confused_learn_programming_and_make_project/:
Hello everyone, I am a beginner in learning programming, I got diagnosed as inattentive adhd when I am 21 years old, but I can‚Äôt buy the meds because the expensive price of meds (I live in 3rd world country), I have several problems when learning programming, here is the list :
I am always confused when learning new concept without implementing it (example: asnyc/ await).
I need a code reference from other project from github or tutorial when trying to implement something new because I have no idea how to implement new features or function in my project, sometimes I am feeling shame of this, because it looks like copy paste.
I don‚Äôt know the keyword when I want to make something, example: I want to make OTP authentication in my website project, but I have no idea how it works and how to implement it into code and in the end, I am always blank in my mind.
I am confused when read documentation, my mind always blank and confused when read documentation, because I cannot understand the meaning of the words and how to implement the code in my project.
Hey so my advice would be to first figure out what you wanna do in terms of programming, is it software development? data analytics? cyber security? then work from there.
I have knowledge in software development so I can help there.
Git
Learn how to use a verison control system like github or gitlab. Basic stuff like how to fork and clone a repo, how to create one, how to comitt and push stuff.
Learn how to use a version control system like GitHub or GitLab. Basic stuff like how to fork and clone a repo, how to create one, and how to commit and push stuff.
Practice these commands over and over , comitting and pushing until its muscle memory when you're typing.
HTML/CSS
HTML would be next , learn all the basics and what each tag does. You don't have to learn every single thing about it but learn enough so that you're able to code things. I've learned that you dont need to know everything only enough to get you by.
CSS is next, same as HTML learn the basics of classes and ids. Choose to either learn flexbox or grid and whatever you don't choose you can learn later on. Try to spend more time with this but not too much because a lot of this you can learn as you go.
Coding Langugue
This is where you pick you're first coding language , this is important because after you choose everything is dependant on this. I would choose either Python or Javascript but its 100% up to you.
Whatever you choose make sure you learn the basics like python, you'll see tutorials about data analytics but don't worry about any of that crap. Just learn for loops, if statements, classes, functions, etc. Spent some time doing some coding questions like on codewars.
4. Frameworks
Before you choose a framework, learn how the web works like HTTP requests, and how a client and server talk to each other. Now you get to choose a framework which is basically a stepping stone to creating a web application.
Depending on your coding language you can do the following:
Python - Flask , Django, FastAPI
Javascript - Node.js
Python - Flask, Django, FastAPI
etc etc
What's most important here is to learn how to write server code so when you make API calls in your front end your backend can take those in and do something with the code so it can get returned. JSON will be your best friend. Spend as much time as possible here learning backend stuff AND learning about the web.
5. Front End Frameworks
React is a pretty good one, Vue, or Angular.
Python might have a few which I don't remember
6. Create a project
It's time to create a project. I would recommend doing a to do list.
It's pretty easy and requires a simple frontend and backend.
Make sure you are using git and pushing and committing all of your stuff through out your whole process.
This is going to be alot and its going to be long and hard but you got this!
This is going to be a lot and its going to be long and hard but you got this. I believe in you. Hope this helps!
How long have you been coding? And how many hours a day on average?
Those are not problems , in anything new you want to learn you gonna face those things

Comments from https://www.reddit.com/r/C_Programming/comments/189cn4d/i_am_once_again_confused_by_an_example_in_a_book/:
This chapter in the book (c programming, a modern approach) is talking about conditional expressions (if, else, else if) and how to use boolean values with it. In the current example the book says:
[ To make programs more understandable, C89 programmers often define macros with names such as TRUE and FALSE:
# define TRUE 1
# define FALSE 0
Assignments to flag now have a more natural appearance:
flag = FALSE;
flag = TRUE;
To test whether flag is true, we can write
Macros are: when the compiler finds a macro in your code, it replaces it with the value contained in the macro, it doesn't store any variables in memory, it simply "changes the source code" every time that macro appears, e.g.:
he would change this code to:
in short, macros are just specific texts that are replaced with their value, nothing more than that.
Preprocessor macros are just token substitutions. The C preprocessor will replace tokens named TRUE with 1 and tokens named FALSE with 0. A flag is just a Boolean variable. The book is saying you can simplify "if (variable==TRUE)" by replacing it with "if (variable)".
About the wording around ‚Äútest‚Äù: this is one of several nomenclatures that describe what the ‚Äúif‚Äù statement does. Different words can be used to describe the same thing.
You can say that it ‚Äúdetermines‚Äù whether the condition is true, or it ‚Äúchecks‚Äù, or it ‚Äúcomputes the value‚Äù, or a number of other ways I guess. One popular one is that it ‚Äútests‚Äù whether the condition is true.
This usage of the word test is quite distinctive from unit testing or functional testing or integration testing or user acceptance testing.
Does this help?
What "C" and if tests are concerned, a true state has the value 1.
The outcome of : (1==1) is 1, when the expression within the parenthesis are evaluted as a logic evaluation, which it is in an if statement. If there was a function call within the parenthesis, and many functions return 0 as a sign of success, then we write the if test like this: if (!zero_is_success()), this is because ! 0 evalutes to not false, which is not 0, which is 1.
Hang in there. In no time, you will see the wisdom and ease of writing C code like:
// Returns 0 if input string is valid
int invalid(char *istr) {
}
if (invalid(inputstr)) {
}
// continue with rest of program
// knowing input is valid ....
this is possible because in C cond-expr, 0 means false and non-zero value is treated as true
True isn't true in the English sense, of being factual. We aren't determining if something is real or a lie, we are determining if it is non-zero. TRUE is 1 (or any + integer, not sure about negatives) by definition. FALSE is 0 by definition. So it is terminology that is throwing you, its simpler than you think. Now a flag is a variable that remembers that something happened ( FLAG == 0 if it didn't happen, FLAG == 1 if it did happen ), so that you can check it later. It may not be happening at the time you check, but it did happen, since you last checked. For example maybe you have a mailbox that the postal delivery people put mail in. If you have mail then the new_mail_flag = TRUE would be set, so that later you can check it, to see if you have to travel to the mailbox and fetch mail. (Otherwise the flag would be FALSE) Its a lame example, but, that's the idea. Also its important to understand that the Macros aren't variables, they are just replacing one kind of constant with another one, when the code is compiling. It would be wrong to say TRUE = 12, for example. Macros are simply there so that you don't have "magic numbers." Instead your code is more readable, and easier to modify if you have to change its value throughout the program. In this case its replacing the ideas of constants in other languages, if you've come across that before.
You could easily define
(Maybe you wrote a program to convert from m to cm, km to m, etc.)
In C if(anything) checks if anything is non-zero. So if(flag) means is flag not equal to zero. It‚Äôs just the way the language is defined.
Just as an aside, since I think others have covers your question quite well; another way to get similar functionality is with an enumeration
enum bool {FALSE = 0, TRUE = 1}
Then you just say:
bool flag = TRUE
if (flag) //true //do something

Comments from https://www.reddit.com/r/Unity3D/comments/168q5bv/guys_i_am_confused_do_i_make_5_to_6_games_to/:
Do you already know how to make 5 or 6 games?
You say this like it is trivial, haha... üòÖ
Well I dont know if It is me but in my personal experience i would tell you to make your own games.
My point is i've done 3 or 4 projects alone and ive reached a level that couldnt have if i made those courses where honestly they will only teach you how to set up Unity and make an YouTube ad tr** game at best
The thing here is having attitude to keep learning avanced stuff even if you are new dev, what worked for me was ignoring basic stuff and working on complex af projects and doing them until i know how to exactly do It all the way i want and getting the exact same results as i imagine since i had the idea using the less lunes of code posible, It is hard but extremely rewarding on the learning process
Of course you will have to read a lot of "useless" documentation (which by the way would help you to know in a near future) only to understand how the code and internal functions work and that will help a lot in the planning and debugging state of more projects you work on.
But if you have this attitudes its just a matter of time that you become a good dev It only depends on how much time you use to improve and how you use that time (which also will perform better as you learn)
Choice is yours, but it is only 40 hours long, so would take you a lot less time to do it than make 5 or 6 games.
If youre the sort of person that enjoys courses, go for it. If you're more like me who'd rather stab myself than sitting through a lecture, and have the attention span of a toddler, just do it your own way and learn as you go.
There's no right or wrong way of learning things, as long as you learn.
Just scroll and see, but from what i can see, it seems like 5 steps to make the same game
make games, you'll have to make them anyways no matter how many courses you take. Why so confused? The best way to learn is to free yourself and start doing the thing, allow yourself to make mistakes. Have the "just make it work" mentality and worry about cleaning up the code for your next peoject.

Comments from https://www.reddit.com/r/dotnet/comments/yqf5sn/im_new_to_the_world_of_computer_science_and_im/:
I wanted to learn how to make apps after only just spending time doing random coding challenges and learning how computers work in general but then once I started learning dotnet it just made me even more confused, like how does this abstraction end up as machine code and how does it work on every platform...?
There are so many classes and things already made for me that I have to dig deep into or else I get frustrated cause I cant learn all of it I hate things being abstracted
Same way as java did it, in java it's called bytecode in C# it's called IL (intermediate language). When you run the application, the dotnet runtime translates the IL to machine code using a JIT (just in time) compiler. JIT compilers nowadays are very complex compilers that use heuristics to determine which code to compile and when. They can for some cases after an initial start up time actually produce faster code than AOT (ahead of time) would have produced. Javascript is another example of a scripting language that now uses JIT compiling to produce very fast code running inside of the browser sandbox.
Nowadays dotnet also has the option of mixed compiling where parts of the application are AOT compiled and part of it JIT. Or with dotnet 7 you can easily just go for full AOT compiling. Of course, in that case you have to build binaries for each platform you want to support.
There's a reasonably good write-up here: https://www.fearofoblivion.com/understanding-cross-platform-NET-and-why-NET-5-is-important
Essentially, there is a platform-specific runtime, which can run the intermediate language (IL) that's generated when you compile a .Net app. So there is a per-platform element, it's just not your application.
Think of it a little bit like how browsers work: you install the browser for the OS you're using (e.g., Chrome has versions that run on Windows, Mac, Android and iOS). Then the browser renders the HTML and Javascript that's platform agnostic.
Well ‚Ä¶ when you get older and people start porting Doom to ‚Ä¶ pregnancy tests ‚Ä¶ you stop asking why and just figure that some people have a lot of time on their hands and are smart in weird ways.
Oh and what other people said about compiling to a portable intermediate instruction set which can already run on other processor families thereby allowing execution without transliteration.
OP probably needs to understand basics of OS‚Äôs, networked, virtual machine, memory, cpu, and how a computer system works conceptually first. By the sounds of it their are gaps to fundamental knowledge and the terms Jit, CLR etc aren‚Äôt connecting yet which is fine.
TLDR: You have .NET Runtime (CLR), language compiler and the language itself. First of all, you compile C# (using Roslyn) to the intermediate language (IL). Then, when you start executing your program, the IL is compiled to nativecode. This is called just in time compilation. And native code gets executed by your machine.
As simple as possible:
After you are done writing your c# code, you need to translate (compile) it to platform specific machine code for it to run.
As there are many different platforms, so how to decide to which one?
What about we create one level between that is more general, like a virtual platform (common language runtime, CLR).
Now, when you compile for CLR and send program to user, his installed net framework tools will translate again from CLR to native code that is compatible with their pc, first time that they runs (Just in time, JIT).
He can then send that same program to another friend with yet again different platform, and for them the JIT will run again, translate for their platform. That way the friend will be able to run too. Clever.

Comments from https://www.reddit.com/r/learnprogramming/comments/12dbbep/video_game_programming_confused_and_want_to_learn/:
Hello, I'm taking a course Video game programming for my degree, and, honestly, I'm a bit lost. We're using Blitz 3D and a book, 3D Game Programming for Teens. I have a hard time understanding. Can anybody recommend any videos to help me understand a bit more?
Videos can be useful, but they are passive and fun, which gives you good feelings instead of results. You need active investigation and experimentation to get results. When you don't understand something, search for an explanation and test your understanding by writing code, when possible.

Comments from https://www.reddit.com/r/learnprogramming/comments/5oh5k0/im_confused_about_objectoriented_programming_oop/:
I've been programming in JavaScript for a while and I'm embarrassed to say that I don't really understand Object-Oriented Programming (OOP) very well. I've finally tried to solve problems using OOP techniques like classes, inheritance, encapsulation, and polymorphism. I'm using Java instead of JavaScript to do this because I don't want to fall back to my non-OOP habits, but I'm struggling because I'm not used to not being able to pass named functions as arguments to other functions and have functions return functions. Because of this, my solutions in Java are much longer and harder to understand. Whenever I write an OOP solution in Java, I can think of a much simpler and shorter non-OOP solution in JavaScript. I'm trying to be open-minded, but it seems like I either don't understand OOP very well or all the people who like OOP know something I don't know. I was wondering if anyone could give an example where an OOP solution is simpler than a non-OOP solution. I think examples would help me understand a lot better because I've already read a lot about OOP and it seems hard to understand because there are never any examples given that compare an OOP solution to an non-OOP solution.
I've written a lot of Java and JavaScript. I struggled with the same thing as you in the past. Here is how I teach people how to think about this:
Nouns which are clear in your mind (User, Order, Song) are often nicely represented by a class (OO). OO is great when you want to write a function (method) that calculates something to do with that noun. E.g. user.fullname()
There are other bits of 'doing' code which just do stuff with these nouns. E.g Go get me 100 users from the database and send each of them an email. This is where OOP gets tricky, often it's hard to find a noun for this, so you're forced to make up a noun (name of your class). Other people might be like WTF when they see it.
Java doesn't really give you any other way to do this other than creating classes. JavaScript you can create a function.
Usually what I do is separate the noun classes (I call this domain) from the doing stuff classes (spring calls them services). I don't really think of the doing stuff classes as classes. I think of them as functions which just 'have' to be in a class.
I'm not used to not being able to pass named functions as arguments to other functions and have functions return functions. Because of this, my solutions in Java are much longer and harder to understand. Whenever I write an OOP solution in Java, I can think of a much simpler and shorter non-OOP solution in JavaScript.
Keep in mind that Java is widely panned as being a verbose language. Don't be surprised if an idiomatic Java solution is longer than one in python or JavaScript. The benefits that Java touts itself as having aren't related to brevity but to ease of maintenance, and portability.
Additionally, OO was historically seen as a substantial improvement to the status quo of procedural languages, not as a massive improvement on functional ones. There's an old programming koan that "closures are a poor man's object, and objects are a poor man's closure" - both have essentially the same power, and closures are less verbose when you only want to return a single function and objects are less verbose when you want to return several.
edit:
To expand on the "closures are a poor man's object" comment, here's an example of a closure as a poor man's object in Javascript:
It should be noted, though, that functional programming generally discourages mutability. Immutable closures, though, can emulate immutable objects.
Similarly, a great example of an object as a poor man's closure in Java is the classic
which creates an "anonymous inner class" to verbosely imitate a closure with as much verbosity as the wordy Java language can muster in its voluble garrulous loquaciousness.
I was wondering if anyone could give an example where an OOP solution is simpler than a non-OOP solution.
The one problem with this is that there's not a universal "non-OOP solution". There are many non-OOP solutions; a particular OOP solution might be simpler than one but more complex than another. Additionally, simplicity isn't the only criterion people value. Ease of ensuring correctness, extensibility, speed, readability (which does depend on the reader), and maintainability all matter, as well.
I'm struggling because I'm not used to not being able to pass named functions as arguments to other functions
That has nothing to do with OOP. Try overloading methods.
and have functions return functions.
Java can do this now.

Comments from https://www.reddit.com/r/learnprogramming/comments/tzkri9/how_do_people_avoid_confusing_syntax_when/:
So, I have been learning java for a while, and now that I wanted to learn the fundamentals of python, I realize that making the switch does not seem very hard (at least in terms of concepts). However, I still wanted to ask how do you avoid confusing the syntax? Also, things like having to cast an int data type if it is preceded by a string literal is easy but that is not done in java (at least not in that way), and so I don't want to mess up my head every time I do the switch. I am probably exaggerating, but I still wanted to ask how you guys avoid confusing syntax
Needless to explain, in java
you just do the following in this simple "program"
int age = 20;
System.out.println("You are " +age+ " years old");
and you don't need to cast it.
Look up he guidelines and best practices of each language in their respective communities. Then use those as your source of truth when in doubt. Python has excellent guidelines and there‚Äôs plenty of good resources for Java as well.
The main thing you have to work on is thinking int language X when using it. Meaning, when you‚Äôre writing Python try to be pythonic and write your code that way.
Java isn‚Äôt going to solve your problems the same way that Python will and vice versa. Learning how you do things with different approaches will make your life a whole lot easier and improve how yo problem solve too. It‚Äôs not the easiest thing, but practice at it and you‚Äôll be swapping languages with ease while be efficient in both!
Frankly, I don't.
When I switch languages from X to Y, it has usually been at least several months since I last did a project in Y. So I write stuff, then it tells me I need to cast something when I try to run it, and I am like oh yeah, better cast that.
But stuff like loop structure, C loops are different enough from Python loops that I don't ever get them confused. But for things like JavaScripts === or how integer and floating point division casting works in each language, I just try it and see what happens.
I don't remember the specifics of how each language works, but I do remember what specific areas are ones that cause problems. And I make sure to test/refresh myself on those when I switch.
You just get to the point where it is you know what you need to do, regardless of the language. Then you just Google the syntax to do that thing until you don‚Äôt have to Google anymore.
Practice and your brain will understand the difference. That's the only solution.
When you program a lot, you'll generally confuse things within the language you use every day every so often, let alone trying to use a different language.
I just try to follow the style guides for each one, see where things are similar, where they're different, and I'm able to compartmentalize them well personally. Not really any secret other than basically having a lookup in your head of "okay I'm making a method in Java, here's what the best practice is for that language". Over time you'll get better at knowing those things and then you can always look it up for everything else.
Automated processes to format your code or check styling is always helpful too, like .editorconfig files. Most IDEs support it and it automatically flag style issues (like C# wants curly braces on a new line, whereas Java has them at the end of the same line for when declaring blocks of code).
I don't avoid it, I get confused and have to look stuff up. It's worse the more similar languages are (eg Ruby and Elixir).
You just mess up and fix it when it errors lol. I do it frequently working with JS and PHP. I‚Äôll put $var + $var2 instead of a . , annoying but it happens like muscle memory after working with one for a while

Comments from https://www.reddit.com/r/AskProgramming/comments/mo2vtf/i_am_confused_about_choosing_the_right/:
Language doesn‚Äôt matter to much. But the biggest value right now is learning JS with Typescript. Lots of jobs that are looking for JS devs that have a decent grasp. A quick React app and some material ui can have something that looks decent with minimal effort.
Though really for just a blog you could do it in markdown and host it on github pages. Keep it simple and easy to maintain. Or really the suggestion to use a prebuilt solution would be better.
Really depends what you are trying to get out of creating the blog.
None, you just pick a pre-existing blogging engine and are done. There are literally millions to chose from.
I really like static site generators and use Hugo with Github pages (free hosting) myself. Doing so, I learn more about git, markdown and the vanilla web technologies (js, html and css). While not really dipping into a single programming language that much, it allows me to explore a bunch of technologies during my blogging pursuits.
There are drawbacks to static sites also, but for blogging I think they are a perfect match.
The Odin project is a full corse in Webb development. It will teach you about creating web sites and most technologies you will need(html, css, javascript). It is probably one of very few self contained resources for becoming a web developer
If your goal is just to make a blog as soon as possible and you do not wish to learn to program, I would stick to a pre-existing blogging engine as many people in the comments pointed out. However, if you are interested in learning programming then this is the essence of web development.
Web sites are conventionally made using 3 languages: HTML and CSS for the visuals and JavaScript for the functionality. TypeScript is a superset of JavaScript that has static types (Instead of typing var x = 5 you can type var x: number = 5 which prevents a bunch of common bugs). TypeScript is often used in larger projects but can be a bit daunting if you have no prior experience of programming.
Web servers. The thing that sends the website to users. They are often written in NodeJS (Same as JavaScript but for servers), but may also be written in other languages, like PHP. However, I strongly recommend sticking to NodeJS as you only have to learn one language then).
Database. To store your blog posts you need some kind of database. You can do it in pure JavaScript, but it's not going to be very efficient, and for larger projects, you should use a database. There are two kinds of databases.
The first category is SQL databases like PostgreSQL (Used by Reddit), MySQL, and MariaDB. SQL databases use the SQL query language to retrieve information from the server. Data is typically stored in tables with rows and columns of specific data types.
The second category is NoSQL databases like MongoDB, Redis, and CouchDB. NoSQL databases are simply databases that do not store the data in tables or use the SQL query language. An example of this is MongoDB, which sends back JSON documents.
I would recommend starting with something like MySQL since it's relatively simple to understand and there are a lot of resources for learning how to use it.
Learning resources. I recommend W3Schools for learning HTML and JavaScript. The tutorials by Bucky Roberts (TheNewBoston) are very good albeit a bit slow-paced.
TLDR; HTML and CSS for the visuals, JavaScript for the functionality. NodeJS for the webserver. MySQL for the database. Start by learning how to make a website.
I like python and django, it's really easy to get started with. And python is a growing language as opposed to php.
Another option would be javascript and node.js. Personally I prefer using django, if nothing else than the fact that designing the software with django is probably easier. Node.js is a solid choice, but it's very modular and if this is your first time building something then it may be a bit overwhelming.
Not one language as most websites are typically built with some sort of stack of language each doing different things. A react based stack will probably work and if you plan on using this to learn programming try using typescript instead of javascript.
If the purpose is to create a blog, then concentrate on that and choose an existing blog tool.
If the purpose is to learn programming then it depends on what you want to build.

Comments from https://www.reddit.com/r/Indian_Academia/comments/15hc54o/confused_about_career_need_suggestions_about/:
I am a female .Listen from start my_qualifications is I am a electrical engineeringstudyent don't know much about coding but still trying to became a developer but every single time deep down Iwant to give a chance for upsc don't know why.I am a fresher so Ineded to improve mu coding also purchased a course so that improve coding but whenever I see ips or someone on instagram postIalwaysthoughtI I should try once but simultaneously in my mind come ups I cant leave my job then I started thinking to do master I even don't knowimn which subject soo as I got some time from job and can run from all my decisions. Side by side I think I get a platform for coding I should utilise it.literally confused because I cant even give my 100% in job nd not confident about my work. Till college I was always very confident about my work. Please help and give suggestion
Hi friend,
Till college everything was structured and there was a clear path. Study XYZ syllabus for X exam, pass with X%, and so on.
Now, you are in a different world outside college.
It is not easy for me to help your situation through text messages. I suggest you consult a professional counsellor/coach. I'm assuming you have a job, so you can pay for this consultation. This will help you solve your problem.
Best wishes!
Not gonna lie, this aspirations of getting a Govt job also triggers my major goals as well. But do understand it ok I can sound biased here, but for a female, the IT Industry is extremely good to land your career ahead, if you are really willing to invest some time preparing for it, probably 1-3 years at max, even if it's not like that you gave all your efforts, earned nothing, learnt nothing and landed no job. Eventually you will secure a good job and get better packages with time.
You must always have a backup plan to sustain your life and responsibilities financially. After a certain age, you know very well that parents and families do require your financial support and you too need money to handle your expenses and save some money.
Lets say, you are preparing for the govt job exam. Can you do your job and study simultaneously for govt job exams? Are you sure that you are willing to invest at least 2-5years in govt job exam preparation, and sure about what you can actually get? If you didn't get UPSC level posts but managed to secure another govt job, will you choose it or land again in IT because of packages?
There are indeed multiple questions that arise while taking such decisions, as you are an engineering graduate, your career is safe in both ends, either govt job or tech job. Now it becomes your call that where do you see yourself.?
Please add some paragraph breaks to your submission by placing a blank line between distinct sections. Users are more likely to read and comment on your post if it's more readable!
I am a bot, and this action was performed automatically. Please contact the moderators of this subreddit if you have any questions or concerns.

Comments from https://www.reddit.com/r/cscareerquestions/comments/4216nu/frightened_and_confused_about_programming_and/:
Dude who cares if you can't remember the C syntax and need to look up the mechanics of a linked list. I work in the field, have a CS degree, and need to reference everything non stop all day. The job is not a closed notes test man.
With that said, by the end of the year you should have a pretty decent grasp of what a linked list is an how it works/how it differs form other data structures
This may or may not make you feel better, but I had a math class with weekly quizzes, and I failed the first 3. I ended the class with a B, and to this day I couldn't really tell you much of what I learned. The professor gave me that grade because I had a grasp on the big picture and I worked my ass off, constantly coming in to office hours and asking lots of questions in class. Making an effort is half the battle.
Once you start working, knowing the concepts is really all you need. You can look up syntax, and stuff you use a lot you'll learn over time. Just don't go crazy pushing yourself to an impossible standard. You'll be fine :)
I agree with what a lot of people here are saying. It's definitely scary to get into, and at times I also feel like I'm not doing well enough to succeed.
What I've done to combat that is look at both what my last year is going to look like (what courses I'll be taking) and what skills are required for a software developer. I created a list of what skills I want to be proficient at and started working towards that.
The person who said that people talk themselves up a lot is entirely correct. In all of my classes, I meet people who talk about how talented they are and how trivial the classes are, and those people are the ones who tend to do pretty poorly. Even if they are good, they become complacent and don't study well, don't give the class the attention it deserves, and as a result they don't get grades as good as you.
Don't pay attention to your peers unless you're actively working with them. Just focus on learning as much as you can while you're still in school, try to gain as many skills as you can. In the end, you're going to have a fantastic transcript which will show that not only are you good, but that you are able to learn, which is incredibly important when you're looking for a job. If you do that, you're going to be in a much better position than the people who decide to settle for Cs and low Bs because they think they already know everything.
Although it may seem a bit ironic because of everything I just said about people trying to show off, you're very much not alone. I think a lot of people, especially programmers, tend to convince themselves that they're not as skilled as they really are. If you're not familiar with it, maybe look up imposter syndrome. It's unfortunate but rather interesting how many truly talented people fear that they'll be "exposed as a fraud".
tl;dr you're not alone, don't worry about anyone else and just focus on being awesome. If you put in the effort, you'll excel.
I don't have that extra spark of motivation to go out and code on my own.
I don't code on my own. I do enough of that at work.
I'm somewhat interested in continuing education because learning is a lifelong process so I read a chapter or 2 about coding practices every so often.

Comments from https://www.reddit.com/r/learnprogramming/comments/18l06pt/help_needed_a_confused_person_here/:
I have been trying to change my career path so I have taken up coding from scratch . In between CS50 and the next logical step feels like a coding boot camp where they teach Java, Python and other languages (Full Stack Bootcamp - the course is called). However I came across some job posts in some of my preferred companies that they are looking for MERN developers. Full stack MERN bootcamps are really scarce.
I am now really worried and confused. Which one to go for? Can anyone help me with the difference between the two things/direction? What should I do?
MERN stack is basically developing everything with javascript. Learning one fundamental language OOP like Java, Python of any other is usually the better route. They're all different in terms of how you'd write code but the logic is the same underneath the hood. Though if your dream company uses MERN, then you need to know that, aka js and its respective tools. Though then you're bound by that for a bit in terms of job search. Up to you.
fullstackopen is the best MERN course in existence, it'll take you a long time to complete though, like 3 months.

Comments from https://www.reddit.com/r/learnprogramming/comments/1f1if6m/im_very_new_to_programming_today_and_im_stuck_on/:
i am following a youtube video and im very sure im following it correctly but there is a problem and i cant find it id just like advice because i dont find any comments about it on the video im using unity
here is the code i have
public class playermovement : MonoBehaviour
{
public Rigidbody rb;
public float forwardForce = 2000f;
void FixedUpdate()
{
rb.AddForce(0, 0, forwardForce * Time.deltaTime);
If statement have opening bracket if (
And usually closing one )
You seems to forgot closing ()
When you are starting, you should try asking ai. 
I love Microsoft copilot. 
I don't know which IDE (integrated Developer Enviorment) you use, but I use VSCode and that helps alot, if there's an error it will tell you on which line there's an error (It's great for these kind of errors)
Also, I am still learning, it might be bad advice, if someone disagrees please let me know

Comments from https://www.reddit.com/r/learnprogramming/wiki/faq/:
Welcome to /r/learnprogramming. This is a list of some of the most frequently asked questions on this subreddit. If your question is one of these, it has probably been answered many times before, and you should try using reddit's search facilities (look in the sidebar) to find previous answers before posting here.
If you're interested in learning to code, it's very helpful to start with the right mindset. This YouTube video by Kevin Cheers does a great job of explaining the proper perspective you should have when starting out.
Next, you should keep in mind that there's no universally agreed way of learning to code -- everybody prefers learning in a slightly different way, and you may need to do some experimenting to find an approach that works best for you. Nevertheless, the majority of people seem to learn best using the following approach, which we strongly recommend you try:
Here are some things we recommend you avoid doing:
And finally, remember that learning to code can be a long and difficult (wayback machine link since the original has been deleted) process. If learning to code feels hard, don't get discouraged! That's completely normal -- many people will spend years of their lives learning and practicing before they consider themselves competent enough to look for a job or contribute to a significant project. Fortunately, just getting started is not difficult at all.
There are two common misconceptions that cause people to ask this question. The first is that there actually is a "best" programming language for learning and the second is that the first language you learn will decide what the rest of your programming career looks like.
In reality, there is no best language to start with, and your first language has virtually no lasting effect on your eventual career. Programming languages can look very different on the surface, but the majority of the fundamental concepts will transfer from language to language. Learning a new language will also get easier over time -- it can take a beginner months before they feel comfortable with their first language; an experienced programmer can become familiar with a new language in a matter of days.
All programmers should ideally have experience in multiple types of languages. Once you are comfortable with one language, move on to another language which differs in some fundamental way. As you learn more languages, you will become more equipped to choose the right tool for the task at hand, which is a hallmark of a good programmer. Since programming concepts are what matter most, we recommended that beginners start with one of the mainstream languages from the table below. All these languages enable beginners to start writing simple applications and practice programming without having to use any of the more complex language features.
If you already have a project or goal in mind, you will learn faster if you can apply your skills to the problem you are trying to solve. The table below contains some recommended language choices for common projects:
If you still can't decide, try Python. Python is a good, beginner-friendly language with a huge community and many libraries for doing almost anything you want, ranging from making games to automating things at your home or workplace or doing data analysis to making websites. Try to find a learning resource which focuses on concepts and fundamentals before diving into more complex applications.
A common question we get from many beginners is "now what?". In particular, you might have tried working through some tutorials, books, courseworks, but ultimately have difficulty making the gap from understanding how things like if statements and for loop works to understanding how to actually apply what you've learned to make complex and interesting programs.
Making this jump between intro tutorials to complex code can be difficult, and is a normal part of learning to code. This article describes this phenomenon very well. Many tutorials (in particular, commercialized "learn-to-code" websites like CodeCademy) tend to hand-hold you through the basics, but stop after that point, leaving many beginners floundering.
However, if you stick with it and work through the confusion, you'll eventually find yourself gradually growing better and better, until one day, without realizing it, you'll find that you've started to become competent.
Here are some suggestions on how to persevere, and what you should be doing next.
Switch from passive learning to active learning
Rather just taking courses and classes that (you hope) will teach you what you want to learn, start actively researching for ways to teach yourself. If you have no idea how to make a game, for example, google "how to program a game in X", where "X" is the programming language you want to use. If you run into an error message you don't recognize, try googling it. Want to learn how to do machine learning? Google, and find a textbook, tutorial, or online course that seems good.
You'll often be able to find tutorials explaining what exactly it is you want to do, or at least articles that give you overviews and clues on how to compose more specific search queries. More broadly, there's no shame in doing research to learn new things -- quite the opposite, in fact. Googling and researching is something all programmers, both beginning and advanced constantly do.
Constantly be practicing
Programming is sort of like exercising, in that the main way to improve is through constant practice. Start simple, and try programming a basic game like "rock-paper-scissors" on the command line. Once you finish, try picking a more ambitious project, and work through that. Perhaps try some programming exercises, if you want to mix things up.
Programming, fundamentally, is really about applied problem-solving, and the best way to learn how to problem-solve is to constantly be solving problems, big and small.
(See also FAQ: Where can I find practice exercises and project ideas and FAQ: I can't come up with any cool new ideas for a project. Am I simply lacking in creativity? How do other programmers become inspired?)
Learn how to decompose problems
When you're trying to tackle a large project or problem, it's easy to become discouraged by just how big or intimidating the task seems. Instead of being intimidated, work on breaking the problem up (decomposing the problem) into smaller and smaller subproblems, until each individual subproblem seems manageable and doable.
For example, let's say you wanted to make a rock-paper-scissors game. Well, if you really break it apart, this consists of several subproblems: how to get input from the user, how to make the computer pick a random option, how to tell who won, and how to repeat the entire thing (if you want to play multiple games).
If you're not sure how to solve each of these subproblems, try breaking it apart more. For example, if you're not how to tell who's won, you could break it up into more sub-problems: how to tell if you've tied, how to tell if you've won (assuming you picked rock), how to tell if you've won (assuming you picked paper), and how to tell if you've won (assuming you picked scissors).
If you're absolutely not sure (for example, how do you make the computer pick a random option?), try googling it. In this case, googling "X pick random option" (where X is the programming language you're using) will bring up multiple different methods you could use. Sometimes, you can break a problem up into many pieces before needing to google, and sometimes will need to do so immediately.
For example, if you're learning Java, want to learn to write games, but have no idea where to start or how to break the problem apart, googling "java game tutorial" would bring up several good results that would both teach you how to write games, and (usually implicitly) how you can break down the process of writing a game into smaller pieces.
Essentially, you're trying to gain the mindset of an engineer. If a problem is big, don't give up. Keep breaking it up into smaller and smaller pieces, and research things that seem irreducible. Then repeat, continuing the cycle: break down, google, break down, google...
This, by the way, is a pretty effective strategy for self-teaching! As you practice, you'll get better at seeing how to break down problems, and will expand your pool of knowledge/possible solutions to problems.
See FAQ: How can I improve my skill to convert tasks/problems into programs (Algorithmic thinking)? for more suggestions.
Learn how to be systematic
When coding and debugging your code, never fall into the habit of just "trying" things and hoping they work. Be as systematic and rigorous as possible, and avoid "trial-and-error".
When writing code, take a moment to pause and plan out in paper a rough plan of attack. Consider sketching some diagrams, or jotting down some pseudocode. If you have to change your plan (which you most likely will), think about why you're making that change, and what your new plan of attack is. (This planning phase is also a good time to practice problem decomposition!)
When debugging, never be aimless. Try and think like a scientist -- conduct experiments to either try fixing the bug or to narrow down where the bug might be, and record your results. If your hypothesis/attempted change turned out to be wrong, or if something worked when you didn't think it would, stop, pause, and figure out why. Consider tracking your experiments and tests in a notebook, if it helps you stay on-track.
Bugs happen when your assumptions don't match up to reality. If something feels "off", don't ignore it -- trace that down until you pin down what the issue is/what incorrect assumption you made.
Don't just "do" random shit until you get lucky -- be systematic about it.
Don't be discouraged by having to debug or google
Something that not all beginners realize is that having to spend more time debugging or googling is perfectly normal, even among professional programmers.
Debugging (and struggling!) is an essential part of coding. Try to avoid being stressed out or impatient, if possible. Treat it as an interesting hunt or a puzzle!
Even if you're making no progress on your actual code due to some bug, as long as you're being systematic, you're still practicing your problem-solving skills, albeit in a different way.
As a result, even if you spend many hours working through a single bug, you should still consider it time-well spent. Debugging is one of the best ways to become good at problem-solving!
(This is even more true as you grow more experienced. It turns out that the the difficulty of bugs you encounter will grow and scale with your level of experience. It isn't uncommon for experienced programmers to have to spend months tracking down just a single bug if it turns out to be particularly nasty.)
Don't be afraid to ask for help
And finally, if you're completely stuck and have no idea what to do next, don't feel bad about asking for help!
Programmers are generally very helpful. Many of us are also self-taught, and so understand what it's like to struggle as a beginner and what it's like to be completely stuck.
As a caveat, make sure you've done your due diligence (tried decomposing the problem, tried debugging, tried googling, etc), and make sure you've written a good-quality post. Like any subculture, programmers tend to have certain implicit rules and expectations. One of the key ones is that your question should be well-written (even if it's basic).
See our guide on asking questions for more info.
Try taking a more rigorous intro course
This bullet point only applies if your only exposure to programming has been really basic "intro-to-programming" courses like CodeCademy. Those sorts of websites are good at giving you a taste of what programming is like, and teaching some of the basics, but may not be helpful if you're trying to progress to an intermediate level.
As a good rule of thumb, if whatever "intro to programming" course you took did not really challenge you, or did not ask you to work through exercises and mini-projects, you should consider finding a more rigorous one. Constant practice (and struggle!) is an essential part of the learning process.
For more perspectives, suggestions, and advice on making this jump, see the following posts:
Project ideas:
If you are trying to make a project, here are some lists of ideas you can reference for inspiration:
Especially in the early stages:
Big lists:
Project ideas accompanied by tutorials or writeups
Other:
Want to do something challenging? Try re-implementing programs that you use every day. For example, try writing your own...
Practice exercises:
Here are some good sites/resources to start with:
Language-specific:
Other:
This is one of the most commonly asked questions.
The general answer is: By writing lots of programs.
However, there is a simple exercise that can help you to build up that skill:
As stupid as it may sound, it works. The above has been tried on many students and proven to produce significant improvement.
For starters, here's a good quote from Chuck Close on (not) waiting for inspiration:
The advice I like to give young artists, or really anybody who'll listen to me, is not to wait around for inspiration. Inspiration is for amateurs; the rest of us just show up and get to work. If you wait around for the clouds to part and a bolt of lightning to strike you in the brain, you are not going to make an awful lot of work. All the best ideas come out of the process; they come out of the work itself. Things occur to you. If you're sitting around trying to dream up a great art idea, you can sit there a long time before anything happens. But if you just get to work, something will occur to you and something else will occur to you and something else that you reject will push you in another direction. Inspiration is absolutely unnecessary and somehow deceptive. You feel like you need this great idea before you can get down to work, and I find that's almost never the case.
You'll rarely get ideas by just sitting around and waiting for a spark of inspiration. Your time will be much more well-spent if you just go ahead and try building something (anything!), even if the idea seems somewhat stupid or already done.
After all, that's what artists and musicians do -- they don't necessarily start by trying to come up with a highly creative drawing or compose their own music. Instead, they draw landscapes or vases, or cover existing songs. Similarly, don't feel obligated when coming up with project ideas. Re-implementing existing programs is a time-honored tradition -- see how far you can get!
But in any case, here are some other ideas and tricks for coming up with your own projects:
Before you start, please keep in mind that studying existing code is not necessarily the best way to learn programming. Programming, in the end, is about applied problem solving, and the best way to get better at problem solving is through lots of practice. Just reading existing snippets of code isn't likely to teach you as much. Usually, when people do study code, it's in a targeted and specific way. For example, if a dev was interested in writing a game using some engine, it would be helpful to see the source code for various demos using that engine.
In any case, try checking out the Showcases section on Github. It has a curated list of tons of popular and interesting open-source programs that range from libraries and games to music and open journalism/data analysis, and is a good showcase of what sorts of things people are doing with code. The source code is also publicly viewable, so you can try downloading and tinkering with these projects yourself.
Also see The Architecture of Open Source Programs, a series of free ebooks that contain more guided walkthroughs on how popular open-source programs are structured. The latest book in the series, "500 lines or less" might be a good starting point since the programs are small enough that you could feasibly tinker with them yourself and use them as a good jumping off point to start your own project.
If you're interested in self-teaching yourself material covered by most standard computer science programs at the university or college level, the following links give a good overview, with links to additional learning sources:
What every computer science major should know - Matt Might
Focuses on giving a high-level overview of different fields, and more importantly, why they're valuable. Also contains some reading recommendations.
Open source computer science degree - Open Source Society
Gives more of a concrete roadmap, with links to mostly Coursera courses per each topic.
Teach yourself CS
Similar to the previous resource, except it mixes in recommendations for both books and video lectures. The upper-level recommendations focus mostly on systems (e.g. operating systems, databases...).
A Self-Learning, Modern Computer Science Curriculum
This resource is a bit unconventional and recommends a far more mathematical approach to learning computer science, focusing on topics like discrete math, functional programming, software verification, proofs, type theory, and complexity theory.
Please keep in mind that high-quality computer science degrees tend to be very rigorous and demanding. If you're interested in pursuing this path, it'll likely take you several years and a lot of hard work to acquire a similar level of education via self-teaching.
First and foremost: get a full, comprehensive understanding of the problem.
Often, Rubber Duck Debugging helps with this step. Explaining a problem or concept to someone (or something) that has zero knowledge or understanding helps to gain a deeper insight into the problem. By doing so, one has to think a lot more about the problem which will lead to a deeper understanding.
Second: Don't go straight to the computer!
Spend considerable time pondering about the problem/task. Create some sketches, drawings, some pseudocode, some plain language hints, whatever may help on paper (I'm emphasizing this here because digital tools are distractions from the actual task at hand - use only pencil & paper or a whiteboard.) Analyse the problem thoroughly.
This leads us to the following.
Remember one thing when tackling big projects by yourself:
Everything in the world is made of smaller parts.
This means that basically whatever big machine, house, skyscraper, car, train, computer, etc. you look at consists of many smaller structures that, combined, make the final product. The smaller structures consist of smaller structures and so on.
The same applies to big programs. They consist of many smaller units that are coupled together to form the whole. Ideally (but often not possible) each smaller unit should work (and be tested) independently from the others.
Start small. Look at the problem you have chosen and try to break it down into smaller parts. Rinse and repeat until you think that you can't break it apart any further.
Once you have reached that point, start programming. Build one small part, test it. Build the next small part, test it, and so on.
Don't look at the final, big picture as this will overwhelm you. Tackle one individual part at a time.
The biggest problem inexperienced programmers face is that mostly they get overwhelmed when they look at a large task. But this problem is not too difficult to overcome:
Don't try to see the final program with all bells and whistles. Focus on a small, manageable part, complete it, and move on. Even the most complex program/system consists of small, simple parts.
How do I keep up with it?
Imagine that you are working for a client and the client needs to see and approve your design before you start to code as they might have one or another comment, or they want to make sure that the communication between them and you worked and you understood their requirements.
Some additional advice:
No, you can learn to program, and possibly have a career doing so, at any age.
There's a common myth that the only way to be good at programming is if you start learning to code at an early age. This is false -- while there are some people who start learning to code early (and so might have a bit of a head start), most people will start to learn to code when they enter college, or later.
Learning is something you can do at any age -- rather then focusing on others, just focus on yourself, and your personal rate of progress. Try and cultivate a "growth mindset" rather then a "fixed mindset".
There are very few prerequisites -- for the most part, you can jump straight into learning to code.
The only real prerequisites are:
It's also helpful if you know some math (up to the basic algebra level) and if you know English (because many online resources are in English), but the two aren't required.
All of the above is also more-or-less true if you want to get a formal degree at a university. Most universities and colleges expect incoming students to know nothing about computer science and programming, and will start by teaching you from scratch (though in some cases, you can skip one or two intro courses if you pass a test or demonstrate enough prior skill). If you're in high school or earlier, and want to study computer science at college, then it might be good to start studying ahead of time to get a head start, but you shouldn't feel obligated to do so.
Some colleges may also have more stringent general education or math prerequisites (most colleges have calculus as a pre-requisite, for example), but this will vary from college to college and is something you should directly investigate and ask the colleges and universities you're interested in attending about. See below for more details.
Not necessarily - programming and computer science is a wide and broad field, and whether or not you need to be good at math depends on what discipline you chose to specialize in.
For example, some disciplines of programming do require strong math skills. 2D and 3D games will make frequent use of vectors, matrices and linear algebra; data analysis and machine learning make use of many concepts from statistics and calculus; and working out algorithmic complexity is easier if you have a good grasp on algebra and basic calculus.
In general, the more advanced and complex the topic, the more likely it is that you need to have a strong mathematical foundation. If your goal is to be able to work on those types of complex problems, then having a good foundation will be invaluable.
However, just as many aspects of computer science and programming do not require a good understanding of math. The only things you really need to know are how to add, subtract, multiply, and divide, and maybe a little basic algebra. Many programmers go through their entire career with having to do barely any math at all.
In particular, many product-facing roles (e.g. web development, mobile development) require very minimal knowledge of math. In those sub-disciplines, what matters most is your ability to write robust and maintainable code, as well as your ability to figure out how to build things that are valuable to your users.
In any case, if you're not very good at math, you can definitely learn and improve! After all, you're presumably not very good at programming yet either, but here you are, learning to code. Check out Khan Academy and you can find free lessons starting from basic math on up. Also see /r/learnmath for more resources.
Do note, however, that the answer is a bit different if you are interested in getting a degree in Computer Science. Many universities or colleges will have specific prerequisites you need to fulfill before you can either enter the major or graduate (calculus classes, etc). And, since Computer Science is, to a certain degree, applied mathematics, you will almost certainly end up learning about discrete math, writing proofs and other similar topics while earning your degree. You do not need to be inherently good at math in order to learn these topics (or any mathematical topic, really), but having some mathematical maturity certainly wouldn't hurt, and would probably smooth the learning process.
Exactly how mathematically-focused a CS degree will be differs from school to school. Some schools place a heavy emphasis on covering theory, while others de-emphasize both in favor of focusing on application. (And some schools emphasize both). If you want to find out more, you should directly investigate the degree requirements and structure of whatever colleges or universities you are interested in attending. We will not be able to easily predict what direction some given university will skew.
To summarize, you do not necessarily need to be good at math if you want a successful career as a developer. If you want to be a computer scientist, you will end up learning a fair amount of math. If you want to work on harder problems/within certain domains, math can be a helpful tool, depending on the situation.
YES. Here is a thread which discusses the topic from a variety of angles. There are many more like it.
Programming is like most skills: it's relatively easy to learn the basics and apply them. If you want to learn to bowl - you'll figure out how to put your fingers into the holes, and chuck it in the general direction of the pins. You might even knock a few over, and not find it particularly difficult.
Programming is also like most skills in that it is much more involved to go from a beginner to someone with a degree of skill. To continue the bowling analogy: if you want to become a competition bowler, you're going to have to spend years mastering the skill. The same is true of coding: you're going to need to spend some (that is, a lot of) time trying to figure out why this stupid program won't work even when you've checked it three times. You're going to need to read books, sit through lessons, and talk to people about it. You're going to learn jargon. You're also going to specialise - learning more about a few small fields really deeply. All of this still uses the basics of programming, but in new ways, and new combinations. Finding solutions to your problems will be hard. Focusing for hours on the same problem will be hard. That's okay, because if you enjoy it, and you're motivated - the hard parts don't feel as hard, and you can get through them.
In summary, programming can be hard. Just like with most things, it takes effort, and that effort can be hard. Don't be discouraged - if you enjoy it, the hard parts will be worth the reward.
Is it normal for a beginner to fall off a bike a couple times? Is it normal for a beginner to sink a couple times when learning to swim? Is it normal for a beginner to miss notes or play the wrong notes when learning an instrument? Is it normal for a beginner to burn some meals? Is it normal for a beginner to struggle to complete their reps when working out at a gym?
Absolutely yes!
Failure and struggle is a very important and natural part of the learning process. Failure teaches you how to not do things and gives you valuable feedback on how well you understand something. Failure is just another word for gained experience.
Failing and struggling is something every beginner goes through: you're supposed to struggle. So instead of feeling discouraged, you should embrace this: struggle is a sign that you're challenging yourself. Use it as a guide to help you figure out what material you need to review and learn next, or what questions you should be asking.
Even experts fail and struggle when they need to learn new material (though they tend to be better at recovering/using failure as a way to help them accelerate their learning).
In fact, if you aren't struggling, that's a sign that you're almost certainly doing something wrong. If everything is easy, that means that:
It's similar to exercising. If you don't feel physically tired after a workout, did you really gain much out of the exercise? Similarly, if you don't feel mentally tired or mentally challenged after working on some coding challenges, did you really learn anything?
If you rely on motivation, you will fail. Guaranteed. You need to rely on discipline and routine.
If you manage to establish a routine and employ discipline, you will improve your skills, which, in turn will motivate you to continue.
Please, read this article as well as part two at the bottom of the linked page. The second part offers some "mind hacks" to help you.
In short (and quoted from the article): you don‚Äôt wait until you‚Äôre in Olympic form to start training. You train to get into Olympic form.
One more "life hack": Use Jerry Seinfeld's "Don't Break The Chain" method to keep you going.
To "know a language" for programming is similar to knowing a language for speaking. You can say you know it when you can use it effectively, even if you don't know "everything" about it. To "know how to program" generally means that you understand the concepts related to programming and you can use them effectively in one or more languages. Read some past threads on the topic.
Especially when you're starting to learn how to program, it's best to learn one language and stick with it for awhile. Even if a particular problem domain uses a specific language that you don't know yet, first learn how to program. Once you understand the fundamentals (flow control, error handling, I/O, implementation of algorithms, data structures, etc.), then you can start worrying about picking up different languages.
Unless you have a good reason to, most beginners should stick with just one language for at least a few months. This is a more efficient way to learn for several reasons:
There are some exceptions to this guideline. It's fine to learn a second language alongside your first if:
If you do not consider yourself a beginner and feel comfortable using your programming language to complete moderately complex projects, it would of course be fine to try learning multiple languages at once. At this point, you should have enough understanding of programming to start picking up new languages at an accelerated pace and should have a good sense of how much you're capable of learning at once.
Check out /r/GetMotivated/ and /r/GetDisciplined
Often we think "if I were motivated enough... then I could...," however; it is action that drives motivation. First comes action, then motivation. Find small, specific programs to create. Get rid of the distractions. Get browser plugins to block websites such as Reddit, Facebook, and Twitter. Take a minute to visualize how great it will feel when you have become a more knowledgeable programmer.
Here are some past threads on this topic:
Modern video games are made using game engines: software libraries that handle complex tasks like graphics, sound, physics and networking. There are many options available - However, the following engines are strongly recommended for beginners as they are free to develop with and have the best documentation for learning:
Always remember that your goal is to develop games, not engines!
Engines will help you get started with graphics and user controls for your games, but you will still need to thoroughly learn a programming language to write your game logic - so pick a good Book or Online Resource.
Most importantly: Start simple. You will want to dive right in and create your dream game straight away, but remember that the only way to climb a mountain is by taking many small steps. Here is a list of simple practice games listed in ascending order of difficulty - consider trying a few of these before jumping right to your end goal:
Be sure to check out the /r/gamedev FAQ, read the /r/gamedev "How to Get Started" guide, and perform some searches for past threads on /r/gamedev and /r/learnprogramming.
There are many different ways to learn about web development, but in general, the core skills that you need are usually divided into frontend skills (code that runs on a user's web browser), and backend skills (code that runs on your server).
In general, most people will recommend that you start by learning HTML, CSS, and Javascript (in that order), which are the core three languages that run on every web browser and makes up every website.
You can find more information on the /r/webdev FAQ. Here's another list of online courses, tutorials, and resources for beginners.
You will need to learn a different programming language for each type of smartphone.
You can also make apps that can run on all three major smartphones using technologies such as Phonegap and Titanium -- they allow you to write your app once using HTML, CSS, and Javascript, and run your app on any platform.
See the list of mobile app development resources for more information. Here is a past thread on the topic: http://redd.it/352f09
However, do keep in mind that many, if not all, of the above sources are geared towards people who already have some prior experience with programming. If you've never programmed before, you may want to start with learning a language which has more resources geared towards beginners. Once you've acquired some experience, and learned about the underlying concepts behind programming, you'll often find that it's much easier to learn a new language and begin learning about mobile development. The Getting Started section in our FAQ has some more info on where to begin.
For Windows there are a couple dedicated programming languages, such as Autohotkey and AutoIt.
Another viable, cross platform alternative is Python. Automate the Boring Stuff with Python is a great learning resource.
If you want to automate MS-Office, use the built-in programming language Visual Basic for Applications (VBA). /r/vba is dedicated for VBA programming.
/u/thekodols compiled a list of more than 150 "what are the best" questions and answers in this post covering various languages, tools, and topics
CS/CE/SE vs Programming/Coding
Computer science (CS), computer engineering (CE), software engineering (SE), programming, and coding are all terms that are interrelated yet subtly different from each other, often making it difficult for beginners to tell them apart.
The first distinction you should make is to distinguish between CS/CE/SE and programming/coding. CS, CE, and SE are all fields of study. Saying "I'm studying computer science" would be similar to saying "I'm studying chemistry" or "I'm studying literature". In contrast, programming and coding are activities -- they're things you do. To use a metaphor, studying CS/CE/SE would be like studying musical theory, while learning programming/coding would be like learning how to play a particular instrument.
Theoretically, you could learn one and not learn the other, but your experience will be much more enriched if you learn both.
Another difference is that while CS/CE/SE are things that you can study, learning to program is something that only comes through practice. And in fact, what most universities and schools will do is formally teach one language to teach the basics of coding, then will focus on teaching CS, CE, and SE and leave you to learn how to program through practicing and completing homework.
CS vs CE vs SE
The next distinction you should make is between CS, CE, and SE. In a nutshell, though there's a lot of overlap, "computer science" has little to do with either computers or science and is more of a field of applied math that studies the concept of computability. Computer engineering is similar to CS, but tends to focus more on lower-level hardware -- it's like a cross between computer science and electrical engineering. And finally, software engineering is more about how to build large and complex programs while preventing them from collapsing under their own weight -- it's like CS and CE, but with less theory.
You can find a more detailed overview here: http://www.reddit.com/r/learnprogramming/comments/2k569h/eli5_computer_science_vs_software_engineering_vs/
Programming vs Coding
And finally, you have programming vs coding. The difference between these two terms are very small -- many people use them interchangeably. In general, the term "programming" seems to have slightly more positive connotations then "coding". If you say "I'm a programmer", it implies a certain level of professionalism -- it indicates that you can not only write code, but also have a firm grasp on the fundamentals and theory, know how to communicate with clients and work with others, etc.
In contrast, if you say "I'm a coder", it usually implies that your focus is exclusively on writing code, and less so on the other things.
However, again, the different connotations are very small here -- you can use the two terms interchangeably in the vast majority of cases.
TL;DR - C, C++, Objective-C, and C# are not different flavors of the same language.
C is the smallest and the oldest of these languages. It was originally created as a systems programming language for the Unix operating system, and is still widely used today for applications programming.
C++ is a very popular, general-purpose programming language, originally based on C. With some tweaking, most C code can be made to compile as C++ code. However C++ adds a large set of language features which change the way the language is used significantly from the way C is used. It is generally considered a bad practice to write C-style code in C++.
Objective-C is a strict superset of C, meaning that all valid C code is also valid Objective-C code. Objective-C is not nearly as popular as C or C++, and is mainly used today in development for Apple's OS X and iOS platforms.
C# is not based on C in any technical sense. C# is a general purpose language designed by Microsoft and is similar in many ways to Java. It compiles down to an intermediate form which runs in a virtual machine (CLR), unlike the previous three languages which are all compiled to native machine code. While C# borrows syntactic elements from C and C++ (as does Java), it has no real technical relation to those languages.
Java is related to JavaScript in the same way that a grape is related to a grapefruit.
Similarly to the previous question, Java and JavaScript are not related in any technical sense. They share a bit of syntax as they are both influenced by C, but that's about it. Wikipedia has a good explanation of why the name similarity exists: Wikipedia: JavaScript and Java
This is a question that appears frequently and often confuses beginners since on the outside both seem to do similar things.
/u/donsagiv wrote a great and simple ELI5 (link to original comment):
A boy scout has badges that merits them to do certain things, such as cooking, swimming, starting a campfire, canoeing, etc. The boy scout troop doesn't care how they were able to do these things (i.e. swimming with the breast-stroke, back-stroke, etc.) as long that they meet the specification for it (being able to move in the water by a certain, controlled movement of the body while staying afloat). Each boy scout can have zero or many badges, meaning they are certified to do each of the things merited by the badge.
Despite that, they are still boy scouts. Every boy scout is allowed to attend their periodic meetings, wear their uniform, etc... A boy scout doesn't need a badge to swim. However, they can't go river-rafting unless they have a swim badge. Edit: a swim badge can't swim by itself. It is merely an indicator that the boy scout it's attached to can swim.
The boy scout is the class, and the swim badge is an interface it implements.
Every object that of the class that is instantiated have the same functions (i.e. attending periodic meetings, uniforms, etc). If the class implements an interface, the class MUST have be able to perform the functions specified in the interface (i.e swimming, canoeing). Some classes can't be used in certain parts of your code unless they implement that interface (i.e. going river rafting requires swim badges). Edit: An interface is an abstraction, so it can't be instantiated. (A badge by itself can't swim.) To sum up, an interface is a contract a class must follow in order for a class to implement it.
Interfaces and classes behave differently in different languages (My example is from what I know in C# with generics). I suggest you read the documentation to your language carefully.
Interfaces can also be used to collect objects from different classes (they act like a data type).
You could collect all boy scouts who can swim, regardless of their nationality, gender, age, etc. and go river rafting. You don't need to know anything about the individual boy scouts, but you know that each of them is able to swim.
Start here: The Missing Semester of Your CS Education
A Version Control System (VCS) is a tool which keeps track of the changes to your code, and allows you do handy things like undo coding errors and see what has changed in the code over time. Modern Distributed Version Control Systems (DVCS) also allow you to work easily with other programmers on the same code. And yes, you should definitely be using a version control system!
The two most popular DVCSs are git and Mercurial; which you use mostly comes down to personal preference, but we strongly advise you to use one of them.
You can start with git by reading a git primer, written by a redditor, and also the free git book.
A good, brief tutorial on Mercurial is here.
We have links to download sites for both pieces of software on our tools page.
An IDE is an Integrated Development Environment, which is a GUI application that generally includes a text editor with code completion and syntax highlighting, some project management features, a compiler or interpreter (either configurable or included), and many other fancy features to make writing, running, and testing code easier. The alternative to using an IDE is to do what the IDE is doing for you automatically on your own. This method requires the programmer to use separate tools and to have a more in-depth knowledge of the development process.
For beginners, there are arguments for both of these development methods:
Using an IDE means that you don't have to know as much about the development process, don't have to use a command-line interface, and don't have to configure those tools to work together correctly; an IDE offers a quick way to get your code building, and may even write some of the code for you!
On the other hand, working from the command-line means that you don't have to fit in with the mindset of the IDE's designer, and since less of the development process is hidden from you, you get a better understanding of the software build process.
Use of an IDE versus separate tools generally comes down to a matter of personal preference (unless of course your employer/school requires the use of a specific development environment). If you've never used an IDE before, download one of the popular ones and tinker around with it. And if you've never used vim or compiled code from the command-line, try it out and see if you like it. A list of common IDEs and lightweight text editors can be found in Programming Tools.
A common question many beginners have is what sort of operating system they should use -- Windows, Mac, or Linux.
It honestly doesn't matter -- in this day and age, the quality and maturity of the tools available to you are going to be about the same on all platforms, and any decent programming language will be usable on all operating systems.
That being said, you should eventually gain some level of familiarity with all three operating systems so that you're not completely lost when you encounter a new kind of OS (for example, when remoting in to another machine or when you arrive at a new job).
There are two main exceptions to this rule:
There are a number of good options for running C# code on other platforms, but some Microsoft and .NET tools are still primarily targeted towards Windows.
While you can develop Mac and iOS apps on any computer, you must use Xcode on a Mac machine to compile and submit your app to the app store.
Finally, it's also worth noting that you're not "locked in" once you've picked an operating system -- it's always possible to run a virtual machine (VM) with another operating system installed. For example, if I own a Windows computer, it would be very easy to set up a Linux virtual machine that I can use without fear of it interfering with my existing Windows OS.
Again, it doesn't really matter -- any mid-range laptop or computer should do. If you already own a computer or laptop, you should just use that instead of purchasing a new computer. Basically, you can learn to program and can write complex and interesting programs on pretty much any computer in existence.
If you're basically destitute and without any usable computer, you can always check places like Craigslist for a used computer, or ask around. You can get very far with an old computer if it's just for learning.
However, if you happen to need to buy a new computer and want to use it for programming, you should prioritize CPU, RAM, and hard drive space. If possible, try and obtain a computer with the following specs or better:
If you can upgrade, it's probably safe to prioritize getting a better CPU and more RAM over getting a larger hard drive -- a beefier CPU will always help. In contrast, most kinds of programming don't require you to have a lot of disk space: the only exceptions would be if you're trying to do something with images or videos, or if you want to download and analyze large data sets while learning about machine learning and similar things (and you can typically store those things in the cloud, if it comes down to it).
If you want to purchase a desktop, these specs are really the only relevant ones. If you want portability, you should purchase a laptop and make sure that it comes with a big enough screen and keyboard to be comfortable programming with. However, there's a fine balance between usability and portability in a laptop:
It's also worth asking yourself how you plan on using your laptop. Do you plan on just having it sit on your desk all day, or on carrying it all around campus, or on going hiking in the Yukon with it?
If possible, try testing the laptops you're considering in person. If you find typing on particular laptop's keyboard to be unpleasant and not something you can get used to, for example, you may want to give that laptop a pass no matter how good it looks on paper.
If you are also trying to buy a laptop to prepare for classes in university or college, you may want to try checking their website/the website of their computer science or software engineering departments to see if they have any more specific suggestions and recommendations.
For more information, and for more detailed help, visit the following subreddits to get more personalized recommendations:
You may also want to be cautious about buying Chromebooks -- they'll require either some degree of customization or will require you to work using online editors and IDEs and require constant internet access. For more information, see the following links:
You should be even more cautious about trying to use tablets or phones as your primary programming device. While it's possible to program using a tablet or phone with some effort, nearly all software development is done using desktops or laptops using a keyboard.
If you need advice on picking a specific brand, just keep in mind that programming doesn't require anything special from your computer. This means that a good general-purpose computer will, in all likelihood, be a good programming computer. (This makes searching for a good laptop easier, since you don't need to try and search for one specifically marketed towards programmers.)
One final optional constraint: If you're specifically interested in doing machine learning, natural language processing, or graphics (including game development), you may want to consider purchasing a machine with a GPU. While you don't need a GPU to do any of these things, you can often speed up your code by carefully writing it so that it takes advantage of GPUs (when possible).
If you're interested more in machine learning or NLP, do note that you can rent machines with GPUs in the cloud via services like Amazon Web Services (AWS) or Google Compute Engine (GCE) for relatively cheap prices.
The general answer is yes provided that you have some device that can run a web browser.
There are plenty online IDEs and courses.
A few examples
Maybe, but only if you are good at it. But you can also earn lots of money as a plumber, or in any other number of businesses. You can also fail horribly. Programming is not a guaranteed, safe job.
This question is mostly out-of-scope for this subreddit: try subreddits like /r/cscareerquestions instead.
But briefly, yes and yes. It's possible to get a job without a CS degree and without a degree in general, though with decreased probability.
If you:
This question is mostly out-of-scope for this subreddit: try subreddits like /r/cscareerquestions instead.
To answer simply, there is no 100% guaranteed way of landing a job and no 100% reliable way to check if you are ready to start applying for one. The best you can do is work on improving your odds of being invited to an interview, submit your resume, and see what happens.
If you are not getting any responses, try posting your resume for feedback in /r/cscareerquestions' weekly resume review thread.
See the How do I break into the industry and get an entry-level job section below for more details.
This question is again mostly out-of-scope for this subreddit -- career-related questions are better asked on /r/cscareerquestions and by consulting their comprehensive wiki. Also see /r/cscareerquestionsEU if you are living in the EU.
But in general, there are two main phases to getting an entry level job, assuming you already know how to code:
The two stages require somewhat different strategies.
Phase 1: Build a resume that stands out
In phase 1, your goal is to steadily start adding items to your resume that help you stand out (or at least help make you comparable to) any other applicants that are applying.
One particularly helpful strategy for doing this is to start building a portfolio of non-trivial projects you can show off to prospective employers. Your portfolio could contain anything ranging from:
Having a strong portfolio shows employers that can successfully apply programming languages, libraries, and technologies to solve problems and gives them a way to more accurately gauge your skill level. (And, as it turns out, working on non-trivial projects is also one of the better ways to improve your skill level in general!)
To put it another way, you want to establish that you have a track record of successfully building relatively complex things. If you don't have any prior job history in this field, working on projects is one of the better ways of doing that.
Some additional notes:
Your projects don't necessarily need to be visually flashy. Most recruiters will focus on your resume (and often will read only your resume!), and recruiters with a technical background will understand that not all interesting projects have or need a slick interface. What's probably more important that you can honestly describe your project on your resume in a way that showcases the complexity of the work you did.
Perhaps the main exception is if you're applying to a role that requires some visual flair. For example, if you're applying to a frontend web designer role, it would help to have projects that show you can make a polished and usable website.
Of course, working on projects aren't the only things you can do. Doing things like getting a degree (preferably in a subject related to computer science) will also definitely help. Just keep in mind that many job applicants will also have a tech-related degree, so just having one might not be sufficient to help you stand out -- you'll also want to take full advantage of any extracurricular opportunities your school has to offer. Good schools will have many potential side projects you can get involved in if you dig a little. Having access to those potential side projects is one of the biggest benefits to paying tuition.
Some people also attend bootcamps in part to expedite the process of building a relevant resume/portfolio. Just be sure to do your research before committing to a bootcamp: some are great, and some are outright scams. Before committing to any one bootcamp, try reaching out to alumni of that bootcamp on sites like Linkedin to see how they feel, try checking to see if the bootcamp reports stats on CIRR, try asking people in a variety of different communities (not just reddit)... Also see /r/cscareerquestion's FAQ section on bootcamps.
If your resume is not getting a lot of attention, try posting it for review on /r/cscareerquestions' or /r/cscareerquestionsEU's weekly resume review thread.
If you are not sure if you have a strong resume, try comparing it against ones posted in /r/cscareerquestions' resume advice threads
Phase 2: Pass the interview
What exactly happens in phase 2 (pass the interview) can vary from region to region. For example, many silicon-valley-esque companies prefer asking data structures and algorithms questions, so if you plan on applying to those types of companies having a strong foundation in that topic is a must. This may not necessarily be the case in other parts of the world or for other kinds of companies.
Some common interview archetypes you may run into include:
Note: this is not an exhaustive list. You should also keep in mind that different employers will look for different things and interviewing practices that are common in one area may be almost completely unheard of in another. So, we strongly recommend you network with developers in your local area and ask them for advice.
Also see /r/cscareerquestions' wiki -- and perhaps /r/cscareerquestionsEU if you're living in the EU.
There comes a time when every programmer grows up, and they face a problem, they are plunged into the real world. In the real world, there is no hand holding or major guidance. Instead, you need to learn how to make your way. If you've come this far, you should have a field of interest, may it just be general programming, web development, algorithms, or anything of that sort. Maybe, you want to learn of other, different fields involving programming, or maybe, you just want to know what to do next.
When you started programming, you might have wondered on when you would learn to create the next Reddit, or when you would learn about being able to make those fancy graphics, or how to perform different algorithms. Well, if you consider yourself to no longer be a beginner, then you have programming under your tool-belt. Now you need to learn how to apply it, and how to strengthen in it. Very soon you will be able to do these things, and be learning all about them.
Many people face the fear that they are not competent enough while programming. And thus, many want to improve their programming skills. But, at this stage, there is only one way to do that, and this is with practice. There are many sites and locations dedicated to practicing, things like /r/dailyprogrammer, CodeWars, HackerRank, Project Euler, and many others.
For a list of affiliated communities, see Posting guidelines > Related communities -- and in particular, the "Real-time help" section.
Please note that /r/learnprogramming is not officially affiliated with any of the communities listed on that page. The moderation teams of all of the listed communities are distinct and independent from this one.
Try checking out /r/ProgrammingForKids and /r/CSEducation. Both subreddits will contain useful resources and suggestions on how to teach others.
You can also try running this query to find past discussions about this question.
Some commonly-recommended resources include:
Participate in one of the projects in the /r/learnprogramming github group! This group was created by jfredett with the express purpose of providing projects for new programmers to learn how to contribute to open source by interacting with more experienced programmers as mentors.
The group is still in its infancy but several people are working to get it up and running.
Here are some websites that contain links to projects thare are actively looking for contributors of all levels of experience, and will often link to open bugs or issues that are very approachable for beginners.
Here are some past threads about working on open source projects.
Try consulting our language-specific wikis to see if your question is listed there:
Check the quick troubleshooting guide for beginners and the FAQ page for the language you're using to see if it's answered in either location. If not, post away!
Try also checking our list of related communities.
This FAQ, and the rest of the pages in the /r/learnprogramming wiki, are community-edited. These answers are the product of the community, and they are from real people. If your question is listed here in the FAQ, it is because it has been asked many times before. This FAQ is a collection of the commonly given and accepted answers to these questions. Please consider whether your question really is substantially different from what is answered here in the FAQ before asking people to take time to give personal replies to a question that has been asked over and over.
If your question really is substantially different, and the answers in this FAQ are not satisfactory, then please indicate in your post that you have read the FAQ and say exactly how your question is different and how the answers here are not helpful to you. This will show that you have already made an effort to find an answer to your question, and it will help to focus the replies to your question.
We encourage you to contribute, but for now the wiki is moderator editing only to prevent spammers from uncontrolled adding of their links. Please send the moderators a message with the information you would like added/changed. The moderators still reserve the right to reject changes if the suggestions are not suitable.
If you are tired of seeing questions about a particular topic, message us mods with:
If the mod team agrees (a) the question is frequently asked and (b) has a canonical answer, we will convert your draft into an FAQ entry and start removing questions about the topic per rule 4.
If you don't feel confident drafting an FAQ entry, free to start a discussion thread crowdsourcing answers and links.
Requests asking the mod team to simply remove a certain category of question will usually be ignored. The purpose of our subreddit is to help people learn to program; simply removing questions without directing people to a place where they can get answers does not do that.
If this is not something you have the experience or time to do, another option is to start hanging out in the 'new' queue. The 'new' queue is where most of the subreddit regulars hang out; 'top' or 'hot' is not really representative of what this subreddit is about. If you want this to change, try upvoting posts in 'new' you think are interesting or have high-quality answers.

Comments from https://www.reddit.com/r/learnprogramming/comments/1e29sj7/ive_started_learning_programing_few_weeks_ago_and/:
I have learned some basics of HTML and CSS so I started javasctipt but there is an issue. when I learn something new and how it works, I easily forget or get confused about it. kind of struggling all the time and I just wanna know if it is normal or am I supposed to change something?
I‚Äôve been doing this for longer than you ‚Äî decades longer than you ‚Äî and I still forget stuff right after I finish it.
I use an IDE with a simple full text search feature. If I can remember anything about an old project, I search for that thing and it finds what I did. Sometimes seeing the old stuff makes me cringe for how bad it was.
Be patient with yourself. You‚Äôll get this.
When starting out it is completely normal.
You need to practice, practice, practice, and practice more. This is the way to improve and retain.
Sure, dont worry about sharing;) just keep at it.
Good start, you are now a real programmer. Try to stay confused about something new all the time.
Learning is struggling. Think of the "confusion" you feel as the "loading..." time your brain needs to sort things out. It's like a price to pay.
The more you spend actively in that "confusion" state, the more you're refining your knowledge and making it permanent. Pen and paper are useful to sort ideas in your head. That's my take, but you can find your way.
When you see somebody very knowledgeable, you're seeing somebody who spent lots of time in "confusion mode".
The genius are those who enjoy that state. That is what sets them apart.
We mere mortals struggle and feel pain, but if you can set apart at lest 1 hour a day for "confusion time" as a goal, you can get pretty far in the long run.
Get used to the feeling. It's normal. You will probably be pretty lost for the initial projects that you build and heavily reliant on learning references. To actually retain the information you are trying to learn, you will have to practice it A LOT.
It's like learning a language. You don't just get it after a few lessons or even an entire course of material. You have to immerse yourself in it. Read it, write it and speak it for an extended period. Expect to be confused.
Unless you have some sort of neurological deficit, repetition (doing the same thing again and again) will help to "solidify" your memory. Similarly taking notes (preferably on paper) cabn be helpful.
You can't just follow a tutorial then move onto the next one right away and expect to remember everything about previous ones.
Yes, it is normal. why dont you show us what you built so far? Do you hack on some project, doing some exercises or?

Comments from https://www.reddit.com/r/learnprogramming/comments/1b3g8a4/new_quite_confused/:
I guarantee you there's a video for whatever extension or framework you can think of. Videos about the language are broad because not everyone is using the language for one purpose.
Just gotta find the right source of info.
Wrong courses and wrong approach from your side.
Pick one language and stick to it. Programming languages are not Pokemon. You do not need to collect them all.
MOOC Python Programming 2024
MOOC Java Programming
Both from the University of Helsinki. Both free, extremely practice oriented and both proper first semester of "Introduction to Computer Science" courses.

Comments from https://www.reddit.com/r/HTML/comments/1cvy0jl/coding_is_confusing/:
I started learning HTML recently and watched hours of HTML tutorial videos. My confusion comes into play when after the initial tag. Is there a specific order to code something? For example, I have a meta tag in my practice code under the head, but when I watch other people's code, they have it designed entirely differently. Can I get some advice?
The general layout of a webpage is as follows
This is just a general setup. The <head> tag is more for page setup and loading external links and stylings. The <body> tag is where you place the content for your webpage. The order of the tags inside the <head> tag are not in a specific order. Above is the order I use, but they can be placed in any order. The important part to note is that your external links and stylings load from top to bottom, so if you are calling multiple style sheets, the later called sheets have the ability to overwrite the ones that are called first, if you want to set them up that way.
Edit: If you have any questions about this or anything else, please feel free to ask!
meta tags go inside of the head tag.
<head><meta></head>
Depends what you are coding ig? But usually the way we form tags is: <a> <b></b> </a>
Also take it easy when coding a lot of things will not make sense and you will probably forget some, but thats how it is. Happy coding!

Comments from https://www.reddit.com/r/godot/comments/1ampjk4/i_am_confused_what_should_i_do_next/:
So I've been activly learning Godot for two weeks. I have 0 coding experience, so I watched CS50 before starting Godot tutorials.
After CS50, I've completed GDQuest "Learn GDScript from zero" cource. Next, I finished "Ultimate Introduction to Godot" video guide on YouTube. Then, I've completed HearthBeast recent space shooter game course.
I found all of them quite helpful and learned a lot (at least I think so)
However after trying to make my own game using stuff I learned I failed miserably. Yea, I know it's a common thing, but I am asking you for advice, cuz videos I found don't really help.
What should I do, to keep learning and don't burn out quickly? These are some of my own solutions:
1.Remake the most basic classic games (pong, flappy bird)?
2.Come up with a simple game, which I can make by collecting peaces of information from different guides or by googling?
I would recommend remaking classic games. Should teach you about different ways of doing things. Just keep practicing, learning game dev takes time and patience :)
You could also try coming up with a simple game after this, when you feel more confident. Basically everything you've outlined is a good next step.
Learning programming is like learning how to bike. You don't learn it by watching other people do it. I think remaking pong or flappy bird is a very good idea. Try to not look at tutorials though until you are actually stuck. And try to use the documentation before you look at tutorials.
If you're coming into this with basically no prior programming experience, that's probably going to be the biggest bottleneck to you getting anything done.
So yeah, start small. Super super small. Doesn't have to be classic games, but they do offer a good starting point so sure, in that order you could try working your way up the complexity ladder with:
pong
breakout
alien invaders
flappy bird
super mario
This is a hard one, but I think the answer is similar to the advice people get for working out: the best exercise is the one you enjoy!
The key for any hobby is to do what you like, so you‚Äôll keep doing it. As long as you keep doing it, you‚Äôll keep getting better. That being said I have a few pieces of advice:
game jam! Try a two week game jam. This was how I made my first ever game, and I remember distinctly thinking before that I have no idea how to make a game, and thinking after that I have no idea how I made that game. Something about game jams shake you out of that paralysis and force you to perform regardless of your skill or ability, and sometimes being forced to perform is all you need.
Google! Google !! Just because you‚Äôve completed all these courses doesn‚Äôt mean you‚Äôre done learning or using tutorials. I‚Äôve been using godot for almost 5 years now, and I‚Äôve also Taught Godot to students before, and I STILL constantly google solutions and tutorials.
expand on a tutorial! Find a tutorial for a game genre you really like (I personally used Heartbeasts arpg tutorial), follow it through with custom art (I find this creates problems and forces you to think a bit more) and when you‚Äôre done with it, expand!
Before I ever made a game, my first project that taught me godot was this weird souls-like arpg. After finishing the tutorial, I spent a month adding enemies and items and a really complex inventory. It took me forever and was terrible, but it was really fun, and I had a much better understanding of godot when I was done.
4. sleep on it, literally. When I first learned godot I went through a similar process to you, and for some reason it WOULD NOT CLICK. And I couldn‚Äôt tell why! It was so frustrating I stopped for a few months and didn‚Äôt touch anything godot related at all. When I finally got back to it that summer, everything finally clicked and I could suddenly make games.
I didn‚Äôt do anything, my brain just processed all this information in the background. Sometimes when you learn a lot of complex information pretty fast, your brain can‚Äôt really get a handle on it. You just gotta wait and give it time to process
Conclusion)
The ideas you gave were also really good, and you seem pretty smart :) I gave you my personal experience learning game dev (I was 15-16 when I did so), but for what comes next? Whatever seems the most fun. Game dev is a hobby, and it‚Äôs a Really fun hobby, so make sure to chase that fun
I also have experience teaching godot, so if you ever want help with a project, reach out to me. I love teaching!
ETA: sorry for formatting, I‚Äôm on mobile
One reason old games are recommended is they're are often well studied and documented in the Game Mechanics and Design. And sometimes source code. But that's arguably less valuable to learning than the High Level concepts.
Another reason is they are often SIMPLE and LIMITED in their actual mechanics. With only a few core actions a Player can do, or can be done to them.
Doom is very well understood game, with open source code. But it is not simple.
You can do a sort of sanity check by describing what you're doing in Verbs.
Super Mario Bros. and platform games can be described as:
Walk
Jump
Fall
Everything else embellishment. With Touch or Collide being the lead-in to a secondary set of Mechanics.
Touch enemy
Fall Touch enemy
Touch warp pipe
Walk Touch block Fall
Slowly building a vocabulary of Verbs (game mechanics, actions), and Nouns (game objects, scenes made of nodes) to act on.
Remember that Game Design is not the programming (implementation). Hopefully CS 50 went over the concept of Design Documentation and pseudo-code.
My ADD brain never really stuck with remaking classics since I don't care about making that. I'd suggest to come up with a very small jam scope game that roughly aligns with the kind of games you want to make. Like it could be a single core mechanic from some bigger thing you want to make. Then figure that out.
But generally, you just need to intentionally make something without automatically repeating some tutorial in a monkey see, monkey do fashion. You need to apply your knowledge in a new context.
The godotneers youtube channel has some of the best tutorials available, and they focus on best programming practices and like figuring out how to go about organizing things and implementing features in your project. If anything you should watch their components video, I honestly feel like it should be required watching for new godot devs

Comments from https://www.reddit.com/r/learnprogramming/comments/123j6pi/i_want_to_implement_dsa_but_im_confused_which/:
I'm beginning my coding journey and I'm confused. Whether I should go with C++ or JavaScript or phython to learn DSA I don't want to take part in competitive coding contests so please do suggest me which language will be easy to implement DSA consepts
Using DSA concepts in programming is like constructing long sentences in speech, so asking what programming language you should learn for DSA makes as little sense as asking what language you should learn to speak long sentences in.
Data Structures and Algorithms are concepts you will need in every programming language. If you want to force yourself to program everything, learn assembler. Assembler knows nothing about data structures or algorithms.
Every single higher-level language has some of those concepts built in. The languages on the higher end, like python and JavaScript, have tons of algorithms readily available, so for teaching purposes they won't do. C++ is difficult to go and learn, but it will help if you choose game development as a career.
Right now you're better off learning c or rust.
DSA is all about understand how information is stored in memory. The operating system is in charge of allocating memory, this means you are given a block of contagious memory that does not belong to another process and you can use it as you please as long as you don't go outside the boundaries. You need a language with pointers and a way to ask for a block of memory (malloc?) so javascript, python, and Java will not work. C, C++, C# will work.

Comments from https://www.reddit.com/r/learnprogramming/comments/nxrhhf/why_do_i_feel_like_high_level_programming/:
I have been coding in C since when i know how to code, i love C, i also know C++ but dont use it frequently.
But Java, Javascript and basically all high level languages are really confusing to me, i feel like they dont follow any set of rules, the language gives the programmer too much freedom that a beginner like me has no idea how to do something properly.
I often hear peoply saying Java, javascript or python is easier than C/C++, it makes me really doubt myself. Maybe i am not a good programmer at all.
Does anyone feel the same ?
Languages in the real world are there for people to communicate ideas.
In computing, languages are there for the same reason. That is to communicate your thoughts to the computer so that it can carry them out.
When, in the real world, you want to communicate ideas better you come up with jargon. For instance chemists can communicate using the technical language of chemistry, that us lay people find very difficult. But it allows them to convey their ideas easily. This jargon is effectively an abstraction, and used so they can talk about complex things simply.
Same with computer languages. Depending on how and what you want the computer to do, you choose an appropriate level of abstraction, which you're experienced and comfortable with.
Low level computer languages like microcode give you control over the buses and pins on the cpu. A level up, machine code, gives you control over the CPUs built in instructions,which are just abstractions over multiple microcode programs. Assembly language gives you a slightly more human readable version of machine code. Higher lever level languages like C and beyond abstract the instructions of assembly language, so you can write programs more simply, and so on.
To do this they introduce multiple and further abstractions and let you express your ideas more easily and more quickly.
However just like it takes time to understand the nuances of those real world languages it takes time to understand the nuances of different computer languages.
Languages allow many ideas, some of which you may not have even heard about and they give control to those that want that kind of control. If I write a program I don't care how a green box gets on the screen. All I want is for that user to be able to click the green box. I could of course worry about voltages and signal latencies on the monitor cable, but I choose not to.
So when you talk about low level languages being easier I would suggest that you probably haven't worked with enough complex programs to understand why a high level language may be the only realistic choice. Of course you can always choose a lower level of you have the time and motivation to do that. And similarly you can choose higher level languages what have the syntax to express your ideas in terms of the things you're programs are for (e.g transport, medicine, banking etc).
I think the answer is just that you're more familiar with C. Java was my first language, and despite never having used it since college (graduated in 2016), it is still my most comfortable language.
I think its also worth noting that you'll have to "unlearn" some things for whatever your 2nd language is. I don't think what you're describing is at all a personal defect or anything, just a learning hump to get through.
C is a very simple language. You can completely understand it, and you can understand most of its standard libraries, with comparatively little work.
Java, on the other hand, has a tremendously complicated standard library. Even its basic collections library is large enough that it's unlikely an average developer knows about all of the choices. It has classes, which C doesn't, and it has a bunch of subtle rules around atomicity and garbage collection and synchronization and such. It is much more complex than C.
On the other hand, though, doing anything in C is quite possibly much more complex than doing it in Java. I can easily write a thread-safe web server in Java in under 100 lines of code, and I can be pretty confident that it will work correctly. The C equivalent might involve implementing a linked list or a stack of some sort, plus whatever data structures are necessary to serving the content, plus a bunch of careful string manipulation for whatever it is your server is actually doing, and more. So the C program will almost certainly be much more complex than its Java equivalent. In that sense, Java is trading away a simple language in exchange for simpler programs, which is usually a great deal if you write a lot of programs.
I feel the same.
C has stupid simple syntax, its main complications come from exposing you to the internal workings of the computer. Higher level have less of this but also have far more syntax to deal with to make it more "humane." But getting used to this allows you to write code in 5 minutes that takes hundreds with C.
I feel the same but about Frameworks which is another abstraction layer on top of the language
There's no way python can be more difficult than C. Most probably you don't have enough experience with them. Try python for a week you'll see why it's so popular.
Bad progammer here. I started with C++ in school, then moved to java and found it way easier. Inbetween that I tried to learn javascript 2-3x and hated it.
I had a 500 line java project and had to learn some basic python to write 100 lines. I don't like python either and find is more confusing than java.
I suspect dynamically typed langs like JS/python/ruby are for more experienced/skilled coders.
I do like the simplicity of certain tasks in python. For instance reading files in a folder. I did not know python did something better than Go; read the first paragraph or 2 here and the very last sentence says:
In any case, I‚Äôm glad that Go‚Äôs support for reading directories will no longer be lagging behind ‚Äì or walking behind ‚Äì Python.
I wrote this function in Go. It adds files to an array if it's not a folder and the filename ends with ".SC2Replay".
https://gitlab.com/Rairden/sc2-replay-go/-/blob/master/sc2replay.go#L197
Python is 30 yrs old, and Go is 11 years old. Sometimes I'll see articles like this one (read top comment).
However, there is a deeper reason why Java was so much faster: more people were working on making it faster.
I also like the top comment here about java. It mentions what is a "fun" lang. Any lang where you can skip writing error handling and tests can be fun. I find Go way more fun than Java simply b/c of less syntax noise.

Comments from https://www.reddit.com/r/learnpython/comments/11e4al8/is_it_normal_to_feel_overwhelmed_and_confused/:
So I've been watching "Pythons for beginners" by Programming with Mosh. While I can replicate the programs he shows me and understand them somewhat I'm still very overwhelmed. I got no clue how to implement the various examples into actual programs and I struggle with the whole str and int identification.
Does anyone have any tips or some resources that are friendly to people who have no clue about programming? I'm completely fresh.
Despite finding it hard and overwhelming I'm still honestly enjoying it.
Python is easy. Programming is hard.
Just keep studying for different sources (youtube, documentation, w3schools, etc). A long ride awaits every newbie.
Two suggestions. Try a course like future coder, the steps might make it easier to do:
https://futurecoder.io/
Alternatively try scratch to get the concepts down before going to Python if you find it overwhelming.
I struggle with the whole str and int identification.
When you assign a variable, think of it as putting stuff in a labeled box. Most of the time it doesn't matter what's in the box, but sometimes we are interested in what type of data is stored. For example, you can't do most math operations on a string of characters. Type is a way of describing what sort of data you're working with and int and str are just a couple of examples. There are also floats (think numbers with decimals) booleans(true or false values) as well as data types like lists, sets, tuples and dictionaries. The key thing to remember is that type is mostly about what you can do with a value and Python will let you know when you try to do something that doesn't make sense or isn't possible with a given value
i really suggest codecademy, because it explains every single concept in part, it doesn't just make you write a program and voila, that's it. it's completely useless to copy/paste someone's lines of codes without understanding anything you've done. try codecademy and see how it goes for you.
What do you mean you struggle with string and int identification?
It's normal. I say this a lot, but it's true, especially with your first language, your learning is two-fold. It's learning how to program and learning the language. It takes time and a lot of practice to narrow down just what you're doing. But it will come in time with consistency. You got this!
Although python is great, don't forget to level up your SQL skill as well
Hi there, I would recommend to take various notes on top of following along with examples Mosh gives you. The notes help you reinforce what you are learning.
Something that always helped me when learning from others is to customize what they are telling you to do with something relevant to you.
Plenty of great tutorials out there, stick with it! You don't need to memorize perse, you need to grasp the concepts!
If you're having issues with str & int, focus on that concept for a bit and use Google and YouTube to your advantage in regards to these topics.

Comments from https://www.reddit.com/r/learnprogramming/comments/u2uxw0/why_beginning_programmers_should_embrace_confusion/:
https://www.youtube.com/watch?v=lytxafTXg6c
In the linked video above, Nobel prize winning physicist, Richard Feynman explains confusion. Feynman was a theoretical physicist, which means he tried to understand the world using math. There are also physicists that do more applied work (experimental physicists).
He gives an analogy of a monkey trying to reach a banana (in a very human like way). The monkey has two sticks of equal length. Both are too short to reach the banana. The monkey is confused. Then, the monkey ties the stick together and gets the banana.
He says a lot of times, physicists (or mathematicians) are confused. They don't get it, but they think and think and think and they finally get a solution.
There was a recent post by someone who said they wanted a book or some resource that would explain the concepts so they fully understood it without having to learn a language. Of course, it's difficult to know how big such a book would be.
I should point out that it's possible for someone to eventually write books for beginners as long as they work with beginners. It will unlikely be comprehensive, but it would be an improvement over what currently exists.
As a beginner thank you very much for this post.
I have two sticks, and I'm going to get that banana! üöÄ Thanks for sharing! ‚ù§Ô∏è
I advise engineering students that I work with, when tackling post-grad level papers for the first time, to embrace the confusion and not worry so much about every detail. Try to understand the basic concepts first, and delve into the complexity down the road / when and if needed.
Works for shakespeare too.
they think and think and think and they finally get a solution.
I think the importing thing to emphasize is that they experiment, they don't just think. By experimenting and playing they arrive at a solution.
Many people here ask how they should go about learning to code. And my answer is simple: Start coding. Make up your own project and implement it. Learn by doing.
The monkey with two sticks analogy perfectly describes how I originally learned most computer science/programming concepts.
I started coding by making Lua scripts on Roblox. Cringe, I know, but this was 2010 before most people even knew what it was. I was about 11-12, and it‚Äôd be 3 years before I first heard the words ‚Äúcomputer science‚Äù spoken in person, but in those 3 years I nearly mastered the basics of programming simply through trial and error without even realizing because I was just having fun making stuff and learning. I even came to knew more advanced concepts such as regex, thread pooling, decompiling/disassembling for debugging, and even code injection exploitation (dll, sql, metasploit) before my high school intro Java class.
I have to say that learning this way benefitted me immensely, because it engrained programming concepts into my brain like a second native language. Since ~2016 it hasn‚Äôt taken me more than a few weeks at most to become comfortable using in any specific language, with the exception of machine code because low level just doesn‚Äôt interest me
What a great write up. This encapsulates the ‚ÄúAh ha!‚Äù moment that makes programming so fun. Instead of approaching problems with futility in mind, approach them that you don‚Äôt know the answer and you will figure it out. Most programmers I know do it every day!
Great post! I think we should add just start, try something, break it, cry a bit, and keep chipping at it until it works. In this case, and in most cases, the act of doing with some google magic on the side is the only way forward.
How do I translate this to something like leetcode that being asked? I get embracing confusion and trying what sticks but how do you improve that with technical interviews? Is that a different process? I've been trying to time myself and try solving a bunch of leetcode questions despite feeling dealing with problems I can't solve on the first try.
Even though I've been programming for a couple years I still feel like I struggle with basic stuff.

Comments from https://www.reddit.com/r/learnprogramming/comments/1ccj9w9/confused_about_what_to_do/:
Hey, hope you programmers are fine. I am right now learning Python from FreeCodeCamp. I am almost done with it. I am thinking of doing desktop dev but I also want to do something else. I want to do something that
Doesn't have a lot of math involved
Is NOT web development related
So any suggestions?
I'm not sure what desktop dev is? Did you mean backend? Either way, look at job postings in your area and see what is required and what they want you to do. Find some you like and see what's relevant to get those jobs

Comments from https://www.reddit.com/r/learnprogramming/comments/ynalzp/asynchronous_programming_is_confusing_me/:
Specifically in C# and Python (Not really relevant, but I'm just saying that I haven't used it with JS).
So I understand the purpose behind async programming, and I understand what async does. (It returns execution to the function that called it). Where my confusion sets in however, is that an async procedure returns a Task or some sort of "Awaitable" - depending on the language - that can then be awaited. But eventually there has to be a synchronous function that calls one of the async functions, but that synchronous function can't await the Task because it isn't async. So how do you do that?
Also, once the task is complete does execution just automatically return to the next line of the function that awaited it? And what about if the program finishes execution before the task is complete?
You're right there's at some point a sync function that calls all the async ones, however, this is not a normal function that you would write normally. In async environments there's a mechanism often called a runtime that controls the inner workings of the async calls. So, in practice, you don't need to worry about this last resort sync function, the framework will do that for you
I imagine it depends on the implementation, but most times the execution doesn't jump around. The whole point of having an awaitable is to be able to gather your result after the work is done, the code remains linear, in fact, that's one of the biggest strengths of async/await compared to other non-blocking techniques
What happens to task that were not awaited depends on the framework, but virtually all times they will just be destroyed, it's not a big deal
Conventional sync functions can kind-of, sort-of await by using some kind of runner. For Python this is:
There should be a C# equivalent to this construct. This is blocking, as we'd expect. The program won't continue passed this point in the synchronous code until an_async_function returns.
Non-awaited tasks can end up getting garbage collected if the runner where they were created terminates without any await ... for them, or forcibly terminated if the overall program terminates before they complete.

Comments from https://www.reddit.com/r/devops/comments/1dofn9b/live_coding_interview_confused/:
So I just had the second round of interviews in the hiring process and it was really not what I was expecting‚Ä¶ I was prepared to write something related to automation, pipelines, IaC but the first question was to write some code that I would expect that a SWE wouldn‚Äôt have trouble to come up with a solution. I ran out of time, and moved to the next problem which was a follow-up on the first. I tried really hard to write something and even tried to explain my approach to the problem, but no working code came out at the time. I let the interviewer know that this isn‚Äôt something that would be part of the day of a DevOps person and he even agreed but ü§∑üèª‚Äç‚ôÇÔ∏è I‚Äôm super sad now because I was really looking forward to work with these folks and I left the call with the feeling that I did horribly bad. That‚Äôs it, sorry. I just needed to vent :(
Update: I got a great job! Making 15% more than my previous yay!
I just finished my 2nd week on a new job with this awesome company.
a bit long process
Nailed the system design call
Talk with CEO was very interesting, he‚Äôs a tech guy and asked me to show some of my code then proceeded to a code review session and made lots of suggestions to me
The is one of the problems with the "DevOps Engineer" title. It means different things to different companies. It sounds like company's definition is probably Software Engineer who will primarily be working on release engineering and whatnot
Most smaller to midsize companies treat a DevOps Engineer more like an SRE + CI/CD but that's really got very little to do with the original concept.
This just wasn't the right place for you. Sounds like they didn't know what to do with the role. Good thing you found out now instead of starting and failing to meet whatever bs expectations they seem to have.
I mean if they said it's not part of the job but made you do it anyway, it's a way to see your thoughts and how you process things.
I saw a job on LinkedIn ‚ÄúUX/UI DevOps Engineer‚Äù. Whatever the fuck that means
Lots of companies only want to hire DevOps engineers who can write actual code, not just HCL or YAML.
This can be pretty common. From my experience the root of the issue is that the company wants to standardize how programmers are treated. This can help ensure that everyone is treated equally in pay and title. But it also means that everyone is ranked against the same scale that is defined by the majority programmer discipline and the more niche disciplines are unfairly evaluated. This tends to be a reinforcing pattern as their hiring process tends towards programmers who are the majority discipline with a side interest in a niche discipline like devops. This then discourages hiring or retaining exports in these niche disciplines leading to the belief that all good programmers are in the majority discipline because those are the only examples they see.
The sad truth is that companies rarely spend time customizing interviews or evaluations to match the roles that they're hiring for but instead take a "one size fits all" approach. If the company has a tech stack that is primarily C++ then expect a coding exercise in C++ because they'll be using the same exercise for all candidates regardless of title.
Yes. This is 2024. I had 16+ interviews in last 3 months and all my round 2 rejections are because of coding.
Good news is there are lots of opportunity now for SRE/DevOps/Infra Engineers.
Unfortunately the interview process can get a wee bit lost nowadays.. meaning that there are some companies out there interviewing based on business problems/needs but not based on actual role requirements. Therefore, losing track, if that makes sense.
I wouldn't feel bad, but more like agreeing on the rest of the comments that this wasn't the right place.
Welcome to the hiring market in 2024. It took me 6 months to find a job after rounds of bullshit interviews like yourself. It wont be part of your day and it is a waste of time for both you and the interviewer but thats what companies are now using to judge candidates.
Just move onto the next. Next time decline any live coding interviews if they want things like data structures or algorithms.
I‚Äôve been on the other side of this. When interviewing for a devops role we‚Äôve asked candidates to write python code for a solution which is academic in nature, but does demonstrate problem comprehension, basic coding, problem solving, looping, etc. it becomes a more objective evaluation. You‚Äôd be surprised at how many candidates state that they have coding skills but are BS‚Äôing it. Do you mind if I ask more about the task that you were assigned?

Comments from https://www.reddit.com/r/learnprogramming/comments/1eqoslf/confusion_with_doing_projects_in_c_beginner/:
I need help. I'm learning c++ from studyplan.dev (I find it more appealing to the eyes than learncpp.com, it looks boring.) And i'm on if else statements right now. I tried doing a little project (chatgpt suggested, never gave me code only a road map.) but I was completely lost. I understand c++, it's easy, but I was just stuck for some reason. I don't understand. I understand c++ real well, I even take notes on stuff I won't remember. But I simply cannot write a program. Any tips? I have 0 prior coding experience.
Learning a programming language and learning programming are two completely different things, like learning to use a chisel and learning carpentry. The former is just a tool for the latter.
Learning programming is learning problem analysis, dissecting problems, and solving them in an algorithmic step by step way.
I wage a bet that you directly started trying to program a solution instead of sitting down, thinking about the task, analysing the task, trying to solve the task on your own, as you would, not the computer.
You need to learn to work on problems before thinking about programming. You need to learn to plan.
There are some books that might help you get over this hump:
"Think Like A Programmer" by V. Anton Spraul
"The Pragmatic Programmer" by Andrew Hunt and David Thomas
"Structure and Interpretation of Computer Programs" (SICP) by Ableton, Sussman, Sussman
"Code: The Hidden Language of Computer Hardware and Software" by Charles Petzold
The thing with technical skills is that you can't just read some documentation and know how to do it; you have to practice, practice, practice. Essentially, you need to form the connections and patterns in your mind such that when you see some new problem, your mind starts to automatically think of how to approach said problem, and form a plan of attack. You can only do this with practice. The more different types of problems you see, the more you start to see the underlying common concepts that go into their solutions. This is literally how memory works: repetition leads to a stronger ability to not only retain that knowledge, but also recall that knowledge.
This is why learncpp is such a well-regarded resource: it is in-depth and notifies you about the pitfalls when dealing with some topic. But, it also gives you practice problems to try applying what you've learned.
Taking a look at that website, sure it definitely is more attractive on the eyes, but I've noticed a distinct lack of practice problems. Without practice, you just have notes on a page, but you need to apply those concepts to be able to make them stick.
I am always recommending this other resource, because I feel it balances teaching with practice, and then gives you more practice after you're done with the course: https://exercism.org/tracks/cpp/concepts

Comments from https://www.reddit.com/r/calculators/comments/1fcf6sr/why_are_people_here_so_confused_on_programming/:
you can for the most part program any calculator but people keep saying you can't? is it just people thinking "no program mode can't program on it" if so dudes and such I have the coolest thing to tell you, you can program any machine you know the language for and can access the storage for! on calculators when you open them up the ROM (the storage for the programs basically) is normally the larger black rectangular chip, find a way to access it and go ahead! if you can't find it it's all done in the calculator chip under that black blob and you should give up for now. this applies to any electronic digital devices from oven timers to a cd player or digital pregnancy test (will say never mess with microwaves) and it's not even that hard, most will use a BASIC language which are kind of written like pseudo code if you've ever done a programming course (if not they are written kind of how youd describe the code to a 4 year old) but some use different ones, it will be listed somewhere by some nerd like me on some forum from 2002, guys dont limit yourselves get weird with it go program a non programmable calculator its fun and less difficult than youd think
This is so unhelpful. How many calculators have you hacked? It is nonsense to say ' find a way to access it ( the ROM chip) and go ahead.' This is like saying it easy to fly to the moon - just find a Saturn 5 rocket and off you go. The average poster to this site is not interested in or capable of hacking anything. There are other sites for that. If you want to program get a programmable calculator- simples.
There is a distinction between calculators that are designed to be programmed and those that you have to hack.
When people ask on this forum if a calculator is programmable they want to know if it is programmable out of the box; i.e. it was manufactured with a programmable environment that they can use on the calculator the moment they pick it up. When answering those questions then, responders tell them whether the calculator is designed by the manufacturer to support user programming. Most calculators do not offer that which why much of the time the answer is no.
Most people don't want to tear apart their calculator to jury rig programming into it. They don't have the knowledge, skill, or, frankly, the interest in doing it. Those that have the interest in and enjoy doing that kind of stuff won't be the ones coming here asking if a calculator is programmable.
Is this just one of those ‚ÄúI am so great, and everyone needs to hear it‚Äù posts?
How is this text (far too long, btw) going to help new users?
Is r/calculators programmable?
Because most people here weren‚Äôt around in the era when there were non graphic programming calculators and aren‚Äôt aware that outside of hp those don‚Äôt really exist with modern available calculators
Brain damage... this fucking post gave me brain damage. Fuck you and fuck your grammar!
Casio are easiest because the language has a lot of documentation, it's CASIO BASIC for the most part

Comments from https://www.reddit.com/r/learnprogramming/comments/994fjf/confused_about_coding_challenge_that_involves/:
I'm posting this in a few subreddits, so I apologize in advance if you've seen this elsewhere. I recently received a coding challenge from a startup, and their recommended study topics were:
JSON parsing and serialization
basics of HTTP requests (GET/POST), headers, status codes
data structures & algs
I've never worked with JSON or HTTP before, so I've been doing reading on those topics. What's confusing me is that on codeacademy, performing a GET request seems super straightforward:
GET /articles/23
Accept: text/html
But when I look up how to perform a GET request in javascript on stackoverflow, it's a bit more involved. At this point, I'm not expecting to pass the coding challenge, but it would be neat to learn more about this topic, and how it's actually applied in real life... is the stuff on codeacademy pseudocode? I'm just pretty confused!!
how it's actually applied in real life... is the stuff on codeacademy pseudocode?
To a degree. That part you have posted is indeed a basic request. A more complete one can look like this:
However, this is just the content of data you are sending, basically a mere string to be read by server. Whereas networking is not that simple and number of things that actually happen when you decide to visit a reddit.com site for instance (which is a GET request too) is quite staggering. What actually happens in that case is more like this:
First, your browser needs to even understand where it even should deliver requests that are supposed to go to reddit.com? Domain name is one thing but you need an IP address. That's what DNS servers do as they keep a "map" that given a domain name responds with an IP address.
Most of the time you do not have a direct path to that IP address. Your request will have to go through numerous hops, possibly all over the world, before it reaches it's destination.
Now, these requests can actually fail! They are also split into multiple parts (packets) and can arrive in any arbitrary order to the server (it's not guaranteed that the first sent packet arrives first by any means). It has to take care of making sure all parts have arrived and merge them together before proceeding. Well, most of the time - eg. in VoIP or many video games all these warranties no longer exist. Why? Because to warrant that a complete message has arrived you often need to retransmit parts of it and ask client if this is everything they have sent therefore it causes a considerable overhead and makes you wait extra miliseconds. Hence in some uses you just don't care if everything has arrived, only latest state matters (who cares where the enemy in an fps was 1s ago, you only care about their current location).
These points are generally taken care for you automatically when you do requests from within Javascript, you don't even need to know about them existing (you generally don't write GET /resource_name manually either). But behind that simple "GET /index.hml" string there's a whole field of computer science. Personally when I was teaching web development I made write basic HTTP server and client exercise to make sure person in question understood these concepts and I suggest you try the same, basic ping-pong application (server that listens on a specific port and responds with pong, client that sends ping message to it) is a very good project to undertake at some point.
So when you use javascript to get contents of a single resource it might very well be as simple as:
but what happens underneath is way more complex!
> JSON parsing and serialization
JSON in itself is a very simple data structure. It's nothing more than an accepted standard of sending informations from one place to another. It's useful since it's relatively lightweight and as a bonus, JSON stands for JavaScript Object Notation for a reason as a response rendered in it can be instantly used in Javascript. When building web applications you nowadays often split them into two parts - a separate front-end (written in pure JS which works on user's browser) and a back-end (written in just about anything) which responds to requests with json. Reddit for instance offers this kind of responses, try using this url to see how it looks like:
https://www.reddit.com/r/learnprogramming/new.json
That way only front-end has to care about HTML, CSS and nicely formatting all this data etc whereas server can happily focus on other stuff.
You will likely encounter JSON APIs of all kinds later on - be it for tracking a package status, looking at what's the weather in a given location, automatically searching for items on eBay/Amazon, fetching new articles and so on.
Performing a GET-request is very simple. With a library like jQuery it's a single line of code:
They're so common that there is almost always something available to make it easier for you. In fact, a lot of things you use on the internet are essentially get-requests. A hyperlink, for example, is a get-request. You can type the address of your get request in the address bar of a browser and you'll get the raw output of that request.
The only thing you really need for a get-request is an endpoint that accepts your request. If you want to practice a bit, you could try the google maps API. It has very good documentation and there are all kinds of fun things you can do with the data.

Comments from https://www.reddit.com/r/technepal/comments/1bp034x/i_got_selected_for_leapfrog_coding_examination/:
I am really happy that I‚Äôm selected. Unfortunately I am in my hometown and It takes whole night to reach Kathmandu. I thought first round would be through video call but it is on site.
I am really confused should I go or not. And the exam is also competitive and If I don‚Äôt pass it would make me depressed. I am also not expert in DSA. It takes around 4k for whole tour. And they would take minimum 3/4 round of the interview and I would need to visit Ktm every time.
I don‚Äôt have money to travel and I have to borrow money with my father that I don‚Äôt want that‚Äôs why I always searched for remote job.
Please suggest me what should I do? Even if I ignore it, I am happy that they invited me. 6 months ago I was rejected.
Thank you.
If the whole tour costs you 4k then I'm willing to sponsor half of it. Go get it, young lad!
If you're not good at DSA it's very likely that you'll get rejected. The competition is cut throat. Travelling for interview is not worth it.
You can ask if they can conduct all the interviews online and you'll relocate if you get the offer.
If there is no money problem you can come and give exam even if you fail it will give experience for the next time . I am also selected it will be fun
ani yo pani nagarney tyo pani nagrney ani jagir chai ghar mai aucha aunus hamilai join gardinus bhandai. wayatt wayyat question ko ni limit huncha ni
Are you sure the exam is on-site? I don't think you have to be present physically untill you are selected for the internship.
Is your problem that you‚Äôre uncertain you‚Äôll pass or you don‚Äôt have the money? Aba virtual is gone. Everyone will do onsite
Can i see your CV? Your projects, i got rejected so i wanna see what i have done wrong

Comments from https://www.reddit.com/r/csMajors/comments/1dzki6z/confused_about_faang_code_assessment/:
maybe you were lucky
maybe you are amazing
maybe you brute forced everything
maybe they‚Äôre just trying to filter out the worst candidates
we can‚Äôt tell without more info
The google coding SWE intern OA was one of the easiest OAs I‚Äôve ever taken. Took it in Fall 2022 and went to interviews, the questions in the interviews were much harder compared to the OA, which was two easies. Interview was a Medium then a Hard.
FAANG interviews are actually very easy if you just study data structures and algorithms. But yeah, just because you pass the test cases in doesn't mean that you have a good solution. Many problems have hidden test cases.
Are you talking about google? their oa has always been easy pretty sure.
It‚Äôs like they wanted you to return smallest element in a rotated array, so u did linear search instead of binary search type shit
Google OA is light just a screen to see if you can code. Interview is supposedly can be harder tho

Comments from https://www.reddit.com/r/learnprogramming/comments/17j6kt5/project_based_learning_keeps_me_confused/:
Hi. I've been learning how to code for quite long and I'm now doing a cs degree. I'm struggling to figure how to learn PHP (in reality any technology). My problem is not the core-language. My problem is how to figure which are the best practices. For example, if I'm aplying "Project-based learning" in order to learn how to make web apps in pure PHP and I'm trying to make a ToDo list app. How could I know that I'm dong things in the right-way? I mean, it can work but maybe it's not a secure app, it's slow, it don't uses the "standards"... I would not know what is CSFR security if I had only learnt by making projects. So, my question is: How can I learn by making projects (which I know that is the fastest and better way to learn almost anything) but without losing the chance to learn the good practices and how things are done.
If you are just getting started then there is no way for you to know all of the little ins and outs and you should focus on just making it work.
It is good that you recognize that these other considerations are important, but you can't try to handle it all now.
Even for professional tasks, I tend to believe that you should "plan to throw the first one away, because you will anyway." The meaning is that the first time through, you don't really know where all the tricky parts are and if you try to solve all the problems at first, there's a good chance you'll solve the wrong problems or end up with a bad design. So if you put in the effort to build the simplest version and explore the problem and learn where the pitfalls are, then when you start over again, you'll have a better design that addresses those issues.
It‚Äôs correct when you meet all the requirements. If security or speed or anything else isn‚Äôt what the teacher wants then don‚Äôt worry about it
Something to keep in mind: Projects are often "grown". You need something that functions, then you can refine, improve, and extend it.
Your first iteration may not even have separate users, just a singular todo list. This lets you practice storing data in a database, retrieving it, modifying it (basically building a simple CRUD application).
Your second iteration may not even have any security, people enter in a username sans password and get their todo list which means knowing the username is all that's needed to get a list. But it can let you extend your practice to separating data by users. How might the database be changed?
Then redo the project or extend it to use proper authentication. Maybe just hash and store the passwords. Oops, you didn't handle salting the passwords. Ok, extend it to correctly salt the passwords. Now go through the PHP docs and common packages and see if someone already has a "standard" solution for you to use. Tear out your custom approach and use theirs. Further extend it to use oauth, consider dropping storing username/passwords (in any form) from your application entirely.
Keep going. Repeat the project from scratch with different approaches, replace pieces as you learn and get feedback, extend with new capabilities. That's how projects let you learn.
If you seek perfection from the start, you won't find it. You'll just be paralyzed especially if you don't even know what perfection looks like. Go for working, seek feedback, improve, repeat.
Instead of thinking about "best practices", think about "what are the possible ways to solve this problem?" Then, you'll understand that while there are some obviously terrible solutions, if you remove those, then what's left are valid solutions depending on the circumstance. This is really what "best practices" are: they solution patterns that fit some circumstance. They are not flawless in all conditions. Some "best practices" fit 90% of problems and are widely adopted. Other "best practices" fit 30% of use cases and are used only in those situations.
Therefore, to truly understand best practices, you have to understand the problem domain first. Only then can you know which solution patterns to apply under which conditions.
You shouldn't be this neurotic about best practices or security if you're in a CS degree. You should worry about coding skills and getting good grades.
Here's the neat thing: you don't. Make the project, and once you're done, ask for feedback somewhere online or from someone you know is an expert. Then, research the topics they mention in their feedback, and either implement them into the project or start a new one.

Comments from https://www.reddit.com/r/vscode/comments/m1h350/i_just_got_vs_code_and_im_a_little_confused/:
I‚Äôm very new to programming and I downloaded a JDK for java today as well as VS Code. Like I said, I‚Äôm VERY new and don‚Äôt really know how VS Code works. I plan on coding in java. What do I save files as? How do I make new projects? Any tips on organization? Any help is greatly appreciated!
After downloading jdk and adding it to Path, you should first install the Java Extension Pack in VS Code.
Attention: Java extension needs jdk11 or recent version to support, please check if your installed jdk is compatible.
Then open command palette(Ctrl+Shift+P) and choose Java: Configure Java Runtime, set project JDKs and Java Tooling runtime.
The editor also has much more capability for your Java workload, like Debugging, Testing, Java Project Management and so on, which you can find it in vscode-java-docs.
What kind of projects would you like to code? It may have influence on the programming language to choose.
Is there a reason java is your first choice?
After you made that choice your other questions may be answered better.
Stick with a proper IDE suited for Java. If you insist on using VSCode, i suggest you google something alongside "how to setup vscode for java" and setup it accordingly.
My love and editor of choice is vscode but it needs to be properly setuped, ie with necessary plugins, there is plugins to make vacode somewhat suited for C#, Go, JS etc so there should be some for Java too.
If you stil insist i suggest you get comfortable with terminals to some degree since you need to run some of your build commands via console.
Also im not a Java programmer and those suggestions were based on my previous experience doing C# in vscode.
I‚Äôd pick JavaScript or Python as a first. Python language is probably the closest to human speak.
As a parallel, to go through the jungle of Programming, you should get the machete that is a big IDE like JetBrains IntelliJ or Visual Studio (not sure about the java support). VS Code is a really tricky Swiss army knife, that is even used for professional infrastructure development, it's awesome, powerful, universal, but tricky. It doesn't do too much for you, seriously, if you can get your hands on an IDE you're gonna have a way way easier time especially if you're new.
But to explain, VS Code doesn't do projects or anything, you just open a folder for quick access, that's it, then no projects, you set up a configuration that is just a guide for what command VS should run with what parameters to build and run your code. Some plugins do stuff for you, like creating these configs and even enabling intellisense which mind you isn't installed for anything by default. So yeah, basically, from my experience, VS Code usually requires equal knowledge to compiling your project from the command line.
I'd recommend installing the Java Extension Pack, which includes all the extensions you need for editing Java in VS Code. You save files as .java, but you don't have to worry about this (and project creation) if you use the Project Manager for Java extension, included in the extension pack. Just open the "Java Projects" view and click "Create Java Project...", as shown in the screenshots at the extension page I linked.
I also saw you mentioned wanting to code Minecraft plugins. All you need to know about that is that the Java extensions are based on the same tooling as the Eclipse IDE, which means that you can follow the same instructions/tutorials as Eclipse users and it should work pretty much the same way in VS Code. You can DM me if you have any further questions about that.

Comments from https://www.reddit.com/r/learnprogramming/comments/a3pxau/confused_about_my_path_best_programming_languages/:
I apologize because I promise I did read New? Read Me First and went to the Best Programming Language for me website, but I'm a little unorganized about my goals. Ideally I wish I could do it all, but I know that's not very realistic. I'm currently enrolled in school for Computer Programming and so far I've taken classes that have introduced just Python, Java, and SQL for Database Management. I really don't want to wait till I'm done with school to get something going. I also can't quit my job right now so I wanted to know what's a good programming language or path to go towards if I want to freelance on the side? Eventually I would like to do something with VR. I know that people said the best thing to do is get into Web Development knowing HTML5, Javascript and CSS because in the future WebVR will take over. Like yes I want to do that and it's cool but I also want to be profitable in these skills?
What are your takes on this for someone so scattered brain such as myself?
P.S. I do like Web Development as I have knowledge in Wordpress and doing Affiliate Marketing (even though they say AM is kinda dead now), but not sure how viable it is in the market as a freelancer these days.
Seems more like something for r/cscareerquestions, since you're looking for "side hustle" and freelance advice.
You can probably get side projects knowing either SQL, Java or Python. If you check out freelancer or other sites, they have postings. For example, you could get a job with SQL doing ETL type stuff. This post has tips on how to get a side job programming https://www.aprogrammerslifeforme.com/side-job-programming/

Comments from https://www.reddit.com/r/VisualStudio/comments/1ay8tfy/why_do_people_continually_and_daily_confuse_the/:
? - Curious on what people think.
Microsoft Made a big mistake naming it Visual Studio Code.
It's an entirely different product than VS and the only thing VS and VS Code have in common is that they are both IDEs.
Microsoft should have just named it "Microsoft Code" or something similar.
Microsoft is historically terrible at naming things.
Both have the word ‚Äúvisual‚Äù in the name.
Which ironically, is one of their main differences. There‚Äôs practically no visual gui or design features in VS Code.
Google does as well
People new to Visual Studio Code often just call it "Visual Studio", not fully understanding the longstanding thing that Visual Studio is.
Microsoft has historically been bad at branding. This is another one of those times they have done bad at branding.
The other reason it's so bad is that the "Visual" in Visual Code, and the "Visual" in Visual Basic referred to the GUI development that you could do in these environments - making Windows apps you could click on and interact with.
Visual Studio Code does not have GUI development, at least, not natively. It's really a terrible name.
What's VS Code?

Comments from https://www.reddit.com/r/Indian_Academia/comments/1dit6no/confused_between_mba_and_programming_need_advice/:
Hey everyone,
I'm currently in my 3rd year ( just finished my 2nd year )of CSE at KIIT University, and I'm at a crossroads about my future career path. Here's a bit about my qualifications: I scored 95% in 10th, 88% in 12th, and my current CGPA is 8.55 after the 4th semester. While studying CSE, I've developed a strong interest in finance and market analysis. I even participated and have won inter-college finance quizzes and puzzle events, which I thoroughly enjoyed. And I even actively trade and invest in stock market.
Now, the dilemma: I'm considering pursuing an MBA, focusing on finance and possibly aiming for institutes like IIMs in the future. However, I'm not sure if I should start preparing for CAT now or focus on improving my programming skills and aiming for good placements first.
Here are my concerns:
I have a basic understanding of DSA and OOPs from college but haven't started competitive coding or development seriously.
Literally in the same condition but the thing is I am from Civil.
I am confused between GATE and CAT.
https://www.reddit.com/r/CATpreparation/s/APuS8SQS9k
Please add some paragraph breaks to your submission by placing a blank line between distinct sections. Users are more likely to read and comment on your post if it's more readable!
I am a bot, and this action was performed automatically. Please contact the moderators of this subreddit if you have any questions or concerns.

Comments from https://www.reddit.com/r/learnprogramming/comments/16q1uhg/confused_about_learning_fundamentals_while_doing/:
I am 25, I have an electronics and telecommunication Engineering degree. I am enthusiastic about programming and hence not reluctant to learn whatever it takes. The First language I learned was Python. I started with knowing the syntax and delved into using the fresh "syntax-tual" knowledge in application development. I learned C++ as part of my electronics curriculum but didn't try developing applications using C++. I also learned HTML, and CSS because I found developing websites cool, and applied it majorly in editing blogger templates and learning Bootstrap. I was stuck with learning JavaScript for a long time, thinking it was a little difficult. Then I had a little opportunity to intern at a very early-stage startup where I got familiar with Laravel and PHP and backend development. The idea of developing an application from scratch with your own custom logic caught my interest. Then I took a break from programming and started exploring design, 3D design, graphics design, and 3D design ( at 22 ) for 3 years. Now with the advent of AI, I am rationally sure that I want to get back into programming and development. Now I am also clear that mere enthusiasm should not be the primary driver along any path. rationality plays an equally important role in continuing on a decided path, and not getting burned out easily. Now I am rationally enthusiastic about AI and ML plus Back development. As said I am from an electronics telecommunication background. I have exposure to mathematical concepts used for AI ML ( Probability, signal processing, linear algebra, calculus obviously) so I know what it takes to learn it and what to expect out of it hence want to get it deeper but also want to have flexibility and perks of backend-application and API developer ( earning potential, remote working, freelancing etc ). So with all these thought processes, and aspirations of mine ( correct me if I am wrong or unrealistic) I have started learning DSA to have fundamentals strong and flexibility later down the path to try on various backend technologies, microservices, and fields as the intersection of AIML and backend, But now I am feeling FOMO (especially seeing the 19,18,17-year-old "prodigies" ) that if I focus on fundamental I might miss some earning opportunity I might get by application development, building my portfolio with just "black-box" mindset. But at the same time, I don't want to get stuck at just the application level. So Please guide me appropriately. I am also now enthusiastic about web3 and want to get into thinking that I might have a competitive edge. As I have familiarity with web2 systems instead of specializing in them I will shift to web3 which has a completely different fundamentals prerequisite (I know there major chunk that still overlaps in terms of prerequisites for web2 and web3 )
Learn and do along.
Learn a subject and immediately practice it.
You don't learn fundamentals without doing. Always do whatever is being explained. At least thats how i personally learn anything; otherwise im just wasting time staring at my screen.
Definitely get good at DSA in a language like C++. That is what learning to program is all about. A company might be looking to hire an application developer but if you don't have good foundational knowledge then you won't get past an interview.
Once you're happy with DSA concepts, then dive into the more fun applications like AIML or backend or whatever you do. A lot of the frameworks you use will be at a high level of abstraction but the underlying concepts will be the same at the bottom. It will pay dividends to get good at DSA first then look at other things after.

Comments from https://www.reddit.com/r/algorithms/comments/9c9lho/indexes_are_confusing_forever_any_tips/:
I have a CS degree and have prepped for algorithms interviews countless times. However, whenever it comes to getting indexes *just* right and avoiding off by one errors, I am forever confused. Let me give you some examples:
Generate all binary search trees with nodes from [1..n]
Try a small example on paper with e.g. 5-8 elements, recording the index of each and what you expect them to be at that point.
Also indexes always start at 0,

Comments from https://www.reddit.com/r/learnprogramming/comments/18s2wxa/confused_cs_undergrad_about_the_future_of_csand/:
I am currently in my 1st year of CS Undergrad. I got interested in programming during my high school and I did well on it.So ,I chose CSE. Most of the people suggested to explore different niches in your field before choosing yours and grow on it like your life depends on it(btw it is true). But what my confusion here is,As you all know The most hyped tech thing ever since I born(due to social media ofc),It restrict me learn things my way. I fear that what if that particular niche gets fully automated by AI and my whole learning might gets wasted. I need to know what area I need to focus on Programming,I know I need to get a strong base on coding and improve my problem solving skills. But after that?!?From your experience Some of you might have some big tech jumps or far ahead of the rest of people in the world.What should be my focus should be for the next couple of years.How to cope up with this AI thing?..Who are the experts whom I can follow(if you're interested you can guide me personally tho)?What are the best resources that I can find ?How can I Make my way into this AI world?Propose A possible relevant framework for me to follow. PS:Pls Forgive me for my Grammar
it feels like you are asking a variation of "what's the next best thing" and that nobody knows (and whoever claims to know is either naive or lying). I've worked in IT for 12 years, and Big Data was great, and Blockchain was great, and Cloud was great, and AI is now great. After a while, all these hype trains find their place, they become just another tool in everyone's toolset, and sort of fade into the background.
Find something you like to do, and get really good at that. If you are passionate about something, and put in the time and effort, at least you'll be slightly less miserable if AI ends up taking your job. Because maybe it will, or maybe it won't, and nobody knows which it will be, so you might as well make the most of the journey.
Well nobody can know what the next big thing is. Gartner's Hype Cycle for Emerging Technologies might be helpful to you. But in the end it doesn't matter since you have to always learn new technologies anyway.
You are already doing the smartest thing you can do. Get into a good CS program and work hard at it. Foundational computer science, which is more problem-solving and mathematics with a bit of programming, will be as safe as any field I can think of. As a CS major, you'll be on the right end of AI. It's the self-taught and bootcamp folks that might fear chatGPT.
The more theoretical your studies might seem to you as a beginner, the more likely that will be the content that helps you in your future. Computer science skills will not be replaced by AI nearly as quickly as long distance truck driving, web development, or many other fields.
Learn problem solving, math, and programming. You'll be fine. I would NOT worry about specializing yet. You're still a freshman. Once you have some exposure to various forms of CS, you'll have a better sense where you fit in.
I am concerned (as a CS prof) that your English grammar might indicate struggles with computer programming. Human readers can understand you even if your grammar is spotty, but compilers are not nearly so forgiving. You'll need to work on your discipline, or you'll find programming quite difficult.
.

Comments from https://www.reddit.com/r/Btechtards/comments/17ekkvx/i_am_a_bit_confused_in_life_i_want_to_start/:
So, I am a dualite in BPHC. So yes my college is good but branch is something I do not know at the moment, My acads so far have been on track to fetch me CS. So, I just want to do something as a side project in my free time. So I thought what better thing to do than venture into coding. So in college we have CP where they teach us C. I have been following classes and trying my best to solve problems but just mindlessly solving problems does not help me learn. In school when I was learning python I used to make projects to learn which was fun. So could someone suggest a starting point or some project ideas I can make at my current skill level. So far I have covered, till strings in C.
Educational_info: Dualite, BPHC.
Who tf learns C by doing projects
At this point C is just a learn and throw language for most people.
Development using C is a pain and I wouldn't really suggest doing it unless you want to go deeper into low level programming.
I'd say just continue with python since you already know it, explore it's libraries.
I'll give you a decent project idea: a discord bot using discord.py
Have you covered arrays? Maybe a program for interconversion of binary, octal, decimal and hexadecimal base codes?
you could try and make a RISC-V or a MIPS Pipelined CPU simulator in C however without OOPS it is a bit hard.. C++ is more suited for dis
you could use structs and functions togerther to achieve same results like that in classes..

Comments from https://www.reddit.com/r/FlutterDev/comments/1eyke2r/so_confused_with_studies/:
Hi everyone. I started learning flutter about just over a month ago using a course on udemy(flutter and dart course). I still feel soooo dumb. Like, some of the stuff makes sense and then other things are like, "What is going on here?". Anyone have some advice to help with the studies or some tools etc. Would be much appreciated. Thanks
Start building UIs first. Learning can be fun if you get an instant feedback and copying speed coding videos is what I suggest people new to programming should do first. Once you have a working UI, you'll appreciate it and you will feel that you have made progress.
Do that for 3 more speed coding videos and after that you will start to get the hang of the repetitive process of creating a project, configuring pubspec.yaml, adding assets, adding colors, adding folders, coding the actual UI, testing, debugging and running the output on an emulator or physical device.
You will start to question what each widget does and you will learn each one through practice or experimentation. You will start to play with each parameters which you can see either through intellisense or hovering over the widget. That way, you can learn by yourself and get instant feedback and have fun as well. You will learn the basics of UI by just doing these repetitive tasks.
You can then go back to basics of programming to learn how to put logic to your UI. Use setState first to learn state management then proceed to value notifiers, inherited widgets, etc. Then learn a state management library of your choice. BLoC or Riverpod is advised. Provider is also good.
After that, you know coding basic UI, programming fundamentals and adding logic, basic state management and lastly try to create a release build of your app. First things first, create an app that you can share with friends and ask for feedback. For sure that will be a lot of fun.
You can learn the following next: local storage, API integration, device specific functions like camera, maps, etc and lastly learn how to structure your folders the right way, MVVM or clean architecture, it's up to you. There are more to learn but these should make you a 10x dev as you are now if you master each one.
Goodluck and have fun. Always remember to practice everyday and learn to finish things. Cheers!
Don't try to conceptualise everything in one go. Create an app alongside the tutorial - write out all the code an experiment by making it your own - don't ever just copy and paste.
Go one step at a time and try by doing, not by watching.
If you have inspiration and the tutorial doesn't tell you how to do something, try ChatGPT or ask on Reddit.
You don't start writing Flutter code once you know everything. Then you will never start.
I started using Flutter in 2019 and I work with it daily. I still have very limited understanding of concepts I haven't had to use. You learn these things as you need them.
I started learning from Youtube, straight up see mockups and tutorials.
When i dont understand anything, I just write it down on a paper. Then look for a seperate video for it.
Kinda lengthy process, but gets the work done.
For learning Flutter, you can check out this free Flutter eBook: Flutter Succinctly.

Comments from https://www.reddit.com/r/startup_resources/comments/17zhqxg/give_advice_to_a_confused_self_learning_programmer/:
Its been Eight months into my self-learning programming, I‚Äôve learnt Flutter but It was hard because It was my first-time writing code and I opted to learn from a book which was obviously outdated. I stared to learn coding with the goal to enter the tech world, ideally in a startup(be a part of it or build my own), but as of now I‚Äôm overwhelmed by choices of specialisations, languages, frameworks etc lack of industry experience making it more difficult to decide as I don't know what is best for me spend my time on. With that Currently, I‚Äôm enrolled in an IBM full-stack developer course on Coursera, but it‚Äôs theory-heavy. I need guidance on what to focus my learning and projects on to get a job (to make connections and gain industry experience), aiming eventually to be a part or build a startup. Could anybody suggest actionable steps for me to follow?‚Äù
Why did you pick Flutter without any programming knowledge?
I personally don't like JavaScript, but without any context, as a newbie, learn JavaScript first then figure out the rest once you have some fundamental knowledge on programming.

Comments from https://www.reddit.com/r/programminghelp/comments/1fizfwr/good_web_dev_course_confused/:
I am confused which one to choose ???
Love Babbar Dot Batch....
Apna college delta
Striver....
I had completed C++ from Love Babbar Supreme Batch I know his DSA series was super and structured...
But I am confused for Web Dev I want to choose only one and then continue till end
Disclaimer: I didn't buy any course till now my friend buys them and we study them together
So, if u recommend which one will be good from "YOUR EXPERIENCE" web dev journey?????
WHICH ONE ??????????????????
freeCodeCamp has been great for me. its free, project based (they teach you something and then have you write a project using the stuff you learned), and there if a forum in case you get stuck. I've also heard some good things about the odin project but cant personally attest. any web-dev course you have to pay for is most likely a scam. honestly i'd say most programming courses you pay for are scams. all this information is available for free.

Comments from https://www.reddit.com/r/learnprogramming/comments/1ds74dz/im_so_confused_but_determined_on_where_to_start/:
Hi everyone,
I'm a big PC enthusiast and consider myself pretty tech-savvy. However, I'm completely new to software engineering and coding. I'm a self-learner and I've just started diving into coding with a few resources:
CS50's Intro to Programming with Python and Intro to Computer Science from Harvard University (both self-paced online courses).
Two additional free online coding classes: App Academy and Codecademy.
While I'm only starting my third week, I'm feeling pretty lost. It's reassuring to know that some confusion is normal for beginners, but honestly, I'm struggling to even explain why I'm learning to code at this point!
Many coding experts and the courses I'm taking emphasize that building beginner-friendly projects is the best way to learn. The problem is, when I try these projects, the code itself is a complete mystery.
Sounds like small refresher on the basics that were possibly overlooked by the class might help. Things like "what is a variable" and "how to use functions in python" maybe Google those and see if there are some rundowns on the subjects. It sounds like you may have been expected to have a higher level of understanding. It's easy for teachers to forget the very first steps
How do beginners learn this foundational vocabulary?
Isn't the syntax of python explained in the intro to python course?
CS50's Intro to Programming with Python
Are the explanations of the basics not landing with you or what?

Comments from https://www.reddit.com/r/Unity3D/comments/15vceh0/confused_with_unity/:
You have no idea how much easier the Editor is than typing code for every single functionality you want. It is not scalable at all. Code comes in editor tools development and making the actual game logic. Unity uses the C#, one of the easiest and best structured code ready to use for quick prototyping. Just try it out, good luck.
it's an engine that is used by people from all kinds of different fields , you can automate your process through code if you don't like clicking buttons, you'll end up just having to read documentation.
what exactly are you running into?
Welcome to how modern Engines work.
The real power of Unity come with using prefabs, reusable complex components of multiple gameobjects, components and scripts.
Of course you can create everything by code with new GameObject(), .AddCmponent<>() and so on but it is much easier to put everything together in the editor, drag relevant components for your own scripts into public or [SerializedField] variables of your own scripts and create a prefab of it that can be instantiated with one line of code or used in the editor.
There are so many ways to solve a problem in Unity. Just take some time and try different things to find your most comfortable way :)
Am I missing something about Unity?
Yes. It's intended to be usable by whole game studios, not just programmers. Typing code to do something might be easier for you, but it won't be easier for the artists, animators, sound designers, level designers, and all the other non-programmers building a game.
That being said, you literally have the means to do all that through code, just write some editor scripts to handle it for you. Or skip the editor completely, you can use the game engine as a library and never touch the editor at all if that's what you prefer.
Hmm‚Ä¶ most of what you do in Unity is by writing C# (other than importing packages, assets, building scenes and configuring options, all of which you can also do programmatically). No need to use the editor except for building your binary, though making in-editor development tools for non-programmers in your team is often a good idea, as is building your scenes using it - although nothing stops you from using procedural scene generation.
You can think of Unity as a generic level editor of sorts if you want. But your game is still 100% code.
It‚Äôs just like learning blender or cad or photoshop or any program you get used to it.
You can Instantiate objects on the fly. But you still need a reference to it.
Unity has a concept called prefabs which is sort of a template of a composite of an object with all of the components.
For instance, I have 6 different asteroids and I want to place them randomly in a scene (I don't want to drag and drop hundreds of these things). I can use the code below:
Everything you can do by clicking can be done purely by code. Unity accepts any approach you want to take.
It's perfectly fine to NOT use some tools if you find it easier to implement stuff in code, some things come in useful when collaborating with non-programmers, some may end up too specific and unsuitable for you.
The biggest benefit of the editor is that it's visual. Try to use that to your advantage and learn to use / create visual tools to interact with your code.
- https://github.com/madsbangh/EasyButtons allows you to mark a function in a MonoBehavior, and it will show up in the inspector as a simple button. It's insanely useful.
- Debug.DrawLine and Gizmos can really help you visualize what your code is "thinking". Most of the time they are as simple if not easier to use than logging messages to the console. Draw a red line between characters if they are in range but not in line of sight, green one if they can see each other. Draw a sphere gizmo where your collision detectors to visualize why your movement controller interacts in a certain way. Visualize paths, motion vectors etc.
- Interact with your game during play mode - inspect objects, see their internal state and modify it on the fly, spawn objects by just dragging them onto the scene, delete them, move them around like board game pieces... No need to write any special developer-mode code.
> Having lines of code makes it easier to return back and see how you did something in the past
Put your project in a version control system . All project files are text-based and work fine with VCS. I'd be careful about merge conflicts but as far as keeping track of change history goes you should be good. If you're using git, enable LFS and grab a ready to use gitignore file like https://www.toptal.com/developers/gitignore/api/unity

Comments from https://www.reddit.com/r/swift/comments/xgkkh2/confused_about_swift_code_execution_flow/:
I should preface this by stating I‚Äôm just beginning with Swift but I admit I‚Äôm a little impatient because I already code in other languages and I find it hard starting over each time when the concepts and syntax are so similar.
I was following along the Landmarks tutorial for SwiftUI from Apple and what confused me is the lack of import statements but I learned you don‚Äôt need them. That‚Äôs nice, but how will I know these properties are ready to use? What if one file is using an async function?
I know I need to slow down and just keep learning but I want to get my hands dirty and start coding. I got to a good place with my API server, and I want to start building a client for it.
Since you say you have experience I‚Äôll keep this brief: The language itself contains a standard library. It‚Äôs open source, on Apple‚Äôs GitHub page, if you ever want to see implementation.
There are also a bunch of closed source OS or system level libs that are required to be linked dynamically on macOS, iOS, iPadOS, watchOS, and tvOS deployment targets if you‚Äôre bundling for those. This is junk like UIKit, SwiftUI, etc. these are kinda like windows.h on Windows (not really but whatever) where they only interface on Apple‚Äôs OS‚Äôs.
Then there‚Äôs one framework that‚Äôs a weird middle ground because there‚Äôs some incomplete implementations for Linux and windows but it‚Äôs not the same, and some of the Linux version is open source, but the Apple OS one isn‚Äôt- Foundation.
‚Äî
Long story short: Swift is a robust language. SwiftUI is just an apple library for making UI stuff on Apple OSes.
Import statements in swift are automatically the same as #pragma once in C++, or #import in objective C. And they are recursive for their dependencies, though they may not always reexport the symbols.
Another thing to clarify: async/await is part of the language. Not a lib you have to link to. So no import required.
If you want to make this faster DM me and maybe we can just chat about this really quick, depending on your experience. Swift is great but I get that the community is crap when it comes to sources for what‚Äôs actually going on with it.
Edit: addendum: I think maybe you also should elaborate about what tooling and languages you‚Äôre coming from, so that we can equate Swift stuff to those languages for you. You say you‚Äôre impatient because you don‚Äôt want to ‚Äústart over‚Äù when concepts and syntax are similar, but there is a chance that you might be missing some fundamental differences that would make this all click for ya.
If you‚Äôre just wanting to solve this one exact problem you‚Äôre working on via Swift and SwiftUI, carry on the way you are.
If you‚Äôre wanting to reasonably solve a much broader range of problems without having to repeat the hoops you describe every time, step back and get the fuller understanding now.
And really, whether you do that stepping back now or later, you‚Äôre almost guaranteed to need to do it.
"I find it hard starting over each time when the concepts and syntax are so similar."
Better get used to that if you want to be a coder. lol

Comments from https://www.reddit.com/r/learnpython/comments/17r6gqe/confused_loser/:
i am an electrical engineer.i am 39 and unemployed. i did a DATA SCIENCE course for seeking a job.
But i used to watch python related videos for two years. In the course they taught the basics of python, simply like theory but not practical stuff like OOPS, functions, classes etc.
the problem is whenever i study DATA SCIENCE concepts i forgot python and when i study python i forgot DATA SCIENCE concepts. This has been going for more than a year.
i have downloaded a ton of python books and online courses recommended in one of the threads suggested in this forum.
now i have been given a youtube data harvesting projects that include streamlit, mongodb and sql.
but i am not able know WHEN AND WHERE I should create and use functions to retrieve data from youtube. the advice given to me was that i should search the INTERNET FOR writing code for this project.
I notice that you have done lots of tutorial, have you done any project on your own?
Are you already confident in basic programming? So you can solve simple problems like fizzbuzz etc? I'm just curious because you're talking about databases, API keys and competitive programming, but also claim that you apparently don't know when to use functions.
If you don't have the basics down, don't bite off more than you can chew. It's sure to overwhelm you if you try to do all this stuff unprepared.
If you do, start small. You don't have to write an entire program at once, just a single function with a single job. E.g. a single function that asks the user for the API key. A function that uses the API key to make a call and saves the response. A single function that parses the response. A function that prints stuff. A function that writes stuff into the database etc. Whenever you decide to finally "write the program", all you have to do is put the functions together in order.
Start with simple things you done in data science and make small apps with it. It doesn't need to be useful.
For example, you made a notebook that receives a CSV file, analyse some stuff and create some plots. Or take a image, do some processing and spit out a classification. Or take a url and download all images in a page. It can be anything you have done before.
Pick this bunch of code and create functions. Define as parameter anything that you may change like the path to the input file, the url, any configuration you may want to vary. Now your program is a bunch of functions and a small part at the end calling the functions.
Now take this bunch of functions, transform into a library and publish to pypi. Now you can install your library using pip install and import your script or notebook. Your main script is now just a import and the last piece of code calling your functions.
Now take your library and make a cli application. Instead of calling your functions from a script you will from your shell.
Now take your library and make a rest API, a server rendered website with Django or flask, a gui app with tkinter or pyside.
You can also make unit tests and get your library test coverage.
These all will probably suck the first time, you probably need to refactor your library a few times, but you will learn a lot of practical stuff doing this.
Funny I'm studying EE right now and feel like a complete loser; I cannot wrap my head around op amps at all. Like I get the theory but now that I have an actual use for one I cannot figure out how to set it up.
I'm going to assume you understand the basics of programming. If this is an incorrect assumption, let me know:
Read the python tutorial on the Python.org: https://docs.python.org/3/tutorial/index.html This is a quick overview.
Read: "Learning Python", by Mark Lutz. It is a comprehensive book that covers the python programming language. I suggest getting the book, it is a good reference.
In addition, to get some practice and see how other code in python use https://checkio.org/. Checkio provides gamified programming problems. You solve a problem, you get to see how others solved the problem. I found this very helpful to learn what is "pythonic", and the importance of the built-in libraries.
Bookmark these references:
https://docs.python.org/3/library/index.html It covers the built-in functions, the basic data types and the standard libraries.
https://pymotw.com/3/ - Sets of examples using the standard libraries.
After you are comfortable with the basics and bored with checkio, start to work on a few self-defined projects that will exercises your data science and programming skills, perhaps linked with another interests. Are you sports fan? analyze sports scores, Stock market investor do some stock analysis. Is there an industry that you want to work in - build a small project that would be relevant or something to talk about in a job interview. Do not get too ambitious with these projects. Keep it simple to start.
If you hit roadblocks, post code here and ask for help.
Good Luck!

Comments from https://www.reddit.com/r/vscode/comments/198ncj7/new_and_confused/:
Hi, I recently got back into python coding and went from a bad Chromebook to using my pc, so I decided to use something with more features than python shell and a friend recommended vscode. I took a class at my school two years ago that was taught in python 2 and I'm still not as confident in python 3, so some of my confusion might come from that.
I want to make a function that will slowly print a message, part of a game I'm working on, instead of the instant print of python. To my knowledge, the main part of this is just printing character by character with a specified amount of time between each print using time.sleep(), but I'm running into an issue getting the timing and everything on the same line. If I execute the code below in vscode it will wait the time and then print, rather than printing the first part, then waiting, then printing the second part like when I'm coding with standard python IDLE (I checked).
print('hello', end = ' ')
time.sleep(1)

Comments from https://www.reddit.com/r/cs50/comments/ydkzib/week_2_still_confused/:
I‚Äôm really eager to learn coding and programming so I decided to take this course. I had absolutely no knowledge of coding or computer science coming into this, and I‚Äôm finding myself confused and overwhelmed.
I just finished Lecture 2, and while the concepts make sense to me while they are being explained, when it comes to writing out the code and understanding each function and symbol of syntax, I become overwhelmed.
Is there a resource that is helpful to feel like I have a better base understanding of what‚Äôs going on, or will things eventually start to make sense in the later weeks? I feel like I‚Äôm still not understanding a lot of the basic meanings of lines of code.
(Thanks in advance)
I'm pretty much in the same boat as you. I ended up pausing my progress on CS50 to take some C specific lessons before I return. It's helping me, but I'm not done yet.
I went through the material here at https://www.educative.io/courses/learn-c-from-scratch (it's free).
Plus section by section went over this https://www.youtube.com/watch?v=KJgsSFOSQv0. I found making a google doc as below so I can highlight each topic as I review them to be very helpful.
You can copy/past the below video outline list directly from the Youtube comments on the video that was you list will be clickable for each section in Google docs. Hope that helps.
I just use this code editor for simple exercises rather than the one the video show you to setup - https://www.onlinegdb.com/.
C Programming Tutorial for Beginners
‚å®Ô∏è (0:00:00) Introduction
‚å®Ô∏è (0:01:22) Windows Setup
‚å®Ô∏è (0:05:02) Mac Setup
‚å®Ô∏è (0:09:04) Hello World
‚å®Ô∏è (0:12:51) Drawing a Shape
‚å®Ô∏è (0:20:56) Variables
‚å®Ô∏è (0:32:25) Data Types
‚å®Ô∏è (0:38:32) Printf
‚å®Ô∏è (0:45:22) Working With Numbers
‚å®Ô∏è (0:52:20) Comments
‚å®Ô∏è (0:56:00) Constants
‚å®Ô∏è (1:00:13) Getting User Input
‚å®Ô∏è (1:12:08) Building a Basic Calculator
‚å®Ô∏è (1:17:43) Building a Mad Libs Game
‚å®Ô∏è (1:26:29) Arrays
‚å®Ô∏è (1:36:44) Functions
‚å®Ô∏è (1:45:37) Return Statement
‚å®Ô∏è (1:53:21) If Statements
‚å®Ô∏è (2:07:11) Building a Better Calculator
‚å®Ô∏è (2:14:51) Switch Statements
‚å®Ô∏è (2:21:27) Structs
‚å®Ô∏è (2:29:43) While Loops
‚å®Ô∏è (2:37:48) Building a Guessing Game
‚å®Ô∏è (2:50:11) For Loops
‚å®Ô∏è (2:59:05) 2D Arrays & Nested Loops
‚å®Ô∏è (3:09:10) Memory Addresses
‚å®Ô∏è (3:17:20) Pointers
‚å®Ô∏è (3:27:41) Dereferencing Pointers
‚å®Ô∏è (3:32:37) Writing Files
‚å®Ô∏è (3:41:52) Reading Files
I found this book to be a really helpful resource on understanding C and supplementing the course content: https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628
This feels normal.
In terms of syntax, I think it just comes down to doing it a lot (doing the problems/labs etc.) I know when I started I had to look up how to implement a for loop a lot before I was able to do it from memory. Same with implementing variables ie. how do I initialize a string in c. etc.
In terms of understanding functions, adding printf statements to parts of the code can help to figure out what's happening by seeing how the variable changes as you run through that piece of code.
I can't remember if they went through using a debugger, if they did, that's something else you can use to figure out what's going on.
Also, good printf messages will help a lot i.e printing what function you're in, the name of the variable you're looking at along with the variable value itself.
e.g printf("func_x var_y[%d]: %d\n", index, var_y[index]); to look at what's happening in function_x to variable_y as index changes
Is there a resource that is helpful to feel like I have a better base understanding of what‚Äôs going on
yeah
its called a desk
do you think harvard students immediately go back to their room, sit down in front of a computer and start coding ??
no -- they attend walkthroughs --- lectures given by teaching assistants that explain how to start the homework problem
they rewatch the recorded lecture from Malan
they read the class notes with all the example code on it
they STUDY before writing a single line of code
you need to do the same thing
download the notes from edx
READ the code
STUDY the code
really figure out what it does line by line, function by function, logic by logic
do NOT type into a computer
just sit there with pencil and a yellow legal pad and think and write stuff down
Someone suggested to start with CS50's Introduction to Programming with Scratch first. I completed week 1 of CS50 and gave up after my Scratch project kinda failed.

Comments from https://www.reddit.com/r/sysadmin/comments/1c7so1u/confused_about_devs/:
Just saying, I‚Äôm confused about devs, my coding abilities are mild at best, just powershell with azure modules. However you have devs people able to work with sql(doesn‚Äôt seem hard but I never needed too) code apps make code, however they can‚Äôt even do simple things half the time like map a drive‚Ä¶ or do a ns look up.
Idk just boggles my mind, you can design a full on software program yet can‚Äôt map a drive or get confused on unc pathways‚Ä¶
Sysadmins are generalists. Devs are specialists. They don't know shit besides the stuff they learned.
System Developer / sysop 50/50 here. Started my career back in the mid 90s.
It also surprises me, how some even write software without basic network knowledge. No knowledge about routing, firewalls and no idea what the difference between for example TCP and UDP is. Some actually think a http proxy is a router.
A lot cannot write SQL anymore. They are used to dot-ing their way though a GraphQL tree or accessing data via another (usually JSON based) protocol.
EDIT: I do not think the new AI genies running in the IDEs will necessarily be a good thing with this in mind. The consequence will be, that noone really knows how to code either. At least not without a code crutch.
Since I have been both:
a sysadmin needs to know a lot of unrelated things
a software developer needs to know a whole area in depth
It's a bit like a garage mechanic vs car designers. The mechanic can probably fix the whole car but wouldn't know how to design the fairing or the electronic ignition or compute a gearbox (all things done by three different engineers).
Wait til you find out some of them don‚Äôt know about breakpoints
*eye twitches*
Or bother to learn how to write applications that don't require you run it as admin and turn off any and all security features. Or even know what ports and protocols their application uses and just want you to "switch off the firewall".
I've gotten all the responses below at least once when asking "Why does your application require local admin?":
We store all our settings in the system folder
We store our temp files in the system folder
we store all our settings and temp files in the application folder
It doesn't, except we added a check to make sure it's running as local admin just in case
I don't know
It's a matter of focus. Being a sysadmin is very unusual role in that it exists in 2 very different forms simultaneously: you can be a sysadmin working within a very narrow technological silo/scope or you can be a sysadmin doing quite literally everything with a ridiculously broad scope with the expectation that you don't have to be an expert in all of them, just enough to get by in all and be an expert in a few things.
I repeat, this is entirely unusual when it comes to job descriptions. Normally job functions are rather narrow, so while a software developer outright not understanding DNS basics and the like is pretty bonkers, you should generally be giving them a lot of leeway in not spending much time at all in areas beyond their primary expertise.
I'm a developer and I actually can map drive or do nslookup

Comments from https://www.reddit.com/r/learnprogramming/comments/1cch4yd/c_learning_conditions_and_im_confused/:
Hey I'm brand new to coding and learning the absolute basics of C#. I'm trying to learn conditions in C# for a command app and I wrote the following code:
bool werewolf = true;
bool vampire = false;
bool hungry = false;
if (werewolf || vampire && hungry) {
Console.WriteLine("You feel the urge to eat somebody.");
}
When I run the code I'm finding that that the console does write the line, "You feel the urge to eat somebody."
If you were coding this for real, you would want to include parentheses to eliminate the confusion like:
What it's doing instead is:
Werewolf is true and if the first part of an OR statement is true, the entire statement is automatically true.

Comments from https://www.reddit.com/r/AskProgramming/comments/1c4cu3p/confused_about_developing_an_app_from_scratch/:
I am trying build an app from scratch, currently I have designed in the work flow (wire framing) in Figma but I am a little confused if I should complete the designing of the app and then switch to coding or keeping doing a back and forth..
what is the the route to take?
Also, is I will have to deal with a lot of APIs and backend dev. should I start developing my resources for backend too?
please advice if my approach is wrong and if there are better ways/methods to execute app dev.
this is a serious project, where I might seek funding at some point
generally you want to build a prototype of the basic functionality before worrying too much about the UI details. chances are you will learn things and change the design as you go.

Comments from https://www.reddit.com/r/AskProgramming/comments/155jd55/confused_about_what_language_to_use_for_solving/:
I know 8 languages and I'm good with 3 of them. They're C++, Java and Python.
I know the basic stuff until arrays in C++ and java.
I was taught lists, dictionaries and a few simple data structures during my high school using python so I'm a little better with that.
Until now I've been solving questions using c++ but they're just your regular add two numbers, basic implementation type questions on codeforces.
But it seems like I've hit a roadblock with c++ because I find it too overwhelming because there's a lot to learn and I'm finding it very hard to stay focused and continue solving questions.
I'm fairly good with python and i can solve questions with it easily but I want to prepare myself for future coding interviews and in my country, some companies don't let us use python in coding rounds.
So I want to settle with a language for solving questions but I can't understand which one to use
You don't "know 8 languages". You describe knowing "the basic stuff" in 3 languages. I'd argue you don't even "know" those.
It's not important to know a lot of langauges. Pick one and get good at it. Don't spread yourself thin.
I know the basic stuff until arrays in C++ and java.
You don't know C++ or Java, so use Python.
Why not solve the same problem in all and look what works best in what case.
I'm good with 3 of them. They're C++, Java and Python.
Nice...
I know the basic stuff until arrays in C++ and java.
Ehm...
If you are equally proficient in all, I'd expect that using a high-level language like Python would take less time than using a low-level language like C++, since there are fewer things to worry about and you can focus on solving the task. If not, you can choose the one you are most comfortable with or the one you want to improve.
Language count doesn't really mean anything. Pick whatever language you can come up with solutions in the easiest, and the one you can write the solution in the fastest. Those two factors are all that matter
Use what you know best. Do a deeper dive into that.
Learn to use a good linter, IDE, and how to write integration tests. This can make development go faster.
As a matter of interest, what is it about arrays in C/C++ and Java that stumps you compared to arrays in Python?
At the end of the day, arrays are essentially the same in terms of what they do. Some syntax - especially initialisers is different, but that is just syntax (and thus easy to learn), there isn't really a functional difference. There may well be some difference in the implementations, but in general terms they do the same thing in each language.

Comments from https://www.reddit.com/r/github/comments/1afx0bj/first_time_and_im_confused/:
Hello,
I'll try to keep this short.
Background: I'm in the last year of my degree and I'd like to do a Masters in Data Science. The problem is that I'm doing a degree in Economics and Management (+Finance), which doesn't have much to do with it. My teachers have told me that to make myself more attractive to schools, I need to take courses and do personal projects on Data Science.
One of my teachers recommended that I put my projects on GitHub. But I don't know how to use this platform. For example, I'm currently working on a project using R software. Obviously, I'd have to create a folder and then upload all the project files. But the code, do I deposit it in RMD format (knowing that there will be a PDF of my code) ? Because I see people coding directly on Github and I'm a bit confused.
Thanks a lot!
Yes you deposit it in rmd format (along with any other file extensions, sorry not familiar with r)
knowing that there will be a pdf of my code.
What do you mean by this statement?
Also, there are no shortage of YouTube videos on using GitHub
There are a lot of resource you can learn from. First off, here's a short guide from GitHub on how to set up your profile. An overview of how to set up the above is as follows:
Create a Repository: Make a repository with the same name as your GitHub username. Add a README.md file to provide project details.
Project Files: Upload all your project files directly to the repository.
Code Format: While some code directly on GitHub, it's common to upload code files. For R projects, deposit the R script, not just the RMD file.
README.md: Use this file for project context, goals, methodologies, and even link to any generated PDFs.
You can as well find more material from Dailydev on how to customize your Github Profile for a beginner
In the context of GitHub the PDF is irrelevant.
You are supposed to upload your rmd, r, rscript and Amy other files required to run.
Ideally I am able to clone your repository and run the scripts to produce exactly the same output.
The idea of GitHub is not to share results that are not reproducible but to share the source code. You'll run into a smorgasbord of challenges, but don't worry, if you stick to it and choose simple solutions that help you, you'll be there in no time.
Github is just online storage to store your projects using git tool. you can use any other storage too like gitlab etc.
So if you change machines, or someone else works on it they can download the code from github and get the same output.
now the source code is not supposes to uploaded like a google drive it also includes all the history of the project which is done through git.
you need to learn git first
You could probably take a look here: https://youtu.be/HVsySz-h9r4?si=gddhS0pll-OD0ZHT
He is one of my go-to mentors when learning programming and python.

Comments from https://www.reddit.com/r/unity/comments/1dgoevz/c_is_confusing/:
Practice.
Focus less on memorizing and more on understanding fundamentals. Use c# outside of unity and do a ton of little challenges/projects and you‚Äôll never worry about remembering anything again.
Maybe, you need an pure C# experience, without unity. Like writing simple console apps, to understand what is a language, and what is a framework (of which is unity really is). Writing in an engine is overwhelmingly hard to discern what is for what, without prior programming experience, hard to discern what cause a problem.
But generally more practice, small bites, small achievable goals will help.
Data types, Classes, Loops and Methods. That is all you must know, everything else is a bonus to help you program faster.
Probably the best advice I can give to anyone new to programming and really wants to get more into it is to simply read other people's code; download a Unity repository and just read the code and run it.
you do not have to memorize anything. if you're focused on that you're doing it wrong.
I've been working in C# for 15 years and i still go to google (or now chatgpt) for tons of basic stuff. i rely heavily on my ide. this is ok and fairly normal.
computers are fucking great at remembering things for you actually.
as you get experience you'll (hopefully) get a deeper understanding of what's possible to do in the language and that will drastically speed up your lookup times.
Hey friend. I recently just learned C# (like six months ago). And unity. Here‚Äôs my suggestion:
You need to learn to think like a programmer rather than just memorize syntax. Before you even think about code, use regular English to describe how to solve your problem. Learning to program is more like becoming a carpenter than many people realize. Loops, arrays, conditionals, etc. those are just tools in your toolbox that you can use to solve problems. But you still need to think about problem solving!
That being said, I used codecademy to help me learn c# syntax. I also used hackerrank to work on my problem solving skills.
Stackoverflow and ChatGPT are excellent resources but are only truly useful when you know first, what problem you‚Äôre trying to solve, why you want to solve it, and how you might go about doing it.
Learn how to debug. Learn how to use your console, terminal, git. Learn how to read code.
Most of all, PRACTICE! You‚Äôve got this ü•∞

Comments from https://www.reddit.com/r/pokemonanime/comments/1f1wsy5/is_anyone_else_a_bit_tired_or_confused_of_people/:
In my mind I feel like all but 2.5 female companions feel more like sisters. The .5 comes from Dawn where I see both. The other 2 are Serena and Misty.
I think in the same way people ought to be free to think some pairings would be cute together, others might see them more as siblings. Like most things in interpreting media, the support for a given position varies in evidence and popularity, but the series also went out of its way to keep things ambiguous.
Become its easy to write stuff off for people

Comments from https://www.reddit.com/r/learnprogramming/comments/19d65qq/methods_are_confusing/:
I am trying to make my brain understand this:
public static void nPrintln(String message, int n){
for (int i=0, i < n; i++)
System.out.println(message);
}
We are currently doing methods, and my ability to comprehend "for" , "if/else" and "while" loops is abysmal. The part thats confusing to me is the "int i=0, i<n, i++" part. The method is taking some string and printing it "n" number of times. but i've seen that code be used in other ways. Is there a way to make my brain understand that better. Its starting at 0 and going up to the value of n. Am i interpreting that correctly?
This:
is just a shorthand syntax for this:
Can we not downvote OP please for posting a reasonable level of confusion in a subreddit devoted to learning programming, for goodness sake?
Methods are like mathematical functions. Like in math how you have some function f(x) that takes an input x, and an equation for the function like f(x)=x2 that pops out a result with some arbitrary input ‚Äòx‚Äô. You input the number x=4 and the function returns 16. Same thing going on with methods.
For/while loops are a bit like summation formulas, where you start at some integer then increment an arbitrary n numbers of times.
In this case, you‚Äôve got a function, like f(message,n) that takes a string ‚Äòmessage‚Äô and an integer ‚Äòn‚Äô. So your function be used in such a way, f(‚Äúhello world‚Äù, 10)
The n is used in the for loop, the loop begins at 0 and increments to n=10, meaning whatever is inside the brackets runs 10 times. Then the variable ‚Äúmessage‚Äù in the System.out.println() function prints that message. Meaning the loop runs 10 times and prints ‚Äúhello world‚Äù ten times (to the console).
In addition to what others have said, that‚Äôs not a method it‚Äôs a for loop, by the way. 
For (as long as) Int i (your chosen start number) is lower than your n (your chosen end number)
And for each time we increment i (i++ is the same as i = i + 1)
Print your line.

Comments from https://www.reddit.com/r/PhysicsStudents/comments/1avnudl/confused_about_programming_as_a_physics_major/:
I'm a sophomore, completely confused about where and how to start learning coding and all. For context, I want to learn programming to help me in future with computational physics. Also, I need to learn coding for freelancing because I'm desperate to get financially independent asap. P.S: Sorry for bad english, if any, English isn't my first language (ik its a common excuse)
Hi! I recommend you this book A Student's Guide to Python for Physical Modeling, I‚Äôve been reading it and its really straight forward.
If you need to start working soon, then I would suggest starting with Python. However, I don't personally recommend Python for compete beginners. Python is high-level and easy to use, but that simplicity can hide important computer science concepts. You may be able to make do without learning those concepts, but they'll need to be understood sooner or later.
I suggest starting with C or C++. You don't have to become fluent in either of them - just some basic Computer Science 101 skills can help you grasp the important concepts. Then you should start learning Python.
I'd start with Python, pick a project to work on and solve it using Python. You can pick up everything on the go via YouTube, etc.

Comments from https://www.reddit.com/r/college/comments/1ex3j9q/im_confusedcomputer_engineering/:
So I just graduated. I‚Äôm 17. I just got accepted into this college. I‚Äôm applying for these scholarship things and well when I was applying to college. I was looking at majors and none of them really caught my eye except civil and computer engineering. Maybe like personal training since I like the gym. But I don‚Äôt think that would make as much money and I alreayd go to the gym everyday so it would be annoying coming home from work and exercising again lol. But besides the point. I‚Äôm scared I won‚Äôt be able to go through these 4 years to get my degree. I‚Äôm good with my hands, decent at math good with computers, atleast better than the average human. I didn‚Äôt choose civil due to being afraid of heights, I know I‚Äôm a loser lol. So I chose computer engineering. Which seems like the best for me. Because I want to be happy with my job and also make a living, I didn‚Äôt know what computer engineering was like literally 2 weeks ago. Once I found out they like build like the stuff I thought that was pretty cool, but there‚Äôs also a bit of coding, now I know nothing about coding except the names of the languages. That not my most worry since I‚Äôve seen people learn coding at their house by themselves. I‚Äôm worried but I‚Äôm still scared, I‚Äôm worried about math. I am good at math. I mean in my school my math teachers said I was a good student and I always got the highest scores. I mean but the highest math I ever took was like algebra 2 honors,math for college. And financial like math. Those aren‚Äôt really that hard though. Like I got accepted yesterday and the semester literally starts aug 26. I kind of made the mistake of just having fun the whole summer. Im just thinking about my future, the whole summer too, really being picky on what I should be in the future. And these are my only choices to make a life for myself. I have no clue about college to be honest. I‚Äôm just taking risks. And I mean you can‚Äôt go no where without taking risks. I‚Äôm just asking a question. What should I like be ready for and any tips, thanks
Here are a few career areas that are adjacent to personal trainer: nutritionist, sports medicine, physical therapy, occupational therapy. Maybe even biomedical engineering if you fancy designing gym equipment.
"I didn't choose civil due to being afraid of heights" - I'm not sure how much that would really matter.
You are going to be a freshman. Chances of you changing your major like 4 times is high.
Just go and see if you enjoy your classes. If you do not, you are still doing many foundational courses to pivot to related fields. And if you hate them all, you‚Äôll learn that too and will still be able to switch.
Some specific things:
what does hating heights have to do with civil engineering? Nothing. You aren‚Äôt climbing bridges. You‚Äôre learning how they‚Äôre designed.
most people enter their majors not having a background in them, and there is zero expectation that you know how to code for things like computer engineering.
And for things like the required math, you‚Äôll take the right courses to build to the requirements. Right now, you‚Äôre about 2-3 courses ‚Äúbehind‚Äù the beginning prerequisites for most engineering math and physics requirements (ie, calculus and calculus-based physics). Also not a problem as you‚Äôll build there.
3) majoring in ‚Äúpersonal training‚Äù does not mean you‚Äôd be training all day yourself. Again, you‚Äôre learning the biomechanics and nutrition background in order to be one.
I think what you need to do more research on is exactly what it means to major in something. Right now, you seem to have a lot of wrong ideas about what it entails and what you‚Äôd be doing.
I know nothing about coding except the names of the languages
Do you know how to learn?
Because your professors know how to teach pretty well.
I‚Äôm worried about math
Pretty much every US university has a Math Assistance Center or Tutoring Center that is either free or is cheaper than a sandwich.
You have the basic outline of a good career plan here. You gonna let something as stupid as calculus stop you from accessing that career?
I mean but the highest math I ever took was like algebra 2 honors,math for college
Doesn't really matter. If you know how to learn, and are willing to apply yourself to learning, your professors know how to teach.

Comments from https://www.reddit.com/r/softwarearchitecture/comments/17u1974/any_advise_for_a_confused_computer_science_student/:
Hello, I am a student in the fifth semester of computer science and I am very confused because I feel like I know nothing but at the same time I know things. In addition, in the projects during the semesters I have always had the role of scrum master or team director and my classmates have been the ones who develop code. I love being a scrum master ,directing projects and software architecture attracts a lot of my attention. But I have met many classmates and professors who tell me that in order to be a software architect I must first learn a lot of code and be a full stack developer and get at least 5 five years of experience in that . I really am very reluctant to code, I love administrative tasks, working with the team defining design patterns and things like that but not sitting down to type code all day. Do u know what my ideal job could be, and if I'm in this process of becoming a software architect or a software project manager, what path should I follow?
Software architect (as in, that's both the role and title I hold on my team) and Certified Scrum Master here. There are a few misconceptions here as well as some harsh truths:
You will not be an architect straight out of college, even if that's your goal. You could start your own company and call yourself an architect and you wouldn't be a very good one. It takes time and experience. I've been working around 15 years professionally and only titled an architect for two. Five is FAST.
You don't have to be a full-stack developer to be a good architect, but it helps a lot. By being proficient on the "end to end" of your product/stack, you will be able to make better decisions on where to put processes/components and balance them. But you CAN be, for example, a back-end architect (assuming a web stack, since you said "full stack") and be a good fit for some projects.
If you don't like coding or don't think you can do it for a large part of your day for AT LEAST 5 years, don't go software development, that's our baseline. It really sounds like you should be going more toward business management or general IT (some colleges offer that? I don't remember it at mine). Here's a current job posting that talks more in depth.
On my project, we have four dedicated project managers. Only one came up through the tech ranks (she was in quality assurance, not directly software). The others came from business. Look at Business Analyst and project management paths.
Edit: I forgot to mention: you CAN do this straight out of college, but you're going to be doing more user reaearch, requirement gathering, prioritization meetings, administrative and "grunt" work for the first few years rather than being the team leader for a software team.
While you enjoy architecture at university it doesn‚Äôt really compare with the scale that is used in industry.
The reason why software architects are born from veteran engineers with 10+ years experience is that it takes an understanding from a combination of the product domain, the language being used (its strengths and weaknesses), and experience of how design patterns scale with both the business case and also the organisation.
You can‚Äôt do those things unless you have written code, made mistakes, and paid attention to how the software evolves over time. An architect will be designing what the codebase looks like in 2-5 years time or more.
From your post, it sounds like you care more about the project management side of things. IMO your options are to look at product management (PM) work or to do 4-5 years as an engineer and aim towards becoming an engineering manager (EM).
To get into a software architect role you will be working your way up to senior engineer, then to staff engineer, then you can look at approaching an architect role.
If you don't like coding, you can still be someone who is at the interface between business and IT. There are plenty of jobs that are exactly at that borderline. Of course, doing software development after university will teach you a lot ground-up, but in the end not everyone likes coding a lot. Also, there are highly technical jobs where you don't really "code" in a traditional sense, for example many cloud engineers usually don't "code" but they write scripts every now and then to automate things (e.g. Terraform).
So, Software architect is probably not the right thing if you don't want to do a few years of software engineering. But project management is interesting (I always liked it). There are also enterprise architects who operate on a higher level - but be aware to be really good at it. There are too many enterprise architects who don't truly understand the lower level problems, and in my experience enterprise architecture is something you should only be doing if you really get the fundamentals right. Then there is a whole world of business analysts (was more popular in the 1990s as a profession), which is at the border between IT and business. Many consultancy jobs are also operating at this border.
Just some ideas.
It sounds to me like you may enjoy Project Management within an IT field....
Whatever direction you decide to take, it must be one where the work is something you love doing. It needs to be something you could spend hours and hours working in without realizing just how much time has passed. The reason for this is there will be difficult times. It might be a contentious meeting with your business customers, an urgent production issue, devising a complex project plan, or simply trying to get your code to work. It will be your love of the craft, whatever craft you choose, that will carry you through the tough times.
It's been said elsewhere in this thread you need to spend at least five years in software development, writing and debugging code, before you can reasonably call yourself a software architect. I concur. I waited 20 years while calling myself a programmer/analyst, systems analyst, business analyst, and software developer before putting Software Architect on my business card. Though I admit, I'm a bit of an extreme case.
As others have suggested, perhaps project or product management is where your destiny and passion lies.
Good luck with your decision, and enjoy the ride.

Comments from https://www.reddit.com/r/AskProgramming/comments/iknxxx/confused_between_competitive_programming_or/:
Hello, I currently work in IT support. But want to do some contribution toopen-source projects. I would like to know what approach will be great for me to achieve skills in coding. Shall I try for competitive programming or do shall I do debug a small GitHub project
Competitive programming is almost completely different from actual real-life projects.
Competitive programming projects needs to be quick to write and run fast. There's little to no error management, the code isn't easily readable, the tasks are usually rather abstract, there's usually a single person writing all of it, there's little architecture needed...
It can be fun, of course, but if you have to pick one and you think that both sounds fun, go with creating a project.
But want to do some contribution toopen-source projects.
Well, you have your goal. The only way to achieve it is by doing ... precisely that. Pick any small open source project, start studying it, making changes, possibly create bug reports, fix bugs, and then once your knowledge of the codebase is at a sufficiently high level, start contributing code. Rinse and repeat.
If I'm not wrong, you're inclined towards contributing to open source projects and there's a simple answer to your question. Just go to github and find a project you're really interested in and not just because you want to contribute. You'll need motivation to keep working on the topic you select and that comes only if you actually want to change something that's happening wrong with the existing software.
Also, competitive programming is as important as project based learning because companies usually ask coding questions in interviews. Apart from that, you'll always find new ways to solve a problem and have a strong understanding of algorithms and data structures.
So, it depends on you how much time you should be giving to CP and projects you want to work on.
Competitive programming isn't a great way to learn how to program.
You need to build up the skills first to be at competition-levels, usually by doing projects and daily challenges like kata on codewars.com (which is competitive ... loosely. It's a good way to solidify fundamentals, see what other people come up with for the same problems etc)
Imagine you want to become the next Annie Oakley, but only shoot during competitions instead of practice on your own time. Sure, you can learn to point and shoot but you'll never have the finnesse the greats do until you've got a good amount of time under your belt with the gun
Project-based learning is more valuable, but you do need a certain level of algorithm and data structure understanding. If you're new at coding, you should do project-based learning, and after a while try competitive programming.
Basically you only need to be able to solve problems on competitive programming, but having more project-based learning is really more valuable.

Comments from https://www.reddit.com/r/CodingHelp/comments/1f4ez78/really_confused_about_the_error/:
Hey everyone, I'm currently working on a coding assignment for class and it involves printing out the size of "bytes" for specific data types. However, I keep getting this error saying that "{" is not allowed even though that is what is required to output the answer properly. I'm not asking for a straightforward answer, just want an idea of what I'm doing wrong
This is my code below and the error I keep receiving
it works fine.
Is that the complete code, and the error?

Comments from https://www.reddit.com/r/webdev/comments/mzq4so/is_it_normal_to_get_confused_in_your_own_code/:
I feel like my code is a mess and I have a different html, css, javascript file for every subpage and I feel like I'm overwhelmed. What things can I do to organize my code better?
I assume the reason for your confusion is that to understand the code, you'd need to keep more data in your brain than your short term memory can hold. Others have mentioned it, you need to refactor your code.
However, when you refactor, do it in a way that reduces complexity. That means, to understand one part (a feature if you like) of your code, you don't have to understand the rest. It's not always easy, but being able to manage complexity is what will make you able to create large applications that can be maintained for a long time.
I can very much recommend reading Code Complete by Steve McConnell. There you'll learn more about this keeping your code maintainable on a high level.
Just comment the hell out of everything. Will save you headaches when you return to a project months or even years later.
You can use templates i.e. ejs templates to make your content dynamic. Write code in a general way so that it can be applied to multiple pages. Do use comments to explain you code in your own terms. Almost everyone suffers from this problem, the key is to practice practice and practice.
first make sure you understand your code,
then refactor the code in each file
then look for modularizing i.e possibility of extracting modular code in some files into another file and then importing it, e.g business logic, utils.js
.. tip: first make files in the most natural way it feels to you, then you can look online for folder structure patterns and adopt one that feels good or adopt parts of it.
Are you applying DRY?
Lol yes. It means you've grown as a developer since you wrote it..

Comments from https://www.reddit.com/r/AskComputerScience/comments/xhb0fy/confused_about_logical_operators_and_bitwise/:
So I know quite a bit about boolean algebra and set theory. In programming I wonder why if you have a boolean of let's say 1011 && 0101, why is it equal to 1 (true), when it's clearly a contingency and not a tautology? A simple truth table shows that it's a contingency (0001).
It's because logical operators in programming operate on the notion of type casting. Computers store groups of bits in "registers", and must interpret those bits as a given type in order to do something. So the 32-bit sequence 01000010 01000101 01000101 01010000. Interpreted as four characters (0-padded ASCII values) these bits are interpreted as "BEEP". Interpreted as an integer, these bits are interpreted as the number 1111835984. Interpreted as a floating-point number, this is 49.317688. (Side-note: this is called big-endian.)
When we cast values to a boolean type, we typically cast 0 to false, and anything else to true. This is just a convention.
So when we do bitwise operations like 0100 & 0010 = 0000 which casts to false when interpreted as a boolean. But logical operations do the casting first, so 0100 && 0010 = true && true = true.
Does that answer your question?
Typically in programming, any number not equal to 0 is regarded as a boolean 'true' value. In this sense, something like if(A&B) can be treated as 'if any bit is true in both A and B'. If that's not the behavior you want, you have to use different operators.
Well, it's not. The bit string 0010 and the truth value true have different types and thus saying that 0010 == true does not even make sense.
You might be talking about the C language, where people thought that it would be a good idea to say that many scalars "have truthiness", meaning that code like if(x) foo(); else bar(); executes foo(); if the value stored in x, when interpreted for its truthiness, is true.
integer types in C have truthiness, and the interpretation is such that all numbers except 0 correspond to true. Similarly, pointers have truthiness, and all pointers except the null pointer are interpreted as true.
This, however, is something specific to the C language, and many other languages are more sane. It's just that back when C was first created, people noticed that you often compare with 0 and that your programs get shorter when you don't always have to write this.
With your background knowledge, you might be more helped by learning a language like Haskell before going for C or what it is you are looking at right now.
In programming
Note that different programming languages do this differently. Your question doesn't really make sense without qualifying what language you're discussing. Presumably C or a C-like language?

Comments from https://www.reddit.com/r/github/comments/17wycwp/so_confused_help_what_is_this_copilot/:
What use does this have for everyday users of Windows? I try to find info on Copilot and it literally is only developers. I do not want Copilot on my computer. It has an icon on my shortcuts toolbar that will not be removed. Sometimes it randomly pops ups when it's not wanted.
And, are you fing serious? It suggests prompts. Like it's some basic, dumb chatbot. I even told it that I wanted to delete it. It gave me instructions that did not work. AND, it suggested I changed the topic.
This feels like AI assault. I want it gone. 100%.
Also, there are YouTube videos from a few years ago about Copilot. I literally never heard about this until a week ago. I bought a new laptop. Am I just really in the dark about Copilot? Do everyday users ( != developers) love this feature?
So, how do I delete this?. Not uninstall. But compeltely remove it. And, does the general public like Copilot?
Copilot is the name for a few products. The one you see on your computer has nothing to do with GitHub‚Äôs Copilot. GitHub Copilot is a tool for developers that mostly is used for writing code and is access in your developer tools.
The one you are seeing is from MSFT and is totally unrelated to GitHub
It's a rebrand. Microsoft loves to rebrand stuff. Bing Chat became Microsoft Copilot. Cortana got killed so basically Copilot is your virtual assistant within Windows now. Instead of searching on the internet "how to do X" for settings on your Windows machine, you can just simply ask Copilot and you can give it the permissions to do the work for you.
You are looking for "Microsoft Copilot", "Copilot" (unqualified) is usually used for programming.
Confusing! Microsoft uses this term and then there is also GitHub Copilot which is their AI pair programming tool
Try installing Bonzai Buddy next.
I got tired of just random shit and moved to a different OS. BGAUpsell.exe broke me*
Other options
A. Windows 7/10
B. OSX
C. Linux
There's no wrong answer but W11 at this point. I moved to Linux but pick what works for you. I run the last of my Windows apps that I need for work in Bottles and have not regretted it one bit.
https://www.reddit.com/r/computerviruses/comments/149x25h/bgaupsell_what_is_this_bing_popup/
Pay for an OS to do my work and get additional marketing on top? No thanks. Imagine if you had an electric screwdriver randomly play a sound advertising their saw. Tradies would lose their shit.
r/OldManYellsAtCloud

Comments from https://www.reddit.com/r/learnpython/comments/18xrq4j/so_confused_fibonacci_sequence_code/:
OK, so I have the following script:
I am wondering why this function actually works properly. Every time I try to do this in my head, I get the values of new and old to be updated to:
iteration 1: 1, 2 (1+1)
iteration 2: 2, 4 (2+2)
iteration 3: 4, (4+4)
I thought that new would be set to equal old at the beginning of each iteration of the loop. What am I misunderstanding?
new gets set to old after old, old + new has been evaluated. The way that assignment generally works is that first you evaluate what's on the right side of the = and then you assign the result of that to the left side. This is still true for tuple assignment.
So for the second iteration of new, old = old, old + new, the steps that are executed are:
Evaluate old, old + new
Evaluate old, which is 2
Evaluate old + new
Evaluate old, which is still 2
Evaluate new, which is 1
1+2=3, so old + new is 3
Create the tuple 2,3
Unpack the tuple and assign its elements to the variables on the left of the =
Assign new = 2
Assign old = 3
PS: It's a bit unfortunate naming that in this code snippet old contains the latest value and new contains the one before that. That seems the wrong way around.
I forgot to add an 8 to my old value of iteration 3 but y'all get the gist of what I am doing.
Variables are swapped sir.
You can also use recursion method to find Fibonacci series

Comments from https://www.reddit.com/r/cs50/comments/1cm6wf4/im_a_bit_confused_now_let_me_explain_my_story/:
I'm a bit confused now, let me explain my story:
A year ago, I graduated from college and got my first laptop. Then I tried ChatGPT, started using other projects from GitHub, and began exploring AI, although I honestly don't know much about coding; I've been completely relying on ChatGPT. Later, I got access to a GPT-4-like model through someone who set up an API and created a Discord server for it. I joined the server, got the key, and started trying to make a simple website entirely with ChatGPT's help, despite having no tech background.
My friend, who's a BTech student from NIT XXX with experience in Android development and a bit of Python, also found these AI models fascinating. We discussed how many API endpoints are available for this, and he suggested why not make an Android app and publish it on the Play Store, offering access to this AI chatbot for free. So, he developed the app while I handled the simpler mobile design and managed the app promotion and source balancing for the service. Surprisingly, the app quickly gained traction and amassed over 10,000 downloads, turning into a profitable venture until our Google Play Console developer account encountered issues.
I am currently working in a Consultancy firm and for developing skills I have a habit of doing courses. I did my under-graduation majoring in Electrical and Electronic Engineering. Programming was something that I initially was a bit afraid off . However, after taking C and due to my lab instructor, I learned some methods and it fascinated me to do coding just as a hobby. If you are really passionate, then I guess you can manage both. I am currently enrolled in CS50P (verified track) - edx. So, far learning many things just for personal development. Hope you will also enjoy taking the course and yes if you think it is hampering your IAS preparing, you can study by taking regular intervals in between- lets say 3 or 4 days or even a month. I think there is you tube channel also where you can see the content free. However, the quizzes will not be available which I also do not prefer. Learning is rewarding if you know you have gathered knowledge and this can only be proven through assessment and so quizzes are important.

Comments from https://www.reddit.com/r/Indian_Academia/comments/1cq9po4/pcm_if_i_dont_care_for_coding_help_a_confused/:
"myquals" 10th pass Im decent at academics so far and as it goes i took pcm without thinking but heres my concern- i dont really care much for coding or technology or even science- i enjoy math but its not something i do for fun either
as a child i loved graphic design, ive always loved pol sci and international relations, and i have also been drawing off late. i love reading and writing too
i think i should take commerce+math and prepare for clat/cuet/nid side by side but im worried about the opportunities this cuts of
my main concerns work life balance and a decent salary
kaunsa stream lu-
If you don't care about those (science and coding and all) then why should you be worried about the opportunities it cuts off? Imagine preparing for jee when you don't even care about tech and coding üò≠there are many options in commerce + maths too like clat cuet nid uceed ca cs and all moreover if you decide to do an mba later you'll get diversity points for being a non engineer... Also ipmat can be a good option for you as you said you liked pol sci and maths...in IPM they teach a lot of different subjects :) I'm also going in class 11 and took commerce with applied maths and I hope this helps
Well there are very different things you can do after taking pcm like architecture, merchant navy, pilot, cabin crew, you can even go for graphic designing. See if any of these fields interest youü§∑
Sun meri baat chote. Badhiya Jee ki coaching join kar. Jam kar padh. Clear Jee and advance. Get in a good college and do btech with CSE. Do coding and whatever you like. Your life will be set. But padhai kar. Take 11th and 12th seriously.

Comments from https://www.reddit.com/r/learnprogramming/comments/1b3mk97/want_to_get_into_programming_and_totally_confused/:
I am 19 and would be entering into college this year and really wanna get into programming. I am totally confused where to start and what language to learn and form where to learn basically how to get started and want some help
The (almost) universal answer is that you start with Python and the free CS50 course from Harvard Uni.
https://pll.harvard.edu/course/cs50-introduction-computer-science
SICP (seriously)
https://web.mit.edu/6.001/6.037/sicp.pdf
https://www.youtube.com/watch?v=2Op3QLzMgSY
Read the FAQ

Comments from https://www.reddit.com/r/gamedev/comments/qqydq5/im_currently_confused_about_which_programming/:
I've been doing video games and programming for a few years (mostly as a hobby). But I've been using mainly the paradigm of OOP (Objected Oriented Programming). In fact, I currently use the Unity Engine and C#.
But yesterday I started reading some articles, videos and reddit posts that criticized this programming paradigm (OOP) and also supporting Functional Programming and sometimes other paradigms too. So, now I'm confused and I don't know if I should continue using Unity and C#. I neither know if OOP is bad.
So, if you don't mind, I will ask you a few questions, since I know that in this subreddit there are lots of experienced people:
In what paradigm is easier to make games? I'm interested in making from big 3d games to more casual 2d games. (Obviously when I say "big", I don't mean as big as an AAA game. But I mean like a big project that takes months/years and maybe in 3D)
In what paradigm there is more tutorials, information and documentation resources to make games?
These are all just tools.
OOP is great, functional programming is great, procedural is great, they all have their place and that's the main thing to remember. There's no right or wrong.
Paradigms don't make software (which includes games) good or bad, the way you use them does.
If you are at the beginning of your journey go with what feels right to you, learn that deeply then learning other things/approaches will be much easier and make more sense.
TL;DR stick with C#/Unity
In what paradigm is easier to make games?
I would suggest putting this question on the back burner for now, forgetting the question, or rephrasing it.
"What paradigm should I use to program my next game?" Is somewhat a better question. It is more answerable. If you want to learn functional programming, then you may decide to make your next game in an entirely functional paradigm, as a way to really learn functional programming. If you have a vision for your game and want to make that vision reality, then you may decide to use whatever paradigm you are most comfortable with. If you use a comfortable paradigm, you will get work done faster.
There are certain paradigms that you may choose to use for projects with large numbers of entities. Performance is important if you are playing a game with 10,000 soldiers on a battlefield. If you're not making something that massive, don't worry so much.
In what paradigm there is more tutorials, information and documentation resources to make games?
There is enough information about any paradigm that this is not really a concern. You can find examples of procedural, OOP, component-based (like Unity), ECS, functional reactive, etc. tutorials with source code available.
Is OOP bad? Why?/Why not?
No. It's just a bit over used. It was hyped a lot in the 1990s and we are still coming down from that hype.
Can I use multiple paradigms at the same time for making one game? For example, I've heard about ECS (Entity Component System). I also heard of Data Oriented Programming. Can I use OOP and ECS and FP together?
Sure, why not?
What paradigm is faster and efficient when executing games?
The slowest part of the game is the part where you wait for a developer to finish developing it. So, the fastest, most efficient way to make a game is the way that you already know. If you know OOP, that will be the fastest and most efficient. If you do not know FP, then it will be very slow and inefficient for you to do FP.
Should I stop using Unity and C# and find another paradigm and programming language to make games? In that case, what do you reccomend me?
Depends on what you want. Do you want to use another paradigm? Keep in mind you can use other paradigms with Unity and use Unity as kind of a rendering engine, if you really want. There is no rule that says that you have to implement your game using components in Unity.
You will not find the answers you want by asking people to tell you which paradigm is better. Instead, you may decide that understanding these different paradigms is important to you, and in order to learn them, you make complete games using different paradigms. Make a game using traditional OOP, make a game in Unity using components, make a game using ECS, make a game using functional reactive programming or whatever.
i mix them all. i don't care.
OOP is just fine for indie games. Minecraft used OOP. Guess what? The author made billions of dollars. Anyone who says OOP is bad and you shouldn‚Äôt use OOP doesn‚Äôt know what they are talking about.
OOP is a tool and sometimes it works great but other times some other tool would be a better fit. But you need time and experience to understand what to use and when. And most importantly the decision should be based on benchmarks if/when there is an actual performance problem. And it‚Äôs not like the whole project would need to switch away from OOP anyway. Maybe just some parts of it. But all of that should be based on informed decisions. Not guessing at the problem.

Comments from https://www.reddit.com/r/learnjavascript/comments/1earezf/this_is_a_junior_programmer_confused/:
First at all, i am a front-end programmer from China.I main use Vue2/3 for daily work.Lots of my job content is backstage management system, mini program(one mini app can running on Wechat), some H5 pages.
I have four years of work experience.Lately, i start to feel my job is boring, my job content is boring and easy, i don't know what the work environment is like abroad, i can only speak to what i have experienced.
In our work culture, focus more on the usability of the code, we have no code review, you just need to finish your task,and no need to think about Code correctness or Code robustness. We call that "SHIT CODE". Lots of managers are not programmer, they don't care about the quality of code, but i start to accept this way, you know "existence implies validity".
Even though i have a lot of grievances, i know i am not a excellent programmer, China has many good Company, it's just that the companies i've worked for haven't been very enthusiastic about code. I have used React, Node.js, and even Java for development, but i am not proficient in any of them.I find it difficult to read source code, so i rarely attempt to read it.
If you have free time you could make your own small projects using what you know. For example a photo gallery, a online shop, a task organizer, a chat app or think of something you would want to make a website for, for example a website about your hobby.
Make them simple in the beginning and then add more to the website to challenge yourself.
4 years of work experience gives you good chances of being hired by another company, have you thought of finding one who works the way you wish and apply to them to a similar position ?
I think it is a great impulse to practice clean code and maybe have some fun with some side projects. Clean code gets faster and easier to write the more you practice. I would suggest finding something that excites or interests you and just go for it.
Some examples:
Open Folio (by me): I love Shakespeare and back when I was first learning JavaScript, I learned a lot making this live-formattable version of Shakespeare's first folio.
Meeba Farm (by me): I am always fascinated by emergent behavior and after running into an evolving racing simulation, I really wanted to build my own version with real life forms. This latest version of the idea is built on the Canvas API, and I learned a ton about optimization working on it.
One Million Checkboxes (by eieio): It's over now, but this was a live set of a million checkboxes which live updated for everyone on the page (until all one million were finally checked). Exactly the sort of fun silly idea you are looking for.
Wordle (by Josh Wardle): Before being purchased by the NYTimes, Wordle was a side project Josh made for his girlfriend who loved word games.
So the question is, what do you love? What motivates you?
There are two ways you could improve yourself:
Build a personal project - Make something that solves a problem. You can even ask people here to review your code to learn what you can improve upon.
Contribute to open source: This will make you read other people's code. You will learn better way of doing things. Also the code you write will get reviewed, giving you a chance to improve.
Ë∑≥ÊßΩÂêßÂÖÑÂºüÔºå‰Ω†ËøôÂÖ¨Âè∏ÊÑüËßâ‰∏çÂ§ßË°åÂïä

Comments from https://www.reddit.com/r/learnprogramming/comments/wgor8u/im_in_bootcamp_but_im_confused/:
Hey Yall,
So I am in a University FullStack Development Bootcamp. It's a 10 month bootcamp, that goes through everything with 3 milestone projects every 3 topics. While I am 5 months in, I find it complicated to retain the info.. everything moves so fast and while we're on react/redux now.. I still feel like I have a half ass understanding of CSS and Javascript.. Back End went by so fast.. I still have to catch up on the assignments. I understand that bootcamp is suppose to help you understand.. but by moving so fast, I feel like when I finish I am going to have to go through everything by myself to really understand wtf is going on. Is bootcamp suppose to be like this?! or is there anyone who has previously been through bootcamp tell me how their journey went...

Comments from https://www.reddit.com/r/learnpython/comments/1czarni/now_i_m_confused_and_depressed_too/:
I was looking for starting my journey to get into AI And ML and automating things through python, because I actually love working in python but after my last post I don't have that confidence with python as everyone is saying it's just fanboys who says python is good for these things and it's slow, it's only a beginner friendly language and can't relly on it for future and all. My summer vacations will be starting soon and I was so excited and now I m depressed like hell. Please someone help me through this and kindly guide me if you can
Anyone who says this is either an idiot or a troll. Python isn‚Äôt going anywhere any time soon. In fact, it is the most widely used language in the world. I write software for a very very large telecommunications/networking company that you may have heard of and everything I‚Äôm doing is in Python. Learn Python and be excited about it! And stop listening to every other asshole on Reddit, some people just want you to be as miserable as they are.
I don't have that confidence with python as everyone is saying it's just fanboys who says python is good for these things and it's slow, it's only a beginner friendly language and can't relly on it for future and all.
I don't know of any work in AI that isn't happening in Python.
Even if all that is true knowing how to code in python makes it easier to learn other coding languages. Stop letting other people drive your journey
everyone is saying it's just fanboys who says python is good for these things and it's slow, it's only a beginner friendly language
I've been using python since the early 2000s professionally, ie, getting paid to do it. I have worked on systems that simulate the effect of rainfall, river flooding and tsunamis, technical systems that track items through wifi signal strengths, and monitoring research cloud systems that physicists use to analyse Large Hadron Collider data. Reddit is written in python. This page lists organizations that use python, and it certainly isn't complete.
and can't relly on it for future and all
Python has been around longer than the Java language which those "other people" might think is a long-lived language. Sometimes other people don't know what they are talking about.
Python is a good beginner's language, easier to start than some but not limited when you get more advanced. If you get into programming in a big way you will learn many languages, amongst other things. Python is just the beginning.
I always laugh at comments that uses the ‚ÄúPython is slow‚Äù as a reason not to use it.
Couple of points in that:
To actually make this a valid argument, you need to be able to write more efficient code in another language. Lots of programmers aren‚Äôt able to do this, so the point is null. Much better to use python to learn better and faster programming techniques
It needs to actually matter. If you‚Äôre writing an automation script that runs once an hour, it doesn‚Äôt matter if it takes 0.1 seconds or 5 seconds, or even 5 minutes. It‚Äôs not that important. It only matters if your code runs slower than the intervals required.
Most of the python libraries are optimised in C, so it doesn‚Äôt actually make that much of a difference
"Everyone" is clueless.
Python has been ranked as the most popular backend language among professional developers, according to the global Stack Overflow survey for 2023. It has a dominant presence in the AI/ML domain and is one of the most utilized languages for automation (with Java being a significant competitor).
In the "admired and desired languages" category, Python is rated as the most desired language by developers and is also among the top admired languages.
Additionally, once you understand Python and have experience in logical thinking, problem-solving, and an algorithmic mindset, you will be able to pick up any other programming language quite easily in the future.
who says python is good for these things and it's slow, it's only a beginner friendly language and can't relly on it for future and all
Send them this list, https://realpython.com/world-class-companies-using-python/
and this, https://engineering.fb.com/2024/02/12/developer-tools/meta-loves-python/
If you want to learn Python, go learn Python. Don't let random strangers on the Internet get to you.
For your use case, Python is definitely the right move.
It's absolutely beginner friendly, but it's also expert friendly.
It's not the most efficient language, but efficiency doesn't matter until you're operating at massive scale.

Comments from https://www.reddit.com/r/javahelp/comments/1fbb0ek/confused_on_revel_java/:
I keep on running into the same issues when I code (Java) with the console on Revel and I don't know how to fix it.
This is the code,
I don't understand what is wrong with this code because I have the main method, the statements, my terminators, and my closing brackets, yet I keep getting back for the 5th line,
"Error found after student code on line 11: class, interface, enum, or record expected"
No idea. I don‚Äôt even know what Revel is, and since this isn‚Äôt /reveljavahelp maybe others don‚Äôt either. It sounds like some learning platform. You may have better luck asking them for support or using a community channel/forum for that product and class.
Are you sure it wants you to write a full class with main method? It might just want you to write a method body.
The code is perfectly fine. Yet, the problem seems to be with Revel.
Show exactly what you are supposed to do and what you are doing.
Grab some screenshots and throw them on imgur.com and link them here, please.
Are you showing all of your code? It says that there's a line 11 and you don't show a line 11. Also, what is the full output (leave nothing out) when you try to compile it and you get those errors?

Comments from https://www.reddit.com/r/learnprogramming/comments/18b9eij/im_really_confused_about_my_coding_career/:
Hello there. I want to share with you my journey with coding. I did a 4 months course focused on front end developing, so I studied HTML, CSS, Javascript, React and SASS. Everything was fine during the bootcamp (even if I was struggling a lot with some concept like arrow function and stuff like that) but when I finished it I was really really confused. Literally no ideas of what project should I create, I tried to build something but I failed, I failed to create a layout, a landing page and I am so demotivated. When I started the bootcamp I was really happy to build websites but now I really don‚Äôt know.. I really like coding, I‚Äôm really in love with this world but I don‚Äôt know‚Ä¶ maybe front-end developing isn‚Äôt my way? Maybe I should try some back-end developing? What should I do? Thanks for your time guys.
It's totally normal to feel a bit lost after a coding bootcamp. Although this sounds very cliche, take it one step at a time.. try out different projects to boost your confidence. If front-end is tricky, don't be afraid to give back-end a shot. Explore what you enjoy in coding, and remember, it's okay not to have all the answers right away. Just enjoy the journey and be patient with yourself. That is probably the best advice I have to give.
If you want to explore backend with the lowest barrier to entry and you already know front-end Javascript, then maybe try Node.js! :>
Coding is very wide. You have infinite roads you can go, if you didn‚Äôt liked one road don‚Äôt forget is one less to choose from. Try to search more ways of building tech and start trying these different paths, maybe you find out that you like working with ML or back end or hardware. Dont just give up because you didn‚Äôt liked one path, you should be happy because you are one path closer to find out what you want

Comments from https://www.reddit.com/r/learnprogramming/comments/1dpd2i8/im_confused_on_where_to_start_and_what_to_do/:
Hi! So, I'm an incoming Junior in high school and I have always been interested in learning web development, but my issue is that I don't know where to start and I don't have any direction. I have never taken any sort of class in which I could have learned HTML5 or CSS, I just sort of scrounged the internet for quick and easy tutorials (I realize now that that was not a good idea on how to learn) which has led me to understanding only the very basics of each and just about no progress. I've looked at different resources like W3Schools or Codecademy but I'm just not sure how to turn what I know currently into something productive. So, does anyone have any advice on a reliable resource I could use to get started in web development and what I could do to improve once I finally do learn? Any help or guidance would really be appreciated. Thank you all, so much!
(Also, if this post isn't appropriate for this subreddit I apologize. I have never actually used reddit in the time I've had it and I was not allowed to make this post on r/webdev)
Just commit to one. bro code is super dope and easy to understand. Pretty sure he has a whole JS playlist.
Download apps on your phone like Sololearn just to further reinforce ideas about JS if you ever don‚Äôt feel like actually coding. W3 schools should also have practice fill in the blank problems for basic syntax (I know they did for Java)
Also I don‚Äôt know shit about coding either compared to some of these people on this sub bro, I started about 3/4 months ago and the amount of information I absorbed in that timespan has been nothing short of immense. I‚Äôm changing industries so I don‚Äôt have the luxury of learning at a leisurely pace. You 100% do have the time to do it at your leisure right now, but don‚Äôt take that as a reason to be lazy.
FAQ ---->
Generally, for webdev always the same are recommended (you should've researched the sub a bit before posting because this topic has been handled to death and back):
Free Code Camp
The Odin Project
Roadmap.sh
Choose something that fascinates and piques your interest,then try on finding the most comfortable stack for you to implement the same.Eventually there....

Comments from https://www.reddit.com/r/javahelp/comments/1bqcx0f/confused/:
Hi reddit community , i am a btech student who will enter his final year in august . I didn't know any coding and started learning java , i have a command in writing code in java but i won't get any placement with that i don't know what should i do so that i have good resume until august so that i can sit in placements with confidence. PS : i just know java and nothing else in programming i am a complete beginner
You probably need to start making good personal projects, would advise you think of something on your own, or even if you have to take inspiration from projects online but add your own features to it.
For example my first project was building an email registration system, got the idea searching online but I added something‚Äôs to it that was not in the initial project online like passwords connecting to a database storing hashed passwords all in pure Java, you can‚Äôt start from there to build your knowledge and probably check our roadmaps online roadmap.sh is a good place to start to see how your learning journey should be
You must have made some projects in Java . Haven't you?
Look into what you want to do, Look for framworks that align with that Make something Post a github link back here
In my opinion you need to find some projects on GitHub. Just see how projects are made. Learn different things like the usage of dao class, dB utility classes and all. This will give you an idea of creating your own project.
Honestly this is what I am going to do in next couple of months .
Any opinion guys?

Comments from https://www.reddit.com/r/learnprogramming/comments/17u16in/an_advise_for_a_confused_computer_science_student/:
Hello, I am a student in the fifth semester of computer science and I am very confused because I feel like I know nothing but at the same time I know things. In addition, in the projects during the semesters I have always had the role of scrum master or team director and my classmates have been the ones who develop code. I love being a scrum master ,directing projects and software architecture attracts a lot of my attention. But I have met many classmates and professors who tell me that in order to be a software architect I must first learn a lot of code and be a full stack developer and get at least 5 five years of experience in that . I really am very reluctant to code, I love administrative tasks, working with the team defining design patterns and things like that but not sitting down to type code all day. Do u know what my ideal job could be, and if I'm in this process of becoming a software architect or a software project manager, what path should I follow?
You may want to look into Project/Program Management.
There are Technical Project/Program Managers & Non-Technical Project/Program Managers.
If you wanted to be a Technical Program/Project Manager then you‚Äôll probably need technical experience.
My Experience
I work at Amazon and the Technical Program Managers are the ones who work with the software teams.
A lot of people that I know tend to work in a technical role then switch over as a Technical Program Manager
It sounds like you'd like being a product manager, project manager, or program manager. In all of those roles you're responsible for helping the team achieve its goals and deliver the features the customer wants, without actually doing the technical work. You'd be making decisions like: what features to work on, what to prioritize. You would not be making technical decisions like what database schema to use, what design pattern to use, or what the class hierarchy should look like.
If you want to be an architect or someone who makes technical decisions, you need to be a strong coder. The architect is the strongest coder on the team, period. If you want to be the architect, you need to start writing code.
You don't need great coding skills to be a manager or tpm or pm.
But what will you do if you need to try for dev positions and you're bombing the coding parts?

Comments from https://www.reddit.com/r/Notion/comments/16f03gc/coding_confusion/:
Hi, I'm new to using notion, and have created a habit tracker following a video on youtube. I'm a little confused after the coding properties I have available are not the same as the person in the videos.
I am attempting to create a progress percentage bar for my habits, and am missing the codes "Prop", which I believe to be because I have to use "+" rather than "unaryPlus", which according to Notion is the new alternative.
The code should read:
round(100 * (unaryPlus(prop("my habit name")) + unaryPlus(prop("my second habit name"))) / 2) / 100
and so on until I have included all 6 of my habits, where I would then change the 2 at the end to 6.
I don't understand code enough, even with thorough research to alter the code myself, so would appreciate some help.
You found differences between your properties and those in the video because Notion recently updated the formulas to 2.0, which means there are some differences between formatting and functionality.
Your formula should be tweaked to the new formulas, so it would be:
Once you put that into the formula, you'll see that the prop part disappears and your property "Habit 1" has a grey background.
It would be helpful if you included a screenshot of your database or quote the exact error.
Unaryplus converts things to numbers. It doesn't add

Comments from https://www.reddit.com/r/learnprogramming/comments/115emnf/confused_and_lost/:
hi everyone! I have a coding problem I was hoping someone was willing to help me solve. "Unable to init from given url (https://nakedfactoryspotlight.s3.us-east-2.wasabisys.com/settings/September" is the error I get even trying to post video or images on my site. I don't get why that started.

Comments from https://www.reddit.com/r/rust/comments/vvqubu/why_i_am_so_confused_with_rust/:
Please bear in mind I am speaking from my development experience point, not from the point of Rust rules and must do's. I didn't code in Rust before, but I understand the basics of programming, so the cool language is the one I can jump straight into the implementation without any hassle. It is called a good developer experience.
Let's look at the simple example:
str can't exist by itself, it needs to be behind a pointer. You probably want String. The decision to not have implicit type casts is just that - an intentional decision.
String is one of the most impacting changes when coming to rust.
Nowdays it's clear to me and I agree why you have &str and String. But I understand your frustration since you need to dive a bit deeper into rust in order to write and understand a simple example like this
> It is called a good developer experience
Just a general tip: I would avoid this wording in the future as it treats your opinions as a global objective definition. This does not generally make you any friends, regardless of whether people agree.
TL;DR: To answer your titular question, it's because you're not reading the error messages that Rust is giving you in an attempt to help you.
In general the Rust compiler won't just say your code is wrong, it will do it's best to walk you through why it has a problem with your code and often will suggest common fixes. It pays to actually read what it's telling you.
So it gives you 2 suggestions, let's try the first one.
Ok it didn't tell us the whole solution, but now it's giving us another suggestion, let's try following it again.
Oh come on, I followed your advice twice and you just keep finding more problems.
Actually now it's complaining about turning a u8 into a u16, it didn't mention that before and that should just work... wait a minute, I don't think this is the right fix as we want to make them u16s before multiplying them, not after. Is that what a language with implicit conversions like C++ would have done? Yep, we just avoided a subtle logic bug.
Anyway let's fix these 2 things and
Hey, the compiler helped us to fix our program.
Although there was another fix that Rust suggested at the start that we could have done, what if we try that, the Box<str> one?
Hmm type mismatch and no hints on how to fix it, damn. Well, earlier it suggested using .into() for fixing mismatched types what if we try that with name: "Rect1".into()?
And it works again, although that last step I was left mostly on my own to fix it (and to be honest, I didn't think .into() would actually work), but it lead me most of the way to that place that the solution was fairly simple. There is still room for improvement of these errors, but they are still fantastic at trying to learn how to use Rust.
so the cool language is the one I can jump straight into the implementation without any hassle. It is called a good developer experience.
No, it's called "compiler being allowed to make (likely wrong) assumptions about your code, and still have it compile". That's not good developer experience. That's what makes developers waste 70% of their time hunting bugs. Bugs that would either never happen, if compiler expected explicit code only, or would be much more easy to hunt down, because the bugs would not be hidden in the assumptions the compiler is making (or rather the assumptions you're making about those assumptions).
How often does it happen to you that you write your code, compile and it works flawlessly on the first try? In Rust that happens surprisingly often, even for 2000+ lines of code.
What is supposed to str[20] mean? 20 characters? 20 bytes? 20 codepoints? Only the 20 bytes version has size known at compile time. So why don't you use [u8;20] instead? Slice of bytes can be converted to and from str, with appropriate error handling (the size must match, must be valid UTF8, etc.) I suspect you're not used to the memory-size-related BS that is string encodings. Rust merely forces you to explicitly handle the BS. Strings in Rust are confusing, because strings at low-level are confusing.
Consider following code:
Should this compile? And if not, why not? Should the compiler deduce different stack size for, a and b? Are they the same type? If not, should b be disallowed, because the size of the type was predetermined by a? What about c ? It contains one character, just like a but has different length. What should be the type signature of these types and where are they defined (note T is not generic)? Should a, b and c be the same type? If yes, what should a=b do? They are not the same size, so how should the conversion be performed?
2. The issue is not that the compiler can't figure out that the result should be u16. The problem is, there is no obvious default for u16 = u8 * u8. Should it multiply in u8 space, wrap and then convert to u16? Should it saturate? should it convert the arguments to u16 first? What if u16 and u8 have different multiplication behavior on given platform? Should it multiply the pre-converted u16s with the same behavior as the original u8s?
If you think this is irrelevant nonsense, what should the compiler do in situation like this for user-defined types that overload multiplication, and implement conversions from one another?
If you can't answer these questions off the top of your head, and give the same answers as crushing majority of developers, then the answers are not obvious. The only thing obvious about these questions is that you should not ever need to ask them of your own volition.
I know this reply might have come off a bit more hostile, but that's not the intention. You need to be mindful of why Rust even exists - what problem was it designed to solve, that other languages fail at. The target audience are developers who face that kind of problem.
The problem is memory safety guaranteed at compile time, particularly when multi-threading is involved. This was Rust's original niche.
Why do you expect to be able to use a language you did not learn?
The idea that the compiler should know what to do with the result of adding two u8s and converting them to a u16 is a stretch. What happens if they overflow? Do you want them to wrap? That‚Äôs a common thing to do. Do you want it to automatically expand to a size that can contain the result? Those are both reasonably things to do, but are completely incompatible. The compiler won‚Äôt make assumptions like that. That‚Äôs on purpose.
Concerning 1: In my understanding, if you were able to use str instead of &str here, each instance of Rectangle would either need to contain a str of the same length or every instance of Rectangle would have a different size, making every instance a different type. This doesn't happen if you're taking only a reference to a static string stored somewhere else in memory.
Your suggestion to allow the developer to specify the length of the string might be theoretically possible, but what would you use that for, aside from protocols or database storage? Why set a certain length, even if the struct may contain strings of (potentially significant) different lengths? Also, what is the 20 in your examples? 20 bytes? Then you could simply use [u8; 20]. 20 characters? What, then, is a character? str are UTF-8, so a character may be anything in-between one and four byte long.
Rust was designed to be a safe system language by sacrifice development experience. It is opposite to the most languages that development experience will come first. Of course Rust will try to make development experience good as much as possible. If you don't have any problems with your current language it might be better to stick with it. You may not even need to use Rust for your whole life. For me I rarely use Rust because my works mostly fit with other languages.
As an average developer I expect this code runs with no issues.
I think you need to qualify this as "as an average developer who is used to managed/GC languages". These languages hide a lot of stuff behind the scene that you don't see in order to enhance ease of use.
The pitfalls is that the stuff they hide is beyond your control, and when you're writing something performance or safety critical (e.g. controls for a nuclear reactor), you sometimes need to control what those languages are hiding behind you. In these cases you'd reach for low-level languages.
Rust will not be alien at all to developers of C/C++, for example.

Comments from https://www.reddit.com/r/dalle2/comments/ugtxtf/a_photo_of_a_confused_racoon_in_computer/:
It's interesting that all keyboards I've seen so far are quite bad.
Somebody tell Dalle2 to just make a single keyboard, a simple keyboard.
Well to be fair, if I had claws and was attending a confusing programming class, my keyboard would look like that too
It looks like the keyboard is melting!
Blurry keyboard, maybe something with the way dalle renders letters? Anyway, I just love the results.
It should be a new meme template
source: https://twitter.com/17facet/status/1521044636114255872
Cute

Comments from https://www.reddit.com/r/cpp_questions/comments/yyo9l8/starting_my_coding_journey_but_confused/:
So i watched few tutorial on how to start with c++ but since I'm new to laptops and computers i don't want much to go wrong(maybe silly or just worried). So when i watched few tutorial each of them had downloaded compiler called mingw from different sites and each of them was different version. One was GitHub some vr12.2 And other from sourceforge minimalist gnu .. with vr6.0 etc. So i wanted to ask what's the right way to install mingw compiler and from where and which is the most stable version I'll be coding on vs code . Please help me a newbie .
I recommend you use Microsoft Visual Studio Community Edition. It's about as turn-key as C++ IDEs and toolchains get. You want to make a Win32 Console Application. Automatically generate a solution file for your project, do not use precompiled headers, and start with a blank project. These are all check boxes you'll see in the new project wizard. Microsoft organizes source code in a hierarchy; A solution contains projects, projects contain source code. Each project produces a thing, like a program or library, or one of the many things you'll see if you casually browse the wizard.
Since you are on windows, I recommend that you dont worry yourself with manual compiler setup(s).
Just install the full Visual Studio (not VSCode, it only shares the name and icon).
See also https://www.learncpp.com/cpp-tutorial/installing-an-integrated-development-environment-ide/
Do yourself a favor and dont use mingw
Download Visual Studio (not Visual Studio Code) and install it. Its far easier and basically plug&play
I will be honest, I think it‚Äôs great that you‚Äôre learning C++! However, as someone who‚Äôs gone to university and landed a good software engineering job, I have to say: Please don‚Äôt start out programming with C++.
It‚Äôs a complicated language that‚Äôs a bit too unforgiving and unintuitive. I‚Äôve seen far too many people start off their coding journey with C++, and like 95% of them give up because the language isn‚Äôt beginner friendly.
That‚Äôs not to say I think you‚Äôll fail - it‚Äôs just that the language discourages people from programming because of how many seemingly random rules there are.
This might be an unpopular opinion, but I truly believe it. I‚Äôd recommend starting out with Java - it‚Äôs more user friendly, there are a lot of comprehensive tutorials on it, it teaches you all the basics, and the skills WILL translate over to other languages.
Don't bother with mingw, not worth the hassle in general. If you're on Windows anyway then the most natural way to go about things is to use Microsoft's compiler as well: https://visualstudio.microsoft.com/vs/community/
That will install the IDE (Visual Studio) and the compiler (MSVC). You can use the compiler independently from the IDE and could use VS Code (different thing from just VS) as an editor but then you'd have to compile on the command line or dive into a build system like CMake directly so for a beginner like you I recommend just sticking with VS instead of VSC since the former gives you a nice little green button to just compile and run [1] and works out of the box .
Also get off Youtube and instead use https://www.learncpp.com/ , much better.
[1] You can get the same "button to compile" functionality in VSC as well. It's technically just a text editor but in practice it's like 95-99% of an IDE with some really simple steps, as opposed to something like Notepad (0% IDE) or vim (~80% IDE after 5 billion plugins and thousands of config lines).
I'll leave instructions for how to VSC below but for a beginner I recommend just going with VS, it's the least effort.
Install MSVC
Install VSC
Install CMake (or whatever else build system you use)
Install the C++ extension in VSC
Install the CMake Tools extension in VSC (or the appropriate one for your other build system)
Open the folder of your project, write the CMakeLists.txt (or other build system file) and then click "yes" or "okay" or whatever else the button is called if VSC asks you if the build system's extension should configure the project for you.
Done. Click the button in VSC to compile, for CMake Tools it's located in the bar at the bottom.

Comments from https://www.reddit.com/r/learnjavascript/comments/1efnavc/confused/:
Wow. so i have been learning javascript for about 2-3 months now. From codecademy - done learn javascript basics
freecodecamp(legacy - did the basic javascript,)
Also watched Teddy Smith break down the learn javascript as well.
I thought i had the syntax and concepts down but im legit trying to create a todo list. I have the blank html and css done(dont care for it. so its just the bones)
But man, im watching a tutorial and dont worry i dont want to follow along, im just watching but man. Its like i may as well have done nothing for the last 3 months. Im just so confused.
I dont want to be stuck watching tutorials or copy. But i even got chatgpt to write me instructions for a very basic todo list but man the javascript just feels different to what ive been learning through these curriculums?
Idk so stuck rn. I try to build it and im stuck after a few minutes.
Any ideas on where to go? I tried odin project months ago but didnt like it, maybe thatll be a good place to go to next and re-try?
It is part of the process bro , everyone feels confused at the beginning. Even pro master gigachad coders had troubling times when they first started learning coding.
If you feel like leave coding you will lose , but if you keep doing it constantly you will see you are actually getting good at it and it doesnt feel hard or confusing for you.
It is like going gym for the first time in your life , seeing all big bros muscleing around and you are there with 0 strength and 0 cardio. But when you work out consistently you will be one of these big bros.
I too suffered the same. I had done java before with some complex or u may say simple string questions( those were just mind boggling at that time). I also struggled to make a todo list as i was learning with the task. It means i had no prior knowledge. I was just googling , running the docs down. Now i have completed full stack and yeah. It takes some time but u will definitely get it. Just be calm and stay focused. Identify what is needed and how can u do that....Asking chat gpt is not a bad thing unless u are blindly following it. It is just a better google
It is a cannon event if you are not struggling means you are not learning
if you want or are looking for someone to talk to about how taking the basics of js and putting them together into a functioning program works in practice, I would be happy to help you with any questions you have or encounter along the way.
you can send me a dm/chat here and we can move to discord to discuss.
when I first started learning js in 1999, things were very different from what they are now, but the learning process has always been the same.
This is because you've just learned the concepts and haven't practiced them. From here, I want you to do two things:
For each topic you've learned, try to solve some coding problems. This will help you identify any gaps in your knowledge and boost your confidence in writing code. You can practice coding problems here.
Once you've practiced a few concepts, it's time to take it to the next level. You need to build a project, using the concepts you have learnt. I suggest going with a project that solves a problem. You can check out these 8 tips to come up with a project idea.
I know it's easy for me to say, "To get better, just go and make a project," but I understand it can feel overwhelming when you're a beginner. Check out this free course on how to go about building a project from scratch.
Keep at it. You‚Äôre meant to be confused. This is not supposed to be easy. You‚Äôre literally re wiring your brain on how to think.
Some motivation for you:
When I first started learning I couldn‚Äôt even grasp what a callback function was.
18 months later I had a fully remote job as a front end React developer on $60k pa. The first company I interviewed with offered me the job.
Concepts that seem difficult to you now will look foolishly easy later on. That‚Äôs the way it goes.
Good luck!
It's one big issue with software dev that new Devs get stuck in tutorial hell and the leap between that and semi competency without needing help is a very wide chasm.
Building a Todo list for me is significantly easier on a framework than pure JS. What part of the logic have you been struggling with?
Sounds like you're getting overwhelmed just thinking about "TODO LIST" as a concept. Think about what you want to have happen, in discrete parts. Then think about how you could make each of those happen, in discrete steps with code. Then start coding.

Comments from https://www.reddit.com/r/developersIndia/comments/1f782w2/confused_bw_dsa_and_development_coding_due_to_my/:
I am MERN Stack developer. And know electron+react native+mern.
My recent interview experience where I got call for a job of electron + python developer, which I was unable to clear round 2(technical round) due to Django which I don't know. Company employee size was 1000-5000 in linkedin which was pretty big for me.
This let me wonder my question of how to proceed forward to take a leap from 6-7lpa to 15-30lpa.
I get offers from platforms like Naukri, indeed, etc but mostly they don't see DSA skills but development skills.
I started working in a few startups and currently employed in a startup for 1.5 years.
I want to hit big but even mediocre companies/firms with employees 1000-5000 employees who call for opportunities look for development(MERN) skills. I have cracked all my interviews via development skills only but ended up on mediocre companies/startups with no job stability at all and less payment.
Go with DSA and then development strategy targeted for interview
For larger companies, especially FAANG-type organizations, DSA skills are often crucial in the interview process. However, for many mid-sized and smaller companies, practical development skills like your MERN stack expertise are more valuable. Don't be discouraged by the Django experience - it's normal for companies to list technologies you might not know. What matters is your ability to learn quickly. To make that leap to higher salaries, consider expanding your skill set gradually while also honing your existing strengths. Network aggressively, contribute to open-source projects, and don't shy away from applying to larger companies even without a BTech. Your experience can often outweigh formal education.
If you're struggling with tricky interview questions or feeling overwhelmed by the job search process, you might want to check out interviews.chat It's a tool I helped develop that can assist you in preparing for various types of tech interviews, including those focusing on both DSA and practical development skills. It generates tailored questions based on job descriptions and provides real-time suggestions during interviews, which could be particularly helpful for navigating unexpected topics like Django in your recent experience.

Comments from https://www.reddit.com/r/androiddev/comments/9fc796/android_development_is_complex_and_confusing/:
I‚Äôve been developing in Java for many years implementing commercial projects of different complexities. I‚Äôve also been easily switching to TypeScript, Shell scripting, Python when it was needed without significant efforts. Why I‚Äôm saying this is because I‚Äôve spent two months with Android and I can‚Äôt fill comfortable in it. It was a pet project and I worked on it after work or on weekends, but still I believe it should be enough, especially being experienced in Java.
When I only started there were some unusual things. First is braking all code conversions. Even on SDK level they often use improper naming, mixed cases, etc. It irritates, but that‚Äôs ok, may be they had a reason. Second thing is that it is very hard to decouple application components. In most of the cases you are required to pass a Context instance, or an Activity to an API method, or you need to extend some classes that restrict you in another way.
I desired that I could solve coupling issues via DI. Here comes the third point. After working with Spring Boot or EJB you don‚Äòt expect anything complex in DI. But Dagger 2 makes you understand that DI is not about simplicity. I spent an evening trying to inject a hello-world component into my activity. Eventually I managed to do so, but I don‚Äôt even want to think of what it‚Äôs like to declare a singleton with Dagger.
But Dagger 2 makes you understand that DI is not about simplicity. I spent an evening trying to inject a hello-world component into my activity. Eventually I managed to do so, but I don‚Äôt even want to think of what it‚Äôs like to declare a singleton with Dagger.
Which now you can get
The implementation is auto-generated with annotation processing
Now you can get singleton instance from singleton component
Fairly straightforward, although nowhere nearly as simple as @Autowired. Then again, you also don't want an Android app to start for 2 minutes while it's parsing annotations across the app at runtime/startup via reflection.
Following this path I implemented a functionally rich application (with video player, audio recording, proper permission handling, view pager, fancy UI and some other things).
Cool.
For instance, once it failed because I instantiated fragments from factory methods and all fields set in this way were set to null once I rotated a device.
Yeah, you can't do that. In fact, only no-arg constructor is guaranteed to run. And the args bundle is guaranteed to kept across process death (and config change).
I learned that whatever I have in activity view is not always accessible within a fragment that is shown in the activity. 1 from 10 tries would definitely return null. Sometimes an active fragment would return null via getActivity...
I've never had getActivity() return null before except when the Fragment was removed (or the enclosing Activity was finishing)? So that's weird. Add a isAdded() check and that should work.
When the app is minimized you would need to be careful with onPause method as there might be some unpredictable things... It continues by now.
Prefer onStop because onPause runs even if you are in multi-window mode and you click another app. Only time you want to use onPause is if you are talking about opening/releasing camera.
Why working with a completely new language is a way easier than working with Android? What was your experience? Do you enjoy developing for Android?
Android is fun, except when you realize that RelativeLayout/LinearLayout don't always work right on all devices and yet those are NOT in the Android Support Library, only literally every fucking else has its own AppCompat* variant.
So you see a device where something breaks and you need to replace whatever you wrote with ConstraintLayout, because thankfully at least that breaks reliably and on all devices if you screw things up.
Alternative answer is, "Android is fun as long as you don't need to work with elevation and shadows". Whoever designed that API was drunk. Although to be fair, a lot of APIs (including shared element transitions, for example) feel like whoever was designing the API was drunk, or at least did not consider actual real life usage. Does it work on my machine? Ok ship it
What is the proper way to start?
Eh. You learn of things from this subreddit (Retrofit, GSON, Dagger2, Glide), step on landmines, then figure out alternative ways to avoid said landmines. That's part of the reason why I'm working on this thing.
And the latest project where I defined what we do: Strictly 1 Activity, compound viewgroups only, no fragments. But to be honest, in retrospect, you really have to know wtf you're doing for a compound view setup.
Toolbar? You want that Back button to be per your design? Well tough fucking luck why don't you override the "contentInsets" because instead of Padding or Margin we added this third fucking thing to do the same thing just to screw you over and if you're not using Toolbar and did it with a FrameLayout, let's hope the notches screw us over.
TextInputLayout? You want custom color instead of colorAccent? Fuck you write your own drawable that looks exactly like what you're editing because WE DON'T GIVE YOU CUSTOMIZATION OPTIONS.
BottomNavigationView? You want to show the title text of the items and not change the size of the selected item? We actually implemented this behavior BUT THE METHOD IS PRIVATE SO USE REFLECTION FOR disableShiftMode. OH NOW CONFIGURE PROGUARD FOR IT, keep android.support.design.internal.** because everyday requirements are accessible only through reflection. Oh, now reflection is fucking disallowed because fuck you that's why. You know what it's literally just a linear layout with linear layouts in it with an image view and a text view. I can write that shit myself and I won't need reflection to get basic fucking behavior done.
Shadows? Why don't you define your view's outline with a path? Everyone knows how to read M0,0 L0,5 L5,5 L5,0 Z right? So obviously you want to hunt fucking pixels while iOS can automatically calculate the outline based on background color. OH, NOW YOU WANT THE SHADOW TO BE DRAWN? Oh sorry set clipToOutline=false, clipToPadding=false, clipChildren=false, and look it clips into ITSELF because LOL maybe you should just export the shadow as a fucking bitmap from sketch because that's the only thing that fukcing works ok?
Honestly the fun of Android Development is that you get to rewrite everything yourself because nothing ever works, and then you realize "hey I could write that myself and it works just fine, now I don't need to mess with android:elevation, fragments, loaders, sync adapters, IntentService, AsyncTask, nested NavController of nested NavGraph, and other complete nonsense that's out there just to make your life hard".
I'm slightly exaggerating but it's also kinda true.
also, writing code in Kotlin lets you write some super nice stuff
I've never thought android was easy. My manager is a programming vet with over 20 years experience and he has a hard time with it. Google seems to love to make simple things complicated. Spinners for instance.. what a pile of shit
When fragments first came out, I hated using them. They were like an extra layer of chances for something to screw up. Over the years, I've learned the pitfalls, but I guess I'm lucky that I had years to experiment and fix bugs while having a job.
From your issue, I sympathize that it can be tricky to manage fragments with FragmentTransactions and onCreate(savedInstanceState) bundles.
One recent issue I had to deal with is receiving onClick() AFTER onStop has already been called. I always thought if the onClick is happening, it must still be visible, but no. Now I have to rethink my error checking.
I can feel your pain, I've been with Android for over 5 years. Believe me, without DI, RxJava and "modern" architectures like MVP or MVVM Android used to be a terrible platform to work with. Well, it is still not perfect, there are many issues with its "open source" concept. You'll understand me when you try to optimize your app for Xiaomi, Honor, Samsung and other manufactures and, of course, for many Android's versions.
Head up, declaring a singleton in Dagger 2 is actually very easy; you just annotate the class with @Singleton annotation.
Knowing java/kotlin is only 1/3 of the problem.
You also need to have good knowledge of the Android SDK(s) 2/3 and lastly you need to understand how all this interacts with real world devices 3/3.
All this comes with experience and countless hours of frustration.
p.s Do you want to know true despair? Try working with the old camera API

Comments from https://www.reddit.com/r/learnprogramming/comments/1ekwk63/feeling_overwhelmed_and_confused_with_everything/:
Recently, I have been dedicating myself to learning to code by myself so as to make my personal projects, contribute to interesting open-source projects, etc. since this is a big passion of mine. So far, I have learned language-specific skills such as the basic syntax of Python, Java and C++ plus a bit of OOP, but not much else. Though, I have faced some problems in identifying precisely what I need to learn.
For example, I know there are lots of coding best practices and techniques to handle big codebases well, OOP-specific practices, etc. but I'm lost in what type of books, courses and other resources can be used to pick up those skills. Do I read a Software Engineering book to pick up on big codebase skills? Do I read stuff like Clean Code?
It's quite confusing to me, so I wanted a little help in that regard, as to identifying the ''main names'' I have to read books on to become a competent programmer. I know some of them such as Data Structures and Algorithms for efficient and effective design, but past that I don't know much. If possible, I wanted a list with the main 4 or 5 topics that a good programmer/SWE needs to know inside-out.
Don't spread yourself too thin. You are already doing too much.
Focus on one language and learn it well. Focus on its standards, code conventions, coding style. Learn programming. Write gradually more complex applications with the language of your choice.
Accumulating programming languages, as you do, does not make you a good programmer. Being able to solve problems with the languages you know, however, does.
A good programmer is able to analyse and dissect problems and to create step by step algorithmic solutions that then can be implemented in programming languages.
Learn programming first, focus on improving later. Yet, follow the code conventions and best practices for your language.
DSA are important, but they should be learnt after one has obtained some programming experience and best in a language agnostic way so that one can focus on the actual concepts, regardless of their implementations in programming languages.
As usual, a list of common book recommendations (from other posts):
"Think Like A Programmer" by V. Anton Spraul
"The Pragmatic Programmer" by Andrew Hunt and David Thomas
"Clean Code: A Handbook of Agile Software Craftsmanship" by "Uncle Bob" Robert C. Martin
"Structure and Interpretation of Computer Programs" (SICP) by Ableton, Sussman, Sussman
"Code: The Hidden Language of Computer Hardware and Software" by Charles Petzold
It might be beneficial to go trough some of the code in any language you are learning and going trough the source code of the libraries. Python should be quite transparent. If you use IntelliJ, you can look into Java source easily as well.
My suggestion here would be to pick a decently sized project that you would love to do... one you can get started with, have fun with and maybe don't know how to do all the pieces of.
Then as you work you will encounter questions and have blocks. We all do. This is where you do the following...
Read articles on the topic or read a book about the topic
Join a forum to ask questions (reddit, stackoverflow etc. to start) about what you read and encountered
Watch videos and tutorials about the topic. Watch a few of them with different perspectives.
I find if you follow this methodology of practice, encounter a problem, resolve the problem and then go back to practicing will teach you tons about everything and you will easily get a well rounded skillset. Not to mention that when you finish the projects, you can also toss them in a portfolio for employers later. :)

Comments from https://www.reddit.com/r/ProgrammerHumor/comments/t6shf8/coding_is_so_confusing/:
Hi! This is our community moderation bot.
If this post fits the purpose of r/ProgrammerHumor, UPVOTE this comment!!
If this post does not fit the subreddit, DOWNVOTE This comment!
If this post breaks the rules, DOWNVOTE this comment and REPORT the post!
What are you using to learn?
You fill progress circles in a counterclockwise direction?
Are you mocking me!!??
I feel attacked XD
Lmao I can relate.
What website is that?
My ADHD felt this

Comments from https://www.reddit.com/r/cprogramming/comments/1769odq/i_think_i_understand_certain_concepts_but_get/:
I started learning programming this april and I started with C. As much as i try to understand c programming, i still struggle with quite a lot of things, i don't seem to know how to write things like linked lists in codes, even though i feel like i understand it, i watch video tutorials and read books and feel like i understand but get confused when its time for execution. i dont know what to do.
Things i don't understand include file i/o, linked lists, variadic functions and some other complex concepts. I know what linked list and variadic functions are in theory.
The only solution is practice! The more code you write the easier it gets.
So, what is a linked list?
Work through some beginner tutorials (or textbook chapters, or whatever) that include regular practical exercises, and don't let yourself skip the exercises.
I think it's pretty normal to feel stuck when you jump straight from reading/watching a lesson to trying to implement something yourself from scratch. That's why lots of interactive tutorials start you off almost insultingly slowly; they're trying to guide you through the learning process one concept at a time.
You have no idea how much I appreciate your humbleness and will to learn C. So, please allow me to give you my 5 cents:
Do not give up;
Try making simple programs without focusing on specific data structures unless you really need them;
Write simple text games. It helps a lot to learn!
Happy hacking!

Comments from https://www.reddit.com/r/LaTeX/comments/9lrhpv/i_am_a_coding_newbie_and_super_confused/:
This is my first ever time even thinking about coding. I downloaded MacTex and can make the very beginnings of an article but I need it in homework format.
I found a template (document class?) that someone made and shared through github that is exactly what I need but I don‚Äôt know how to get the format onto my computer, if that even makes any sense.
My question is so basic I can‚Äôt even find an answer that makes sense on google.
So essentially, I have this link: https://tex.stackexchange.com/questions/31183/class-file-for-homework-assignments [first answer GitHub]
I want it on my computer so I can write up my thermodynamics homework. How do I do this? If you can explain it like you would to a fucking toddler I would appreciate it because BOY am I lost.
(Sorry for bad formatting, I‚Äôm on mobile and clearly know nothing about coding)
In this case, since the document class is hosted on github and not on ctan (a repository of packages that most tex distributions can download from) what you need to do is manually download the jhwhw.cls file and put it in the same folder as the .tex file you want to make. To download it go to https://gist.github.com/jhwilson/1278588 and click download zip and then extract it. Or you could literally copy-paste the text on that page into a text file and then save it with the name 'jhwhw.cls'.
After you've done that you can change the \documentclass{article} command at the top of the document to \documentclass{jhwhw}.
All that said, you could easily use the report document class, which should come by default (or otherwise would be automatically downloaded by most tex editors), instead. There isn't anything you can't do in report that you can do in the homework class you've found. Indeed the entire homework class file is something this person built off of the report class. It just comes with some extra automated commands that help you make a document with that structure a bit more easily.
Most tex editors can automatically download packages from ctan. If you find something on ctan, or something referred to by others generically, chances are you can \documentclass{documentName} or \usepackage{packageName} in your document, and it will automatically download the required packages.

Comments from https://www.reddit.com/r/C_Programming/comments/ufn3z3/confused_about_some_code_in_a_c11_book/:
A couple days ago I started reading a C for Dummies book that taught C99 code (i think, not actually certain), but used gets(). I quickly found out that C11 is the newer standard, and uses a different set of functions. Cool. However, C for Dummies taught to use "int main()" at the start of the program, and "return(0);" at the end of the program.
Reading through the book " The C Programming Language 2nd Ed by Brian W. Kernighan" I noticed the author(s) do not use those in the book. I flipped to the back and checked other pages of code, and none of them use the "int main()" or "return(0);"
Excerpt from book: https://i.imgur.com/MBjpCIa.png
This code did not work for me until I added in what was missing. I also installed MinGW 64bit with GCC/G++ v. 11.3, and all the extensions in VS Code. Here's the same thing but with those two missing parts that works for me: https://pastebin.com/77gkPTvD What gives?
Edit: i moved from a newer resource to an older one it seems. TIL am dumb; am reading C89 book not C11...
In standard C, main must be defined as:
or:
or equivalent, or some other implementation-defined form.
Now there's a few more things to say about this. First, the "or equivalent" bit means you can write char **argv instead. You can also choose other non-reserved identifiers for the parameters; you are not forced to use argc and argv.
But you're asking about:
This is not valid in C99 and above. In earlier versions of C, it would have been equivalent to:
Now you might be wondering whether this is the same as:
Yes, it does... but only because it is a function definition! Technically speaking this an "old-style" function definition, where the parameters are declared after the parentheses, e.g.:
It just so happens that with your main function that declaration list was empty.
Old style function definitions containing declaration lists are deprecated in all existing C standards, and they will be removed in the next C standard (C23). However, an empty parameter list () will still be used to indicate the function takes no arguments ‚Äî that is, it will be treated the same as the parameter list (void).
I stressed above that the empty parameter list works because you had a function definition. If instead you had a function declaration:
this does not say that the function takes no parameters. Instead, it simply says nothing about the number of parameters the function takes, and those parameters' types. This will still be the case in C23, as far as I know.
For simplicity and clarity, I recommend using (void) as the parameter list for all declarations and definitions of functions that take no parameters, even when () might technically mean the same thing.
Finally, if main has a return type of int (it may not, since you may be using an "implementation-defined form" of main), then there is an implicit return 0 at the end of the function body. This special behaviour only applies to the main function, not any other functions in your program (even if they have the same parameter list and return type as main).
C11 is almost identical to C99. There are a few changes you'll want to read about, but a book about C99 will be fine. There are very few C11 books because of this.
I've had very bad luck with "for dummies" books, as well as a lot of Sams books like the "in 24 hours" series. They're rife with bad wordings, confusing sections that try to oversimplify things, and broken code. This is unforgivable, expecting a newbie to sort through the mess of these books is just asking too much.
In older versions of C, int is assumed anywhere a type is expected, but absent. So you can say main() { and the compiler will assume that it returns int because it expected a type there and found none. This was removed in C99. The compiler will likely issue a warning for this.
As for the return statement, another assumption a C compiler makes is that the main function returns 0 if there is no return statement as the last statement in the function. You also don't need the parentheses, simply return 0; is fine and more typical.
The K&R book is okay, but if you're new to programming then you should look at C Programming: A Modern Approach by K. N. King. It's, IMO, a much better book. It's longer, but the K&R books shortness is a detriment, if you ask me. It should be the only book you need. But whether you choose to stick to the K&R book or move the K. N. King book, you should stop shopping for books and get to work. No book is perfect, no book will suit your every need, and to make progress you need to put your nose to the grindstone and get to work. Learning these things can be hard, resist the urge to switch books when it gets tough. Post your code and ask questions, try to understand why you're stuck and get past it.
Why do people keep defining multiple variables in one line, then having separate initialization for them? Why not just
Etc. What's benefit to offset repetition and more lines of code?
They were probably excluded from K&R examples for the sake of avoiding redundancy. You need a main function for your C program to work.

Comments from https://www.reddit.com/r/ChatGPT/comments/13emcfy/has_anybody_found_a_way_to_get_chatgpt_to_write/:
Either:
If you ask for a skeleton of the code, it tells you "This is a complex program and requires a substantial amount of code to fully implement, so for the sake of brevity, the code below will only demonstrate the basic structure and some key components of the program, and not every single feature."
It will attempt to write something that looks somewhat decent at first, but as you continue implementing features, it will mess up the code entirely and forget previous instructions and/or get mixed up.
Disclaimer: I have absolutely no idea how to program.
You're hitting the token limit of 4k, for GPT-3, at which point it starts forgetting the initial information. You will have to guide it better, like asking it to write specific individual functions with whatever requirements you need. You will then need to piece these functions together to create your program.
Yes. Iteratively. This is the same trick as with writing. It would really help if you knew how to program because then you could construct this using API calls and procedurally work through the problem.
Do it like this.
Outline the program functions as a plain language workflow with one action or activity per line
For each line of the workflow, translate that into a low level first pass version of the function
For each function, go over it recursively to improve it.
Now, it's never going to reach the level of proficiency of an actual programmer (currently) but it will get you a lot farther than what you're trying right now. For best results, do not give the iteration over to GPT. YOU do the iteration in GPT. As in you copy a single line from the plain language outline, wrap it up in prefix and suffix language, such as "Let's think step by step. Your role is a programming assistant" and "Output a [programming language] function that satisfies the above condition. Don't forget to write a docstring and comment the code". Something like that.
Start small and build up around it. Along the way, ask GPT to explain each line to you. If you don‚Äôt understand, ask for clarification and more examples. You need to have some understanding of programming for anything that‚Äôs not trivial. It does make mistakes (especially for larger, more complex stuff) and you need to be able to read the code and assess it for correctness.
Start with Python if you have no experience. I would recommend completing a free course (like codeacademy) that covers the absolute basics in a structured environment. GPT is definitely helpful, but it‚Äôs still a little cumbersome to get it to stick to a formal lesson plan. Don‚Äôt forget that just because AI is taking over the world doesn‚Äôt mean that other learning resources are now obsolete.
Disclaimer - I have never used GPT3.5 for programming, only GPT4. I wouldn‚Äôt recommend gpt3.5 for programming at all tbh (underwhelming to the point of being unproductive), especially for a beginner. All of the below text only applies to GPT4
You have to treat it like you‚Äôre tutoring someone. There are a lot of ways to get it to write reasonable code, but the more relevant context you can stuff into your questions, the better the code will be.
The (4k? not sure for gpt4) token context is a real limitation, but you can work around it if you‚Äôre careful to infer what it forgot, and add that info back into your context.
Essentially, you need to be able to juggle the relevant bits of your project in and out of its limited context to get it to write more complex things. Like you would if you were pair programming with an excellent junior dev that has ADHD. Your architectural/big picture experience is much more powerful and expressive, but you still need that experience to get to a certain level of complexity (for now!)
If you‚Äôre new to programming, I think doing some kind of LLM-aided analysis of large existing projects that it has good knowledge of might be helpful, in tandem with leafing through some Oreilly books on language agnostic-fundamentals and architecture.
Of course, this could all be moot in the next year or so, with the advent of larger contexts. Tighter integration with IDEs and tuning to retrieve context from vector databases will also be a substantial boon
‚ÄúPrint python code to chunk txt file folder/file.txt into 2048 token chunk txt files and output to folder/chunkN.txt‚Äù
Now you can chunk your code and feed back in all the chunks with simple copy paste without exceeding char limit.
Maybe start simple, especially if you have 0 programming knowledge. Ask chatgpt to create a html/javascript web page. You can use this prompt "Generate a single page html/javascript website for a blog".
Edit: and whenever it doesn't complete the full code prompt it saying "continue" it should continue where it left off as long as you don't try something too complex.

Comments from https://www.reddit.com/r/CodingHelp/comments/9ohvr1/confused_about_certain_code_java/:
So I was enrolled in AP Computer Science this year, and the teacher uses code HS. I decided to try to get ahead of the class and move forward, but now I am stuck. We have to take a string, called str and extract the characters from it using a for loop, and capitalize those letters. (It won't let us use the string method to upper case)
This is my code so far:
public String toUpperCase(String str)
{
String newString = "";
for (int i = str.length() -1; i <=0; i++)
{
char cha = str.charAt(i);
Try removing the spaces between toUpperCase and (char cha) and toString and (char cha)

Comments from https://www.reddit.com/r/learnjavascript/comments/1fpo4fh/confused_with_the_scattedred_online_resources/:
Hi. I'm a complete noob when it comes to programming. Currently, I have an idea for a social media website that I need to develop. Of course, I'm going to get help to develop the project but I need you guys to share me resources online so I can start my journey of learning about how to idealize the project, what to learn, and things to learn all in a proper sequence so I can learn it one by one in the right order. Do you guys know where online I can find these resources for free? Programming stuff online is scattered all over the place online especially the free online resources that why I am confused.
You've asked this before.
What you're asking for isn't trivial and you'd be best off doing a full online computer science course so you understand the fundamentals
You already asked this like 2 days ago, you‚Äôll get the same answers again. Nothing has changed since then.
Go learn the basic web technologies like HTML, CSS, and JavaScript. The Odin Project would be a good place to start. Now go actually START instead of worrying how to start.
EDIT just checked OPs post history‚Ä¶all he does is go around asking this question lol
How would you figure out what the ‚Äúproper sequence‚Äù is? How would you know if a sequence is ‚Äúproper‚Äù or not?
Boot.dev and scrimba are ordered one for backend and one front end... or front-end masters. Check through that

Comments from https://www.reddit.com/r/learnprogramming/comments/1c0rfez/i_am_really_confused_about_my_programming_language/:
I first started programming a few weeks ago and I started with python, it was really easy and i learned a bit of the basics(for loops, making a calculator.) I switched to c++ and I keep seeing advice to stop learning.
Could you give me any ideas for a programming language?
How about Python? Or C++? Why not stick with one of those?
I keep seeing advice to stop learning.
Do you mean the White House BS that's currently going through all media?
No matter what: don't listen to those naysayers.
Yet, the question is: why did you switch from Python to C++? Any particular reason?
You should really stick to one language in the beginning and learn it well, plus, you need to learn programming, not only programming languages.
You need to practice, practice, practice, and practice more.
You‚Äôre bouncing around too much without building anything.
You mention Python and then C++ and wanting to do web dev next which might introduce anther language.
Try and make something real. The language does not matter. The thing matters.
It depends on what you are interested in within the development world.
Python is used a lot for data science, machine learning, and backend development. Python is higher level, meaning most of the actual implementations are abstracted away into classes or functions (or even modules). It‚Äôs a great way to get started in program and worry more about the logic and flow of your algorithm, rather than memory management and other lower level complications. Most of the heavy lifting in Python is already done for you so you‚Äôll find an excellent selection of libraries and modules that you can pretty much do whatever you want with it.
C++ on the other hand is your lower level general purpose language used for building applications, OS, and used widely within the embedded systems area. This language is older but still very widely used and taught at university (so is Python). In c++ you‚Äôll be challenged with understanding lower level complications such as but not limited to memory management and pointers. C++ is my favorite language as it not only allows me to get close to the metal, but also provides me with a great libraries for deep abstraction and algorithmic heavy programming. Example: I‚Äôve recently used C++ to implement a Topological sort using DFS on a DAG. The code was beautiful and was completely done with no pointers ( not using the lower level features).
Again, the choice is ultimately up to you and where your interests lie. I started learning programming in C++ back in 2017 and haven‚Äôt looked back. I know a great amount of Python but I agree with you when you say ‚ÄúI feel like I‚Äôm not doing anything‚Äù because comparing it to a language such as c++ where it‚Äôs common to just build it yourself rather than importing a module. Both are great options, both have there own advantages and disadvantages but learning one over the other doesn‚Äôt mean much since you can always learn the one after you learn the other. Good luck!
Stay with Python for awhile. Learn advanced problem solving, all-things-functions (including lambda functions), OOP, some libraries like numpy or pandas (if you‚Äôre into data science). THEN start c++. C++ has many of the same concepts while introducing many new ones like pointers and low level memory management.
Why did you switch?
Do you know what you are hoping to accomplish with programming? ML/AI, embedded systems, websites, game programming, etc. If you have an idea, let this guide you to the language that best fits what you want to do.
Edit to fix typo.
Why are you being told to stop learning?

Comments from https://www.reddit.com/r/computerscience/comments/pr5s8k/many_confuse_computer_science_with_coding/:
I hear lots of people think that Computer Science contains the field of, say, web development. I believe everything related to scripting, HTML, industry-related coding practices etcetera should have their own term, independent from "Computer Science."
Computer Science, by default, is the mathematical study of computation. The tools used in the industry derive from it.
To me, industry-related coding labeled as 'Computer Science' is like, say, labeling nursing as 'medicine.'
What do you think? I may be wrong in the real meaning "Computer Science" bears. Let me know your thoughts!
‚ÄòComputer Science is to computers what Astronomy is to telescopes.‚Äú -Edsger Dijkstra
I think you are half-right. The bit you‚Äôve got wrong is to assert that CS is ‚Äúthe mathematical study of computation‚Äù. that‚Äôs absolutely a core field within CS, but phrasing it as you do excludes a whole range of other legitimate CS sub-fields.
Also I guess you meant ‚Äúnursing‚Äù not ‚Äúnursery‚Äù
Much more people confuse CS with printer and router maintenance. Especially my relatives.
But nursing is also medicine. I completely see your point but at the same time, you need practical examples to learn concepts anyway. And the examples might as well be often used ones in real life. Also I don‚Äôt think it‚Äôs just computation. I took a lot of networking classes in my masters cs.
Oh oh, we had comments like this. Be aware that people will accuse you of gatekeeping.
We have a term for industrial coding: software engineering. It's a subset of computer science, though. The takeaway should be, that software engineering is not equivalent to computer science, much like physics and engineering.
What you're thinking of is called Theoretical Computer Science. It's a subset of Computer Science, but not all there is to it. The field of Computer Science is pretty wide.
It's true that Computer Science is not just programming. But the opposite is also true. Computer Science is not just theory.
I agree. Code is just a tool for cs.

Comments from https://www.reddit.com/r/learnpython/comments/m9b2qz/for_loops_are_confusing/:
my teacher taught it to us and in theory it made sense but the second he gives us homework on it i can never apply it. i haven‚Äôt been able to do a single one without the help of someone else. can someone try and help me figure out a way to apply my knowledge in practice?
What exactly is the issue you are having??
For loops is one of those concepts that are so simple for people who understand it yet so confusing for many beginners. This can sometimes make it tricky to teach since the teacher will explain it in a way that makes it sound simpler than it is.
The only way to learn it properly is by doing problems that are very simple and then slowly increasing the complexity.
For example:
Write a program that will print "Hello" 5 times each on a new line.
Write a program similar to the one above, but will print the line number as well.
"Hello 1"
"Hello 2"
"Hello 3"
Do the same as the previous but in reverse. Start with "Hello 5" and end at "Hello 1"
Overall, there is a lot to learn about the way the index of the loop can change. Then after that is the difference between looping through an array directly and looping through indexes.
If you're still having trouble after the explanations offered here, let me know, maybe I'll be able to help out!
You do them in real life all of the time you just don't realise it.
You are baking a cake. The instructions say to stir 4 times or stir while the mix is still runny. That's a for loop or a while loop, respectively. The computer is dumb compared to you and needs to be told explicitly what to do for each repetition. Perhaps you had to add three eggs and you followed the same steps for each egg.
Another example. You are sorting out your recycling. For each can in your stack of cans you put the can in the can squasher, squash it, remove the can from the squasher and put it in the recycling bin.

Comments from https://www.reddit.com/r/learnprogramming/comments/1cxi4qy/confused_about_pointers_in_c/:
so when we create a pointer *A and print out A only then we get the address memory that *A points to. so i assumed here that the address *B points to would just be filled with A address, but instead *B start pointing to the same array *A points to. which i thought should be done with B=A not *B=A.
so im confused here.
 int main() {
int *A = new int[5];
for (int i = 0; i < 5; ++i)
  A[i] = i;
int *B = A;
cout << "A value is:" << A <<endl; // A value is : 0x301560
A pointer is a kind of value (in particular, a value that represents a memory address), and variables store values.
The * character means different things depending on where you use it. In a variable declaration, it just modifies the variable's type to mean "this is a pointer type". So in int *B = A, the * just causes B to be declared as a "pointer-to-int" variable instead of an "int" variable.
This is separate from the way * is used in expressions to "dereference" a pointer, i.e. access the value at whatever memory address the pointer points to. In other words, int *B = A; and *B = A; mean two entirely different things, despite how similar they look.
so when we create a pointer *A and print out A only then we get the address memory that *A points to
I think you need to be more careful with your terminology. A is a pointer value, so the value of A is a memory address. The value of *A is not a pointer, so *A doesn't point to anything. As an expression, *A means "whatever value is stored in the memory address that A points to. So *A is an integer, not a pointer.
so i assumed here that the address *B points to would just be filled with A address
Same issue here. B is a pointer, and *B indicates the value it points to.
You initialized the value of B to be equal to the value in A, and since A and B are both variables containing pointer values, they both contain the same memory address and they both point to the same place.
*B=A
You're mixing up the dereference operator with the declaration of an int* variable. If you want the first element of A, you want
Great question. First, let's talk about what an array is in C and C++. An array is just several values of the same size in a row. The first value will be at address X. The second value will be at address X+(however big the type is). The third value will be at address X+2*(however big the type is).
So, we have A. It's a pointer to an integer, that integer being the first member of the array. That is to say, these two lines are the same:
Now, you have this line:
I think you're thinking that this means that B will point to A, but that's not what is happening. B's type is "pointer to integer," not "pointer to pointer to integer." You're copying A's value (the address of the first element of the array) into B, so that A and B are two distinct variables with the same value. I think you think you were writing this line:
You might want to delete your pointers at the end to avoid memory leaks. Using plain pointers is also considered bad practice in C++, so please do this kind of stuff only for learning purposes - in actual projects you should rather use std::vector and wrap your pointers in std::unique_ptr or std::shared_ptr, depending on what is needed.
Two separate things:
A[i] is just syntax sugar for *(A + i). A in this case decays into a pointer. A pointer is a derived type. It doesn't simply store a memory address, but it gives information of the given type of the object that is pointing to. In this case, A points to an int. That is relevant because when we add i to A, it won't be A + i bytes. It is A + i * sizeof(int) bytes. (A + i) essentially adds an offset of i "int sizes"; or the space that i ints occupy. That's why *(A + i) is equivalent to A[i]. With that in mind assigning the pointer B to the pointer A is the same as having two pointers to A + 0 or A[0]. Then when you do the loop on B[i], you are accessing the values at (B + i). And since B and A point to the same address, (B + i) is equivalent to (A + i). Therefore B[i] is equal to A[i] access the same values.
The asterisk has a special meaning when it is in a variable declaration. I said a pointer is a derived type. Deriving means basically coming from something and modifying it. When in a declaration, the asterisk is doing just that: deriving the type. Similar to how [] derive the type to be an array, or () turn the declaration into a function. The other use of the asterisk you're more familiar with is that of an operator:
The unary * operator denotes indirection, and returns the object or function to which its operand points. It is an lvalue if the operand is a pointer to an object of arithmetic, structure, union, or pointer type. If the type of the expression is "pointer to T," the type of the result is T.
So if (A + i) is a pointer to int, the type of *(A + i) is int.
To give an example, the following two blocks of code are equivalent:
and if A is an array of int, both *B and *A would be the integer value of the first element in that array.
If you ever get time, learn the basics of Rust. You'll never forget how pointers work and how to properly use them again after that.

Comments from https://www.reddit.com/r/learnprogramming/comments/dkliz6/cs_student_confused_with_web_development/:
Hello,
I'm a CS major currently in my fourth year, I was used to programming in C++ and C# which was going perfectly fine! My productivity was awesome, I created projects, solved assignments without any issues, since you have a main function and everything gets called off of that function, I knnew how the control flows through a program.
In the web world stuff is a bit more "messy", JavaScript for example doesn't have a main function, so sometimes I have no idea how the control flows in a JS program. Even CSS is a messy language in itself.
How should I approach web development? I am currently learning through FreeCodeCamp, and earned a scholarship for a Udacity Nanodegree which I am also studying.
Your opinions, ideas, and help is greatly appreciated!
You'll find that the more you branch out from console-based applications, the less you can expect a simple main entry-point. Android applications, for instance, can have multiple different "entry points" (Activities) that could be started independently from each other.
CSS isn't what I'd personally call messy; just annoying. But it's a requirement for any kind of front-end development, so it's worth just buckling down and learning how to use enough of it to get the job done. You don't have to become a design wizard if you don't want; there are things like Bootstrap that give you a leg up in that area.
JS execution is simpler than you think. It starts at the top of the first loaded JS file and goes down from there. You can imagine a big main() function wrapping the entire file. Declarations like functions aren't executed, they're declared. So, if you see a file like this:
The flow is
declare that a function called doAThing exists and what it does when called.
call doAThing()
Events on the other hand, can be a bit confusing until you're used to event-driven programming. But the gist of it is, you set up handlers, bind them to events, then they become pseudo-entry points for your code to start when some event happens.
For frontend Javascript, a good way of imagining it is that code is always executed in response to some form of input or action. A JS project really just boils down to snippets of code to be executed when the user clicks on a button, scrolls somewhere on the page, or even just loading the page. You can also use it to manipulate HTML with a logical model called the Document Object Model (DOM). CSS doesn't really work in the same way as you'd only really use for stylistic reasons rather than having it perform any sort of logic.
If your background is in C#, I recommend trying out TypeScript... which is JavaScript with a very close syntax to Java and C#.
That's because JavaScript code is basically one giant main function. There is no such thing as a function that takes precedence over all of the other functions.
You're thinking about programming sequentially rather than programming in response to input. Generally, when you write code in an OOP language you have a sandbox where you write out all the things then you tell me what order things should come in.
When JavaScript is processed,it's performed stepwise. This means that global code is treated just like function code. Therefore, most of the code you write in JavaScript is written to be executed in response to something not written to be executed at a specific time. A good reason for this is that sometimes the DOM (the tree hierarchy that creates all the things you see on a web page) may load out of order, or be manipulated by some other code to change what is loaded completely.
Imagine you have a web page that pulls restaurants from Google Maps.
The user must enter input (Japanese, Vietnamese, Thai, Korean food) On successfully hitting search with valid inputs, it grabs all the venues nearby. The results will be displayed in a table.
How do you know how many cells to draw on the page without knowing what kind of food they want? What if there are 20 Japanese restaurants and 100 Korean restaurants? How do you know how many rows to draw?
You don't. That's partially why JavaScript is step-wise; the construction of the DOM (document object model, or the structure that contains all the elements of the page) usually relies on user input.
Otherwise, you get very static, Geocities esque pages that don't do anything with respect to user input.
I don't know if I wrote this too confusing, but I wanted to try to use a real world example that I personally ran into. Here's an SO post that gets into the technical nitty gritty:
https://stackoverflow.com/questions/9015836/why-doesnt-javascript-need-a-main-function
For vanillaJS, use the body tag‚Äôs onload event handler as your entry point. It‚Äôs timed well to execute when the page is ready enough.
For individual frameworks, each works a bit differently in terms of their preferred entry points since they generally do a little processing on their own and then let you take over somehow.
Do not use sequential processing since the sequence can be easily gummed up and it doesn‚Äôt account for page loading.
Try eloquentjavascript its a free book with great analogies and had chapter for web as well
How did you earn a scholarship from udacity? I'm from a third-world country in economics crisis, do you think I could get one ?
As opposed to libraries, a framework follows a "don't call us, we'll call you" approach. You write a bunch of functions and then call some run() or main() function in the framework, and the frameworks calls your functions as needed. JavaScript can work similarly with its callbacks: you assign functions to be called in response to certain events (like onclick() or such). After that function returns, the framework pauses until some other event happens.
I was in the same position. I am fine with C,C#,Java and Haskell, but I struggled with Javascript. For some reason, it didn't stick as fast as my learning experience with other programming language.
I guess you just have to use it a lot.
The main thing is to think in terms of events. The browser itself does all the hard work for you of listening for events and updating the page so you mostly need to just tell it what to do on the events you care about.
Beyond that web programming is just getting familiar with the built in tools you are given. There are loads of html tags for all sorts of content, and loads of css properties for all sorts of styles. And you can change any of them at will by listening for whatever event you want and then updating whatever element or style or data you want, however you want.
Check out MDN regarding addEventListener() for more info :)

Comments from https://www.reddit.com/r/learnprogramming/comments/wpfut0/i_must_be_confused_what_is_an_api/:
I've been programming for a couple years and I even have a job doing web dev. That said there's something I never really understood: What exactly is an API?
I was under the impression that it was a "website" with endpoints that serve JSON instead of HTML. Basically a website to be consumed by another application.
I've also heard it refer to libraries their functions/methods. I've also heard it refer to a language and the underlying implementation of it's methods.
Is it all of the above? redhat.com defines API as: "APIs let your product or service communicate with other products and services without having to know how they‚Äôre implemented."
So that sounds like it's describing a RESTful HTTP API. But the same basic principle also applies to the internal implementation of a library or even that of a programming language too.
Are they all different kinds of APIs? They serve the same essential purpose, to abstract away internal implementation, but that's also pretty much... everything in programming?
The key word is interface.
The buttons on a TV remote make up an interface.
The mouse and keyboard on your computer are an interface.
You don't necessarily know or care how the underlying circuitry or digital communication protocols work, but you know how to use the buttons.
A server hosting a REST API only exposes the endpoints, not the underlying code that backs them. Similar to a TV remote hiding its underlying circuitry.
API qualifies "interface" with "application programmer". So it refers to interfaces that programmers use. The simplest way to think about it is literally an interface definition, where you don't care what the implementing classes may be doing under the hood, but your knowledge of the superficial interface is at least required in order to use the library..
A REST API isn't much different, it's just remote. Imagine the endpoints as if they're remote functions you're able to call. Same general idea in the abstract.
The Term API is purposely vague or ambiguous, by itself.
An API, such as REST maybe available on a Server for which you want to retrieve some information. If you're familiar with Python, for example, you need not be familiar with the Database and resources from the site holding the information you want.
You can simply connect to the REST service via some call/library from Python and request the data in the form of JSON or XML for instance. You only need a way to access the service via the language you're programming in. A Stored procedure is not likely an API, but rather the commands there in could access an API, such as Twitter to gather user information.
APIs can be services, libraries, or any piece of code that defines how to share data via a given technology. By the way, an api may include rules for the types of requests to be made and whether a socket needs to be opened. (Some of this is hidden or obscured in higher level languages)
Hope this helps clear up the definition a bit.
You can have an API to your application as a stored procedure.
An API is an interface on how you interact with the application.
An application can be written in many many many different ways all different and special but APIs none the less.
The term seems wayyyy too broad and it has been the single biggest source of confusion for me in learning. Am I mistaken? I imagine I have to be wrong somewhere in here because the term API seems practically meaningless to me.
You're absolutely correct, 'API' can be used to mean virtually any encapsulation or information-hiding. An object with getters and setters could be called an API. The term was invented long before the internet, and even then they felt it was too broad, and could even apply to hardware.
But when people say 'API' today, in the vast majority of cases they're talking about Web APIs using endpoints, exactly like you described.
API = Application Programming Interface.
It's very very broad. Any interface between two pieces of code, could be in two different files of the same project, two applications on the same machine, or over the internet to another system. API is the term that describes that interface between the two.
its' the interface, to eg. a box of private data. You dunno how the car works inside, but you know the wheel, doors etc.
Does the term "controller" seem meaningless to you?
TV controller, A/C controller, RC Car controller, PS4 controller, XBox controller.
API is just a fancy word for "controllers that a programmer uses for stuff" and "stuff" can be anything a programmer uses.
Am I sending a request to a server? Well, I could write my own code to send data over tcp, then write my own http logic, then encryption with tls, then I could send raw data in some arbitrary format to the server.
Or I could use the standard library's https API to manage https, and the server could offer me a REST API with a set definition that I can use to make things easier.
My server could use the stored procedure API of the SQL database to give me simple ways to manage data, and it might use a backend framework that has an easy to use API to simplify my work.
If I write a small module with a couple of public functions, coworkers working on the project who use those functions might ask me about the API of that module (referring to the functions and their signatures).
API is basically anything that is abstracted away from a programmer.
A single function by itself could also be referred to as an API depending on the scale and scope of what it does.

Comments from https://www.reddit.com/r/cs50/comments/1dxbl14/confused_about_a_couple_of_things/:
Hey y'all, this my first post in like ever, so I started doing the CS50x (on lecture number 2)course from youtube. Now I know that you can do it for free if you don't want the certificate at the end. But i still have some doubts:
During the lectures he never mentions anything about the problem sets, but I keep hearing about the problem sets, so are we supposed to do that as well? and if so where do i get those from? and if i solve those, am i supposed to submit them. and if i did, who would grade it?
2.I already know a bit about coding and computer science in general, so I don't think it's helping me as much as it would have if i didn't know anything, should I continue the course?
Hello, start here for most of your answers.
https://cs50.harvard.edu/x/2024/
I can't really answer your second question because I don't know what experience you have.
Yes you have to solve problem sets, it's not compulsory but what is the point of the course if you are not applying it. In Problem sets you apply the knowledge you gained from lectures, even there are few extra things in psets which you will only know once you solve them...and yes you need to submit it in end all instructions are given. Also you will only get the free certificate when you solve all the problem sets and the final project. It is automatically graded, the site checks whether the code is running and checks few more things...And don't watch it directly from YouTube, open EDX, search of cs50x introduction to computer science and enroll in it and then follow the instructions, in edx everything is organised so easy to navigate.
Only lectures will not make any difference, solve problem sets and then notice the difference, so yes you should continue.
well, you do get the certificates for free from harvard the one provided by edX is paid since its verified (but harvard one is verified asw)
Give up

Comments from https://www.reddit.com/r/learnjava/comments/1bqmepl/im_confused_on_how_i_should_roadmap_learning/:
I‚Äôm a sophomore in high school and have been coding for about 5 years now and i‚Äôve primarily did HTML/CSS, though in my time learning HTML/CSS i never could advance further than mediocre code and never became aware of having to use javascript. Fast forward to last year, my freshman year, i learned about the CS class at my high school and i took it. It was just java programing and i peaked interest in java and that‚Äôs what i‚Äôve been trying to learn since. We were given a book to work off of called ‚ÄúBuilding Java Programs 3rd Edition‚Äù and it has helped, but at the same time i can‚Äôt really understand it all too well. I had finished up to chapter 4, where i am now able to do System.out.println(), for loops, while loops , scanner, and strings. Though for all of these i am n it able to do them on a higher level than basics. I need more practice although i don‚Äôt know where to begin, i‚Äôve tried continuing with the book but it‚Äôs kept confusing me. i‚Äôve also tried project based programming, though quickly figured out that i‚Äôm not capable of that yet with my skill level. I‚Äôm someone that works best in a guided but also am able to learn myself as long as i have something like a website to give me practice. How should i go about this? I would also like to understand a proper road map so i know where i‚Äôm going, and resources to accommodate.
Hackerrank.com or leetcode.com are what you need to practice.
Focus on solving small problems with ArrayList, String, loops and HashMap. That covers 90% of what‚Äôs used by a professional on a daily basis.
Learn selection sort and binary search.
Learn how to solve small problems with stacks and queues.
Then move on to recursion, trees, linked lists.
Learn breadth first search and depths first search.
Forget about object oriented programming until you can solve problems without it.
Move on to SQL, relational databases, NoSQL databases.
Learn how to make HTTP requests and how to serialize and deserialize JSON
Not sure what you mean by a proper roadmap. If you‚Äôre just trying to get through your AP CS class you don‚Äôt need the leetcode stuff. That is entirely irrelevant at your age. If you just want to pass your class, you could learn from any textbook or from the official Java tutorials.
If you‚Äôre planning to become a professional programmer, I‚Äôd suggest you still do the same as above but then start to learn a web based framework. It doesn‚Äôt matter what you want to learn but if you want to continue programming in Java then you would learn Spring.
You could also learn JSP/JSF if you‚Äôre interested in learning how legacy web based applications were built. I don‚Äôt know how relevant that would be for you when you get into the workforce but I am a professional Java developer, so it is relevant to me because I work on both.
For loop in hell, code joke, think of your own project and code it in java, use the internet it's your friend for solving problems, btw you don't need to think of an new idea no one has ever done before, you just need to think about an idea that interest you it could be a game or a tool, that's the best way to learn over any boring book
It seems that you are looking for resources for learning Java.
In our sidebar ("About" on mobile), we have a section "Free Tutorials" where we list the most commonly recommended courses.
To make it easier for you, the recommendations are posted right here:
MOOC Java Programming from the University of Helsinki
Java for Complete Beginners
accompanying site CaveOfProgramming
Derek Banas' Java Playlist
accompanying site NewThinkTank
Hyperskill is a fairly new resource from Jetbrains (the maker of IntelliJ)
Also, don't forget to look at:
The official Documentation
The official Java Tutorials
Our community resources thread
If you are looking for learning resources for Data Structures and Algorithms, look into:
"Algorithms" by Robert Sedgewick and Kevin Wayne - Princeton University
Coursera course:
Part I
Part II
Coursebook
Algorithms 4th Edition
Your post remains visible. There is nothing you need to do.
I am a bot and this message was triggered by keywords like "learn", "learning", "course" in the title of your post.
I am a bot, and this action was performed automatically. Please contact the moderators of this subreddit if you have any questions or concerns.

Comments from https://www.reddit.com/r/HomeworkHelp/comments/10r3s2x/computer_programming_pretty_confused_what_to_do/:
To begin, You need an if statement that determines whether the click was in the purple or not. Use the hint.
What should the value be?
What was it I need it

Comments from https://www.reddit.com/r/learnprogramming/comments/1etyvg3/its_normal_to_feel_so_confused_at_the_beginning/:
I tried to see if the FAQ could help me, but I don't feel that is enough to answer my doubts, so I wrote this:
Before anything I now that's normal to struggle at the start, but I can't see me making any progress and being able to solve things in my own, my problem-solving skills are pretty low right now.
I'm doing the CS50 course and I'm on week 2 and it feels incredible hard, I just can't understand anything and it feels like I can't write anything or get solutions in my own. In the week 1 I was so lost that I need to look for a tutorial to understand how to do it, I tried to understand how it works (I think I got it) but deep down I know that I can't replicate the code in my own.
So here we are in week 2, I tried to do the first exercise and I didn't understand anything, I had to look at the pseudocode to know how to start, I did the easiest part and the next part I didn't have any idea, so I give up and looked for the answer, and then because my block of time for this day has ended I let it there.
Yes, it's normal.
Yes, it is hard.
But if you view the solution you're never going to learn. You have to not give up. Figure out every exercise yourself, whether it takes you a minute, an hour, a day, or a week.
The exercises build on each other. Next week's exercises aren't solvable unless you thoroughly understand this week's.
You need to get the idea out of your head that struggling to solve a problem is "a waste of time". It's not a waste of time, it's learning. There's no deadline. It takes as long as it takes. If you try to "skip ahead" now without understanding it, that will just make it ultimately take longer.
Every dead-end, every wrong turn - that's part of learning. Over time you'll hit less of those, and you'll get through them faster. You will always hit them, but they won't bother you.
So slow down, relax, and keep working until you figure it out.
There are communities online where people can help. This is one of them! But cs50 actually has a bunch of others, look them up. You can message or chat with other people taking cs50 right now.
What you want to do is explain as clearly as possible what the problem is, what you've come up with so far, and where you're stuck.
Again, there's no rush. Take your time to ask a good question - like you did here.
Ask for a hint, an idea of what to try next - not the answer.
We can try it right now if you want! Post the most recent problem you're stuck on, and let's go through it now.
Yep. Get your wisdom from a variety of places until you understand how you learn best: then stick with people who teach that way.
Of course! It's like learning math: you have to try to solve problems but you also have to see how other people work out problems. It's like learning art: you can practice painting or drawing a landscape scene, and you could probably figure out your own way, but DaVinci, Van Gogh, and a paleolithic cave artist would likely do it differently, and you might want to see how different artists have gone about it.
Just memorizing the syntax and standard library of a programming language is not normally enough to actually code. Even back in the days of paper textbooks, there were usually pseudo-code examples, real-code examples, and ideas to try to do on your own based on what the lesson was about.
If there's an example or tutorial for what you want to do, pay attention to the reasoning behind each feature that's being used to solve the task, and think about other things you could try with those features. If you still get confused, try something simpler or try breaking your task into smaller parts that you feel more confident implementing. Keep experimenting and getting whatever kind of help is available until something works. Programming is still an exercise in creativity, but after decades of people doing it, there are lots of opportunities to learn from what others have done.
But a word of advice, though, if you're in a class, academic honesty matters. Just copying someone else's code will probably not be okay, ESPECIALLY if you don't cite your source. But still, it's usually okay to do outside research to see how some tool or technique works in general. I spent quite some time in the library when I was taking my programming courses. Even books about different languages sometimes gave me ideas or insights to move forward.

Comments from https://www.reddit.com/r/OpenUniversity/comments/1de0jpl/confused_about_the_future_computer_science/:
Everyone is talking about AI but it can only be as good as the data that trained it and using sources like Stack Overflow and Reddit is not the way to train programming AI. The AI model does not know the difference between what answer works and what is totally wrong, what code is vulnerable to attack and what is not, etc. The ZipSlip vulnerability was as a result of a Stack Overflow post with code that would unzip a compressed file and had been used in MANY popular tools and libraries, but it did not check file permissions and could be coerced into overwriting protected files on a filesystem to allow a user to gain access to the machine. It was being used for at least 7 years before it was discovered. As more AI writes code and answers Stack Overflow questions, the models will gradually skew towards AI generated code using AI generated code and you will get a feedback loop which is never good. Programmers will still be needed just to make sure AI produces good code, and programmers hate working with other people's code.
Code written by AI can work, but unlike the memes programming is not just about cut and paste from Stack Overflow. It won't be the most efficient code out there and it won't innovate with new approaches and solutions. Something that is also not talked about is IP rights, if ChatGPT codes your application and you make millions from selling it, is it really yours or does it belong to OpenAI, or even someone further down the chain? Some companies have already banned the use of ChatGPT etc. by their developers.
Finally, OU does an AI module. I did not enjoy it, but it does exist. If everything goes to AI, who is going to develop the models that AI will use to code? The thing to remember about AI is, although it is good, at the end of the day it is only assessing a probability that what it has is correct, it cannot definitively know it is 100% correct.
Personally, I think there is a lot of hype about this new technology, because the press like to get hold of these things and exaggerate and techies love new tech. It could as easily go the way of a lot of "next best things" in technology and in 5 years time we will realise it cannot replace the programmers. Back in the 80s fourth generation languages were going to allow business analysts to write code in plain English, it never happened, I think AI could go the same way.
im a software engineer myself, worked in ai, have a bachelors in mathematics.
buisness folks and the like have been trying to get rid of software engineers ever since software engineering began. first it started with natural language programming, then it became WYSIWYGs editors and RAD tools, then graphical programming languages.... All have failed to replace software engineers because of one thing, no matter how "smart" the computer is, you still have to have a guy who tells the computer how to do every specific item.. you still have to have a guy, who invents and describes every specific process that gets the customer what they want.
even if AI could "program" for us, they would still become nothing more than glorified compilers. no matter how the AI works you're still gonna have to transfer your idea for a program from you to the AI through some kind of medium.
Ask the professionals in the industry you want to go into. They are best placed to say which degrees are best and if they are required at all.
For context, I have a PhD in computer science and teach at a university-level. My area of expertise and research is applied and theoretical artificial intelligence.
Predicting the future is incredibly difficult. The automatic telephone exchange eliminated the position of switchboard operator completely. It did create new jobs for people to build and maintain those systems, but those new jobs did not go to former switchboard operators who needed to find entirely new work. Other technologies, simply create shifts in the kind of work being done. If AI-based code generators can easily create the backend for login webpages, then chances are there will be no need. but perhaps they will struggle with the UI/UX aspect of web design. In which case, there will be a shift towards UI/UX. In this case, the underlying skill set is similar enough that not that much retraining is required, i.e., the jobs could go to the people that used to build the backend and were wise enough to learn about other aspects of their jobs. My own assessment of AI-based code generators is they are not very good at solving problems and only good at writing code for designs that are already very well-known. E.g., a login page, sorting, etc. Also, the code generally needs to be fairly narrowly defined. It also sometimes has bugs. Plus, AI-code generators are notoriously bad at maintenance.
So, to me then, the job/skillset that is not likely going away is the analyst who can define what code is required to complete a project. I can see an analyst who does bug fixing. refine, and maintain AI-generated code definitely being a thing. Plus, of course, there will be a need for developers to make more complex code.
All of that being said, there are probably a lot of developers who do not have the necessary skill set or aptitudes and will go the way of the switchboard operator. But it seems unlikely that this is the death knell for human-based software development.
Just my thoughts. There is a high probability I'm wrong because predicting the future is very difficult (you said that already). I know but it is important enough to say it again (ahhh).
I'm not a developer but I believe it's more supplementary, they will still need people to operate the LLM's.
AGI isn't quite here yet.
There's lots of noise about AI, don't get scared and carry on studying. Just yesterday I was using ChatGPT to generate some tests for the code I wrote. I then spent 4h troubleshooting the darn thing because it kept failing. We are really really far from AI taking over. Also, programming is just a small fraction of what the sector does.

Comments from https://www.reddit.com/r/learnprogramming/comments/tx1avi/functions_make_it_more_confusing_for_me/:
I've recently been devling into functions and they absolutely confuse me. The structure of a modular program makes it harder for me to understand. I get how a function works. But the structure of a modular program is more confusing to me than a non structured program. I realize that some programs will have thousands and thousands of lines of code and the most I've written is about 200. But for some reason i struggle to see how functions make a program easier to write. Calling a function in one part of the code and then having the actual code somewhere else in the file confuses me. Is this just me?
Edit: thank you to everyone who commented. Its helped out immensely.
Most people find new concepts confusing, so it's not a surprise or uncommon.
But it is important to push past that and learn to understand them. Functions are an absolutely core principle of programming. Almost every program you will ever work on once you move past this stage will involve writing your own functions. Practically every program you ever write uses functions (built-in or from libraries).
So, it's understandable and normal to feel confusion, but don't let that confusion be an excuse to skip learning functions.
Edit:
But for some reason i struggle to see how functions make a program easier to write
What if, every single time you needed to print output to the console, you had to write all the code involved. Setting up the stream, converting your strings into bytes and writing them to the output buffer? Wouldn't it be easier to just use a function? Well, of course it is; that's why most languages have at least one built-in function for doing that with a simple single call.
The idea is to put re-usable logic in self-contained callable code. Yes, the actual code is "somewhere else", but it's only in one place, instead of repeated everywhere it needs to be used in your program.
What if you had some repeated task you just copy/pasted all over your code, and later you discover you need to change it, or add some corner-case handling to it? If you had made a function, you could just change the code in the function and be done. But if you didn't, now you have to search your code for every single place you used that logic, and update every one of them.
It's hard to see the forest for the trees when you are just getting started. When your entire experience has been small programs with little repetitive logic, functions seem unnecessary. Once you start writing more complex programs, they will make sense.
I'm new as well, but one of the reoccurring principles is DRY code. Don't Repeat Yourself. Functions make this possible. It takes a program that would be 5,000 lines down to 1,000 just because the functions were only written once.
Calling a function in one part of the code and then having the actual code somewhere else in the file confuses me.
You just need to get over it. I know that sounds bad (and maybe a bit rude), but it's true. Where the code is executing (and really, even what code is executing) doesn't matter to you in 90% of cases. It's too much information for you to be reasonably able to use anyways. If you're reading code and see this:
As a simple user of the method, it doesn't matter how produce_things is defined. All that matter is that you understand how the function is supposed to be used. You should understand what restrictions on input it has, and what guarantees on output it has (and those facts can be learned by reading the docs).
At some point, you need to abstract away from focusing on the details of the functions. You write a function that does some complicated task, then you name that code by wrapping it in a function. You can now use the code without caring about how it works.
As an analogy, your comment is a bit like saying "I don't like using pre-made microwaves. It's confusing for me to not be able to see the wires". The problem with that attitude is the internals are often complicated, delicate, and can cause bad things to happen if misused. This is true for both microwaves and code. Microwaves provide an outer interface so they can be used safely. Functions also provide an "interface" (the input/output of the function) so they can be used safely in a controlled way.
It is important that the function names are meaningful then you don't worry about not seeing the code.
if the function name is getUser then you know exactly what the function will return and you don't need to know how it does it.
i struggle to see how functions make a program easier to write
Often they don't make it easier to write. Functions are more about making a program easier to read. You see something short like postComment() instead of the many low-level programming language instructions it takes to implement it, and you usually don't have to read those details.
Think about Wikipedia. You're reading an article. It has links to other articles. You click on a link, and it takes you elsewhere. If you want to back to the original article, you hit a back button. It's like that.
Would you want one Wikipedia page that is a billion lines long? Or would you prefer mini links to individual topics?
Usually, what people find challenging is
giving functions good names
understanding parameter passing and return types
If you don't do this, then if you have a function you call 5 times, you'd have to copy and paste that code 5 times. It's like saying "I don't like loops, I'd prefer to write it 5 times" and that doesn't even work because you'd have to pick a number instead of letting it run, say, N times where N is picked by a user and not hardcoded to 5.
The point is, you can't call yourself a programmer if you don't learn functions. It is absolutely vital you learn it.
Plenty of articles out there. Try "what good are functions?" in your favorite search engine.
A big advantage is that they make your main code easier to read. Instead of having to read say for example 1000 lines of code to see the top level logic of a program, it might be 20 or 50 lines, with all of the separate tasks broken out into nicely self-contained functions.
Another big advantage is re-use. Often you will find a program needing to do a task over and over. You don't want to copy-paste code if you can avoid it. Again, it's harder to read and when you go to fix a bug or improve copy-pasted code you'll have to do the same changes over and over. You'll miss one if you're not careful.
A major software project will be many thousands of line of code. Tens of thousands of lines, even hundreds of thousands. It has to be modular. Otherwise it's madness. :)
If it helps, I like to think about it as creating a new instruction. Yes, the definition of that instruction is somewhere else but you‚Äôre still calling that instruction in the right place. Just the same as the code for the print() function is defined elsewhere but it makes sense within a program. This is one of the reasons function names are important. It makes a lot more sense to see a function called ‚Äúadd two numbers‚Äù in your hundreds of lines of code than it does to see ‚Äúadd‚Äù for example. Hope that helps a little.
The main point of functions is literally to make codes not thousands of lines more code, prevent it from being a huge mess with conflicts everywhere and just preventing over complication in the code
You can theoretically have code thousands of lines long that can be reduced to 50 lines of code if functions were just used instead
Confused me until I saw it and used it over and over again thousands of times.
Nothing magical about it after that kind of repetition.

Comments from https://www.reddit.com/r/learnprogramming/comments/wk6e3s/algorithms_are_confusing/:
Hi everyone, so I'm new to the tech world trying to learn programming and I've found that some parts of programming are easy to understand and some parts are a little more confusing, for me the section that's been giving me headaches are algorithms, data structures & functions and was wondering if the experienced programmers out there knew of a site or book that would help explain these things for a beginner like me. Any help üôè
My suggestion is to not limit yourself to one site. When you are having difficulty with an algorithm, look it up in more places. See if there are youtube videos of someone talking about it or just another website with a different person talking about the same thing.
Not everyone learns things the same way, so the more places you look increases your chance of finding a description that clicks for you.
I don't have a specific resource recommendation. But I think the confusion you're having is because this part you're learning about the logic of the program, instead of syntax. They are pretty much distinct from each other. Logic is about how the program should run. Syntax is about how to tell the computer to do what you believe to be how the program should run.
Because of that, logic is pretty much universal. It's (mostly) the same across all languages, or at least those with imperative paradigm. And it's not even restricted to programming.
Because of that, I had always find it a lot better to learn logic through pseudocode. Pseudocode is a mixture of natural language and programming language. Benefits of pseudocode:
It gets to the point, and highlight the main idea behind the algorithm and data structure. Natural language is too imprecise to describe those. While real programming language suffers from having a lot of quirks and extra "bureaucracy" that distracts from the main idea.
Since pseudocode is not specific to one programming language, many sources use pseudocode instead. In particular, Wikipedia. If you open yourself to read pseudocode you have a lot more source to consult from.
Pseudocode is not real code, it can't run. That motivates you to actually implement the code in a real code. The process of understanding pseudocode and implementing the code will help you learn much better. When people learn from real code, they have the tendency to get lazy and copy without understanding it.
Can you try to describe what is confusing you? You're reading some explanation, so can you give an example of an explanation that get you confused?
there's a like 4 hour video on youtube about datastructures and algorithms, I didn't finish it but the begining really broke down and visualized it well if you're haven't checked that out. I forget the channel name, was a long ass video though
My suggestion is always to use the book, an ‚Äúintroduction to the theory of computation‚Äù by Michael Sipser. Really understand that book. It‚Äôll take some time, but you‚Äôll be able to get algorithms and data structures no problem. Like really understand them where you can use and improve them at a core level

Comments from https://www.reddit.com/r/learnpython/comments/84ownr/i_have_my_confusion_about_python_as_for_what_to/:
Started learning Python a few weeks ago. Im a newbie. I have been learning the basic staff and not sure whether what I have learned so far is all the basics or there is more. I have been learning through multiple sources like SoloLearn, thenewboston, or some other Youtube videos. SoloLearn doesn't have much explanation or good examples. I learnt alot from thenewboston but there videos are pretty old as of now and there are a few python concepts that weren't in there videos and had to look for those concepts in other youtube videos. Python's official documentation is pretty hard for me to comprehend as I am not a native English speaker and the documentation is written in a very hard english (atleast seems to me). but whatever source it was that I looked into there were quite some things that I came across but either didn't find enough explanation or didn't find it being mentioned at all. Or it was probably mention and used in code but not explained. statements like 'in', 'as', 'not in', 'none' 'pass' and maybe a few others.
The point is, I can't find each and everything being mentioned in one single course. And the concepts that I see have to be looked in other sources as well to be finally satisfied with the concept that what it is, what is its purpose, how to use it etc etc. Have to go through the same thing multiple times. and in the end when I look back its nothing but very basic stuff that I have learned so far
Heres an outline of things to learn (Beginner, Intermediate, Avanced):
Beginner
Data Types - Lists, Strings, Tuples, Sets, Floats, Ints, Booleans, Dictionaries
I/O - Sys module, Standard input/output, reading/writing files
Control Flow/Looping - for loops, while loops, if/elif/else
Arithmetic and expressions
Functions
Exceptions and Error Handling
Basics of object oriented programming
Intermediate
More advanced OOP - Inheritance, Polymorphism, Encapsulation
Data Structures - Linked lists, Stacks, Queues, Binary Search Trees, AVL Trees, Graphs, Minimum Spanning Trees
Algorithms - Linear Search, Binary Search, Hashing, Quicksort, Insertion/Selection Sort, MergeSort, Depth First Search, Breathe First Search, Prims Algorithm, Dijkstra's Algorithm.
Algorithmic Complexity
Advanced
A.I./Machine Learning - Advanced Search Techniques, Genetic Algorithms, Neural Networks, Backpropagation, Machine Evolution, heuristic search, Natural Language Processing.
This list is a decent enough outline of what kind of learning path you should be taking. Of course theres things like web programming and stuff that can be thrown in there while you're at it.
It should keep you going for about a year. Best of luck and enjoy!
Once you feel like you have a handle on the syntax, it would probably be best to work on small projects. Solving problems solidifies your understanding of the concepts. Here's a diverse list of small projects that I like. I would feel comfortable with all of the everyday features before moving on to more advanced topics. Once you're ready, there are lots of good YouTube videos at channels like Coding Tech and Pydata you can watch. Probably the best places to start learning about data science and web development in Python would be at the pandas and django websites, respectively. They both have fantastic tutorials.
List, set and dictionary comprehensions are useful. They allow you to do a lot with a little code.
There are a lot of different ways to make GUIs. I originally learned tkinter although I hear qt is better. There are several more frameworks for creating guis.
Matplotlib is nice for plotting stats. Pandas is nice for manipulating large sets of data and works nicely with matplotlib.
Network related thing such as creating a TCP/IP server is surprisingly simple with python. BONUS: threading is a piece of cake to so thread those sockets.
For a little practice. http://pythonsandladders.com
YouTube Sentdex for good tutorials.
Automate the boring stuff is a free book that is pretty good too.
Can anyone just tell me what else am I missing in python?
You've learned basic language features and you're correctly noticing that this doesn't add up to knowledge about how to write software. It's like finishing a Rosetta Stone language course and noticing that this doesn't add up to knowing how to flirt with French girls.
There's not really a tutorial for software engineering because it's a process of developing your own creative, professional judgement. You can't be walked through that process, you just have to try and fail a lot.
That's why the next step for you is just to start. You can't wait until it feels like you're ready, because you won't ever feel that way. Every time you open a text editor to write software it's basically like taking a step into the unknown.
You just have to start solving problems with code. There's not a walkthrough for that; you have to open the text editor and write Python without knowing what the right answer looks like.

Comments from https://www.reddit.com/r/learnpython/comments/3iu7jl/compact_code_elegant_or_confusing_whats_your_take/:
Though I've been coding for almost 20 years (on and off), I'm still quite new to Python aiming to adopt a more Pythonic coding style. It helps to trawl online for examples whenever I'm trying to solve a problem. Here's a bit of code on stackoverflow that I'd like to discuss. The question the OP asked was how to list all files of a directory in Python.
A top suggestion was:
I get what's happening here. In one line you accomplish a heck of a lot. Some might call it elegant. But it took me a while to figure out what was going on and how that line accomplished its magic. I'd venture to say that for a Python newbie like me, it was a little confusing. For example, it was my first time encountering the f for f in... construction in Python. While I had a gut feel for what it was doing, I needed to experiment to make sure.
if something can be wrapped in a simple list/set/dict/generator comprehension, do it. one loop level and one condition are definitely simple enough to do so.
comprehensions are an expressive and widespread concept, which is better for everyone to learn right now instead of having his/her hand held.
you can make things more clear by using better APIs:
Yes, I would consider that list comprehension to be Pythonic. It's a common pattern that's easy to glance at and read, once you have seen it enough times.
In fact, for me, I think it's easier to read than your code, because as soon as I saw the square brackets and the "x for x in" pattern I knew exactly what it was. A generic for loop can be used for a lot of different things so it requires a little more time to make sure that you understand what it is trying to do.
I think that you are uncomfortable reading "f for f in" or other constructs like that because you aren't particularly knowledgeable about the language. I would have to say that absolutely anyone who writes python code in the industry must be able to decipher simple yet elegant code fragments like the list comprehension you pointed out.
I think right now you are frustrated about syntactic sugar, the idea that certain code can be written multiple ways, generally to aid the programming in writing more concise code and accomplish their goals while writing 1/4 of the lines of code (in the case of the example you wrote). Syntactic sugar is there to aid programmers who use the programming language explicitly and are at least generally familiar with it enough to write code that actually does something worthwhile. On that note, if you want to label yourself a "python programmer" you should definitely be comfortable reading the example list comprehension you posted.
Until you get better and more experience, there may be a lot of code that you find unfamiliar, code that you would be better able to understand if it was written more "explicitly" as you wrote. I would argue for one, the list comprehension you posted is very explicit, and that that is not the problem you have. You are actually saying you tend to write very verbose code when something less wordy and equally as understandable to most all users of Python.
Don't get discouraged! I use about 4 languages weekly, and I am often running across new constructs in those languages that I have to lookup, get familiar with, and wrap my head around for a while.
The reason the list comprehension is more 'elegant' is, in my opinion (and quite opposite from yours) is that it's MORE understandable to readers from a variety of languages. Think about reading the list comprehension as a sentence, and then look at the 4 lines of code you suggested was more clear? The hurdle here is the understanding of list comprehension, but once you understand those, I would argue that the list comprehension is more readable, more pythonic, and more concise.
One last thing that I want to reiterate-- If you are at a company, and that company uses Python, it is necessary that the company programmers understand what a list comprehension is. It is a very fundamental part of writing clean, understandable, and succinct Python code.
The list comprehension there is fairly clear. It's when you nest them too heavily that it gets rough.
I think your version is totally fine. I also think list comprehensions are great.
List comprehensions are a weird part of Python, in my opinion. Overall, Python is an amazingly intuitive and straightforward language (at least compared to most others). That's one of its major strengths.
List/dict/generator comprehensions are kind of an exception to this, though. In my opinion they are in no way intuitive. For most people it takes a bit of focused work and practice to get comfortable with them. Until you come to a realization which I'll talk about towards the end of this, there just isn't anything out there that the average person can relate to comprehensions (unless you do a lot of math with category theory or something? I don't know, not my thing).
But on the other hand...
It turns out in real life you need to build lists, and other data structures, in that exact way, with those exact four lines of code you supplied, all the time. It's almost hard to realize how insanely common it is until you switch back to a language without comprehensions, and you come to that first place in your code where you think, "Man, a list comprehension would be perfect right here. Time to write a for loop I guess... Step one, initialize a counter variable. Step two, establish boundary condition. Wait, what's the size of my array again? Step three... Dammit I would be done with this loop already in Python."
It seriously happens all the time. We need to:
Make a new list (line 1)
Take each item from some other iterable (line 2)
And if a condition is met (line 3)
Append the item to the new list (modified, if we want) (line 4)
Which kind of blends into another great strength of Python: iteration. They realized that iteration is one of of the most important and common things that happens in programming, and then they implemented a language around making it safe and simple to do so. We don't need subscripts, boundary tests, counter variables, etc. All of those things which are so ridiculously easy for humans to create devastating bugs with, we don't have to worry about in Python. We just for item in iterable:... and boom, we're on our merry way.
This is already pretty rant-y, so I'll just kind of wrap it up. But yeah, I agree comprehensions take some time getting used to, and you are under no obligation to use them. I think your four lines are fine and perfectly understandable. If you want to avoid comprehensions in favor of that style, I can't fault you.
Oh yeah, here's the realization I mentioned earlier. Or at least the realization as it occurred to me. Comprehensions are nothing but a concise, elegant rearrangement of your exact four lines of code. Four lines of code it turns out you have to type all the dang time. Yes, it takes some getting used to, if only because unless you use Haskell or are a mathematician or something it's probably simply novel to you. But once you make that mental mapping of the rearrangement, and it becomes part of your programming vocabulary, it's pretty great.
I spent way too much time typing this.
As a bit of a simpleton, I always stick to the zen of python.
In other words, even if you can do something in 1 line instead of 3 or 4, what's the point? Unless it relates to performance optimization, I think it makes sense to make your code as readable as possible. This will allow other devs to easily grok and update your code.
As a relative beginner to programing, I hate the "elegant"/compact solutions. They are much harder to read for me.
I imagine that might change in the future, but I don't really see how it helps anything.
That said, comprehensions are super common in Python. The one you listed isn't too bad of an example.
its interesting to see the two kinds of responses you are getting. From newer learners, your second code is more readable -- while all the frequent users essentially tell you the opposite. If I showed a random person your code, I am also confident the second snippet would be easier to understand. Swingtheory's post is probably the most honest -- its not easier to read, its easier to program once you know how to do it, and once youve done enough programming in this format it becomes 'easier'. But thats like saying taking derivatives is a walk in the park. Sure, once you do enough calculus to ingrain it as part of your intellectual tool belt. And thats a real choice -- just because its easier to do does not make it easier to maintain or re-use or translate sometime down the line for someone else.
But as your own questions at the end already answered it, that is the wrong attitude for 'Pythonic' coders.
You are confusing unfamiliarity with confusion.
From the Zen of Python "Readability counts". So if you can read compact code it's elegant, if you can't it's confusing.

Comments from https://www.reddit.com/r/learnprogramming/comments/emo8qc/is_coding_supposed_to_be_confusing_as_a_beginner/:
hey guys. I'm a beginner coder, currently using Unity C# to make video games. at my current stage, I've been reading and watching YouTube videos on making games, but whenever I see them putting in a line of code I wonder how in the world am I suppose to put that without having to watch a video or some sort? how would I remember a line of code to make something work if theres a billion of other codes I gotta remember? dont get me wrong, I've been having a bit of fun coding, but I'm just scared I'm gonna have to be dependent on tutorials and such for the rest of my coding "career." especially when I'm really interested in video game design and trying to get into a career of that field (currently in high school).
EDIT/UPDATE:
wow. woke up not expecting this many replies nor upvotes, lol. some put fear in me and some gives me some confidence and relief. either way I wanna thank you for replying. I wanna answer a few concurrent statements that I wanna get through first
yes I understand coding is hard and gonna be hard, it's just that I was scared I was gonna be dependent ON tutorials and such
Every complicated subject is confusing as a beginner.
The process is the same for most of things.
I have a problem -> I read the manual -> I fix the problem. The next time, you'll know how to fix it without reading the manual.
The same applies to programming, you have a problem, lookup documentation, and then solve the problem.
Honestly, I think the answer is yes. I personally found coding to have a very steep learning curve - at university when I did programming modules, I didn't really understand all that I was writing and leant on more experienced friends for help.
That word is key - experience. The more you do it, the more you'll see the same problems crop up which you've already done before and so you won't need to look for advice.
Honestly though, I did find there was a moment where it clicked and you no longer were constrained by 'how do I express this idea in code'. What happens then, is you have all these ideas you know how to do and you just don't have the time (which is why I think a lot of programmers do coding instead of other things - cos it's properly addictive).
It's like any other creative art too - with drawing, you'll start off not understanding shadows and texturing, but the more you do it the more you're able to express what's in your mind on paper.
To reiterate, don't get despondent that you don't understand how people think things up. Being confused is absolutely expected and you'll have a moment where it clicks, I promise. (Also, find a friend who can unstick you when you're stuck and it'll REALLY help).
If you are trying to start learning programming through Unity tutorials I would suggest to stop. Grab actual programming tutorials. Learn the basics of programming first. Then you can try to hop into Unity.
It has its own ways of doing things which may confuse and it‚Äôs also a huge thing so to try to learn programming and how to use Unity at once is quite a task and will surely leave you confused.
I believe you've fallen into the same trap that I did when I wanted to learn programming in high school. That is, the belief that a large part of programming is memorization of whole lines. But in the beginning, you will only need a know a few.
- Basic Value Types - char, int, String (Yes it's an object, but that's not important for now, you can treat it like a type), double, bool etc.
- Selection Statements - IF, IF Else, Else etc.
- Loops - For, While and Do While
- Operators - +, -, /, %, *, = etc.
- Functions - Pass-by-Value vs. Pass-By-Reference (if this is in C++)
Look for beginner c++ projects that have you do some basic input/output that involve some of these, but don't look at completed code. It's absolutely vital that you run into bugs, fix the bugs and learn from them. Learning Programming is an iterative process. Continue until comfortable with the concepts.
Then jump to Arrays. Rinse and Repeat.
Then jump to Objects & Classes. Rinse and Repeat.
Then jump to Object-Oriented Programming concepts (Abstraction, Encapsulation, Inheritance & Polymorphism). This will take some time to wrap your head around, but learn through doing. Learn from the mistakes you make, or issues you encounter and how you fixed them.
As a beginner? Lol I‚Äôm 6 years in and it‚Äôs still confusing. I spent all day trying to figure out why a plug-in in my IDE wasn‚Äôt working.
But that‚Äôs the beauty. If it were easy it would be boring
Dependent on tutorials? No. On documentation: 100%.
It's really impossible to remember everything you have to type and you're not supposed to. Over time you'll memorize the commonly used patterns, functions, classes etc. but nobody expects you to remember 100% of the printf behavior, that's what documentation is there for.
Reading all these comments and wait.. you're supposed to stop being confused at some point?!
currently using Unity C+
Nitpicking, but essential: Unity uses C**#, not C+**. In fact, C+ once existed for a brief time, but is no longer used at all.
There are C, C++, C#, and Objective-C (which has been superseded by Swift).
Learning proper naming and terminology is absolutely necessary.
About your question:
Yes, in the beginning programming is confusing. Just like any other complex skill. It gets better over time.
I've been reading and watching YouTube videos on making games, but whenever I see them putting in a line of code I wonder how in the world am I suppose to put that without having to watch a video or some sort? how would I remember a line of code to make something work if theres a billion of other codes I gotta remember?
You don't learn programming through memorizing. Programming can only be learned through programming - through practice. The more you practice, the better you will get and the more you will remember.
In the beginning, you will need to google a lot, but again, with gained practice this will be less and less necessary.
Tutorials are great for a start, but once you are over the basics it is time to ditch tutorials and start working on your own. Google what you don't know and learn by doing.
how would I remember a line of code to make something work if theres a billion of other codes I gotta remember?
That's the common beginner misconception. Don't learn lines of code, learn function, concepts. Code changes, concepts don't.
This is one problem with plenty (IMO, low quality) tutorials also. They don't focus on explaining concepts, they focus on code. Focusing on code is the wrong way. This is like presenting a finished painting and tell a beginner to replicate it.
Code is the end of the journey, not the way to the end. The train of thought, the considerations, planning, decisions, abstractions, detailing, drilling down are the way. Code is only the final result.
Once you understand the process, you only need to convert it into something the computer understands.
I'm 20 years in as a Dev and coding can still be very confusing. The only thing that has gotten easier is how to figure out problems and break down big projects and tasks into smaller ones that can then be implemented with code.

Comments from https://www.reddit.com/r/learnprogramming/comments/yfwykb/i_get_confused_sometimes/:
When writing even simple code or usually during refactoring I lose my train of thought and don't know what I'm even trying to accomplish. I'm 22 so it's literally only going to get worse.
I had a technical interview to write a little program reversing lines and there was an issue with newlines, if the line had a newline at the end it should be added at the end and I stumbled my way through that so much I think it was the reason why I got rejected. I had high hopes and this issue makes me sad. I don't know if I'm good enough for serious programming.
Did any of you struggle with this? Did you overcome it somehow?
It's like any skill. You learn and train and get better.
In the beginning, you largely learn syntax and basics like ‚Äî "how's this variable scoped?" Getting anything done at that point is hard because you have to reason through every, little detail.
But after x hours, you almost never think about that basic stuff for more than a moment. You free up cycles for higher level thinking.
I don't know if you know how to drive. But when you first start driving, you are really focused on every aspect of the road, and that makes you very tired easily. But after driving for months, your brain begins to selectively process only parts that are relevant to actual driving, and you are on autopilot for the rest.
Refactoring is the same, your brain needs to adjust to seeing which part is more crucial and which part you can likely just ignore. The instinct will be honed, so you will get better over time, not worse.
Comments are really helpful here. And writing things out in English on a physical notebook will help you as well. Just like studying math, you need to take notes so you can empty some space in your head for the complex stuff.
I lose my train of thought and don't know what I'm even trying to accomplish.
Write it down before you even start doing anything.
Plan before program.
Some literature:
"Think Like A Programmer" by V. Anton Spraul
"The Pragmatic Programmer" by Andrew Hunt and David Thomas
The issue is that I am at the point that the syntax and basics are not a problem, I've been coding on and off for 4 years now and am in last year of Bachelor studies
Sorry, but it sounds more that you have learnt programming languages, but not programming. These are two distinct skills akin to learning the vocabulary and grammar of a language and to writing a novel. While the former is fairly easy due to the limited vocabulary and grammar, the latter is difficult and requires first and foremost practice.

Comments from https://www.reddit.com/r/learnpython/comments/1etwv0o/im_learning_from_free_code_camp_but_confused/:
I got step 38 of the first cipher tab I still most of the time don't know what's going on I just do what's the guy is saying and whenever I don't understand the text I just copy it and paste it in another tab and a forum comes up where that specific step is being talked about sometimes it's even solved. I pick a couple clues of there spend some time thinking about what the guy was saying and asking and finally solve it( this sometimes takes hours or a day because I get frustrated and just close the website and come back to it after half a day or so) so in summary I don't quite get what going on with the for function and loop function and the instructor feels like going in his own pace so should I continue or should I restart because I took too many breaks and that's probably the reason why I'm not picking up things as well as I was when starting this course.
The thing about the system at FreeCodeCamp... they don't run it all the way through like a regular tutorial. They expect you to do your own research and remember things from previous lessons. If you are doing Python there, I highly suggest opening w3schools python info in another tab, as sometimes they do a better job of explaining how things work in general, not just for a specific task. I am still stuck in the web dev part and thinking I should just reset everything and start taking notes...
The thing about learning programming or anything else of similar complexity is that it takes a long time and practice. 
Do lots of exercises, do things outside the course, do something else when you get frustrated and come back. But unless you're one of those natural learners (jerks) it's just going to take a while. So let it is my philosophy. Let free code camp take 3x or however long. And switch over to a YouTube tutorial or whatever to let what you've learned sit. 
Create a checklist of everything you want to learn in Python and set a deadline next to each item. Cross off each item when you‚Äôre sure you‚Äôve learnt it. Create an Action Plan using the STAR Method (Situation, Task, Action, Result). Create for yourself SMART Objectives (Specific, Measurable (key progress indicators), Achievable, Realistic, Time-bound). Create for yourself a portfolio of programs. Over time you will see just how much you‚Äôve accomplished. I recommend the following books by Chris Roffey for learning Python Programming: (1) Coding Club Python Basics Level 1; (2) Coding Club Python Next Steps Level 2; (3) Coding Club Building Big Apps Level 3; (4) Programming Art Supplement 1; (5) Interactive Adventures Supplement 2. I also recommend reading Python Docs in the Help Menu in IDLE (Python‚Äôs Integrated DeveLopment Environment). It has the Python Language Reference that lists every module and method used in Python. Also, look at Turtle Demo in the Help Menu which has sample code for the Turtle Examples. Turtle is Python‚Äôs Graphics module. The O‚ÄôReilly Python Pocket Guide is also a useful Quick Reference. It is best to take a systematic approach to learning programming.

Comments from https://www.reddit.com/r/learnprogramming/comments/s83jcx/confused_of_which_path_or_programming_language/:
I'm a programmer with almost 7 years of experience with PHP because it was the only programming language that allows me to get a job, at least I got the chance to work with Wordpress, Prestashop, Laravel, databases, frontend development like VueJS, hosting management, Apache/Nginx and Docker. I've done some stuff with NodeJS like small APIs and with Python by coding some memory reading to get certain values in PC games
Since there's an increase on other programming languages being used for backend there are less job offers related to PHP, and during the pandemic I've realized that I can emigrate to another country to develop better my carrer since I couldn't get hired. So I've started to learn Java and Spring Boot since it's a language and framework with a high demand but I've found kinda difficult to learn and also I'm struggling to find a job ASAP (right now I'm working on Uber Eats because i need to pay the bills), on the other hand I've got interest to work with Python/Django and Golang in backend but I don't know if those languages are required in companies located in the US, New Zealand, Canada or Japan (places that I'm applying)
TBH I don't feel that Java is the language that I want to work on during my carrer (by now, I hope to change that opinion in a future) compared to Python and Golang which have more interest but I don't know if I'm gonna get hired overseas. So, should I stay learning Java and Spring Boot? Or maybe there's a chance with Python and/or Golang?
You should decide by the job markets in these countries/cities. Look up different job advertisements that you can find from there and see which back end programming language/framework is in demand in one place and which is in demand in another place. For example where I'm living at, Spring Boot is the main backend framework. With Golang slowly gaining interest. PHP... it is still around but people are switching away from it, here. Django (Python framework) is not so much used here and Python is used for other things than web development.
Like that are also other countries. Your skills should be based on the local demand if you want to find job easily.
And life in Japan is not going to be easy for you if you do not speak Japanese. English is not that common there.
I‚Äôm curious, what‚Äôs holding you back the most with Java and Spring Boot? Did you happen to stumble upon the Baeldung.com site?

Comments from https://www.reddit.com/r/learnjavascript/comments/ypmsdx/is_it_normal_to_find_javascript_harder_than_c/:
Hello everyone, I'm a CS student about to graduate and I'm here because I'm pretty confused about something... Everywhere I go, every programming meme I see, every post about comparison between programming languages I see says that C++ is such a ridiculously complicated language because it is low level, pointers, manual memory management, blah blah, etc etc,... Whereas for JavaScript I think most would argue it's fairly simple to understand... And this is where I get confused lol.
At University I've been learning to code and been coding basically only with C++ (beside for a web dev project where we used some PHP for the backend and very little JavaScript for client side form validation mainly (but yeah, I didn't touch the JavaScript almost at all, I was the CSS guy of the group)) so you know, I got familiar with inheritance, polymorphism, etc... For C++ indeed, and I gotta say I enjoy it. I got hooked into web dev after the web dev course/project and I've been thinking to find a job in it after graduation, so I decided to enroll in a free online course: I'm doing the Odin Project right now; I finished the fundamentals part fairly quickly (knew most of it already, but I still read and done the whole thing) and started the full stack JavaScript part, in which I did the intermediate and advanced html and css chapters... And now I'm doing the JavaScript one.
Writing JS after only using something like C++ will be a bit of a culture shock. There are lots of gotchas to JS, and they can take a while to get the hang of. '1' == 1 returns true, but that's why we generally always use strict equality checking. That's just one super simple and contrived example of JS weird-isms. Prototypes are very different from classes and take a minute to get used to. Sometimes you need to extend an object's prototype, most of the time you don't. The best thing to do is build some stuff in JS, then convert it to TypeScript, and you'll feel right at home again. JS will be confusing at first if you only have experience with languages like C++, stick with it and you'll get the hang of it.
Despite the fact that a lot of people inexplicably start with it as their first programming language, JS is not particularly beginner friendly and has a certain amount of quirks and oddities that are down to its status as the language of the web, which necessitates backwards compatibility with every weird and bad design decision the language has ever had.
Also dynamically typed languages can often throw people for a loop if they've only ever used static types before; JS allows you to be a lot messier in some ways than a language like C++ and it can be disorienting.
Just because other people claim that JS is 'easier' doesn't mean it necessarily has to be easy for you. There's nothing that's innately easy for everyone.
My suggestion is to read Self's language paper, that's the mother of all prototype languages.
Stop whining and learn few simple rules, it's really not that hard. The hard bit in the javascript world is to stay tuned in the fast paced ecosystem.
Same. I wasn't really into programming and I knew only basics of C++. When I started learning JS I found it incredibly confusing. It's really not a beginner friendly language and I will never understand why people state that it's an easy (or sometimes even easiest) language. I personally found Python as an easiest language out here except html and css. Also heard that Go is even easier, but I've never worked with it.
Cant comment on everything you mentioned. I am relatively new to JS but I would stick to the arrow functions, it's the newest syntax, so no need to memorize multiple syntaxes.
If you're about to graduate with a degree regardless of the languages you studied you should have a grasp of the "this" keyword. This isn't unique to JS.

Comments from https://www.reddit.com/r/learnprogramming/comments/1eqgc8u/confused_need_guidance/:
I'm currently a career changer (finance/data analysis).
I'm 90% done (3 classes away) from a Bachelor in Computer Science.
I love problem solving and figuring things out.
That said, I currently hate programming but I am confused on the root cause.
I'm detail oriented, analytical and understand data structures and OOP (Java & Python).
I can figure things out for school projects where I'm fixing existing code.
I cannot do anything from scratch.
I think my issue is I don't have the correct approach to thinking in terms of programming.
That said:
Another one of countless similar posts.
So, you'll get similar recommendations:
"Think Like A Programmer" by V. Anton Spraul
"The Pragmatic Programmer" by Andrew Hunt and David Thomas
"Structure and Interpretation of Computer Programs" (SICP) by Ableton, Sussman, Sussman
"Code: The Hidden Language of Computer Hardware and Software" by Charles Petzold
"Algorithms" by Robert Sedgewick and Kevin Wayne

Comments from https://www.reddit.com/r/github/comments/1e83d7n/confused_with_how_my_code_review_is_handling_prs/:
I've never really done pull requests for an actual company so I am unsure if this is something that is common in the real world. But for this startup company, my code reviewer is letting all of my PRs stack and has been stating that he has merged it all locally on his end. This doesn't make sense to me, and I feel like I am just blindly putting out PRs without knowing the actual progress of the code. I was frustrated and wondering if he is just overly controlling of the code. I would love feedback but my PR's just sit there for weeks on end. Some of the PRs I make are also blocking as I made some UI fixes for a button which is dependent on another screen that is a work in progress...
I've discussed this to him once and he says its okay if it overlaps and that he has merged most of the PRs on his end (he has been stating this for weeks and I have yet to see it merged onto main). He also said he will "take on" relevant code with corrections if required and that its okay if PRs are not perfect. I want feedback and I also would love to see my contributions to be on the repository instead of it being randomly merged in on his end with changes I am unaware about so this is pretty demotivating and I feel like I am not learning at all. To be honest, code progress has been embarrassingly slow for a startup that wants to launch because of this. He suggested to the team that we should take on another intern when in my head I want someone who can handle PRs since they're just collecting dust at this point.
Sounds a bit silly, him withholding feedback like that. In my experience feedback is given right on the PR or issue- you can see this happening in the wild in open source repositories. So, at first pass this doesn't sound "normal".
Sounds like a control freak. Some developers treat company code as their pet projects. You cannot work this way in a group. PRs should be merged quickly. If lack of time is an issue, you can speed up code reviews with the right tools.

Comments from https://www.reddit.com/r/ChatGPT/comments/14lisa9/chatgpt_coding_skills_seem_to_have_been_gutted_im/:
As always it'd be helpful if you provided specific prompts where it's failing.
As someone with an AI company, most of the time when someone is having no luck with GPT4 , it's because they need better prompting.
Break your problem into clear, simple steps. You want to minimize the "logic per token" needed to answer your question. It's the difference between:
"Code a to-do list app"
"I'm creating a to-do list app. I'm using python dictionaries with the following attributes to manage state. I'd like for you to write a class that can update an item, given the item id (str). If the item doesn't exist, raise a ValueError"
Breaking your problem down like this has massive impacts on performance on non trivial prompts.
This is always a funny progression
Technology doesn‚Äôt exist
Tech product is invented, hailed as a miracle of modern science and engineering
Product is released to the public
The public first resists the tech, then adopts it, then habituates to it
Once they get used to it, it sucks
What was once purely theoretical becomes a piece of junk in 8 months or less
Every time
Every single day we get someone saying "they GUTTED GPT, before today it was GREAT and now it's BAD!"
Every single time I've noticed no real change and can use it just as well as before. I have it write code for me pretty much every day. Prompt better, keep context length in mind.
People here pretending the issue is prompting need to get off their high horses and understand that not everyone is a dumbass just asking GPT 4 for stuff with no prompting.
I used to use GPT 4 everyday for work (coding) and it was super helpful to get started on new stuff or be faster on refactoring, adding a bit of new logic to existing stuff etc. Usually simple but precise prompting is more than enough - clear instructions, some small code snippets or examples, steps.. But I almost don't use it anymore because the code it gives is so bad I feel like I am using GPT 0.5: it is buggy, a lot of code is hallucinated out of nowhere, even on very small code quantities, in the end I lose more time having to debug its code and make it fix it than it would have taken me to code it myself.
It has been nerfed and anyone pretending otherwise needs to get off OpenAI's dick for just a second and actually think critically.
I appreciate how people on this thread are encouraging good prompting skills and general techniques. But let's assume we already have those, right? And we now see a noticeable difference since the 0613 update. It can't be just "through of disillusionment" .
Truth is, OpenAI rugged us of the powerful model, they toned it down due to massive regulatory pressure and now we are left with a less sparkling, genius AI. There is no access to the regular user to the OG model. Also, I think Microsoft is also pushing in this story, to get more people use their AI integrations and steer away from ChatGPT. When you invest 10 bln in a company, you get at least some attention.

Comments from https://www.reddit.com/r/thinkpad/comments/1ckonb0/confused_about_choosing_the_best_programming/:
While I was choosing, I noticed that all the models that are recommended on the Internet are either too cheap or too expensive, and those that suit my price have analogues from other manufacturers with better characteristics (higher screen frequency and higher resolution). I also don‚Äôt like that Lenovo has started making non-expandable RAM in new models. I would really appreciate your recommendations as I'm starting to think that the Thinkpad is not for me.
...for $1,100 I would buy a screaming off lease machine configured for engineering-- better specs needed, CAD can be as demanding as gaming.
I generally pay 33% of the new price on ebay. My current laptop has 64GB of RAM... all replacable, discrete GPU, a XEON CPU, a "3K" main screen, a good TouchPad, and I have a docking station for it. I think it was maybe $700.
"Pleasing to the eye." If you aren't gaming 120hz is going to be fine.
My 55" 4K secondary screen is only 30hz...
I code for a living.
newest gen T (gen 5), L (gen 5) and E (gen 6) series all have two RAM slots and also a 1900x1200 screen
why do you want a higher screen frequency? what would you use the laptop for?
You need higher screen frequency for programming?
Soldered-in RAM is much faster and to be frank, how often do you need to expand? Are you gonna code on it or is it a server rack?
To be honest, I really want to buy a Thinkpad because I have heard about its incredible quality, but it seems that due to the build quality they have skimped on performance and characteristics.

Comments from https://www.reddit.com/r/learnprogramming/comments/ol3q3c/i_want_to_learn_and_get_a_job_in_programming_but/:
I've been learning Java online for a few weeks now and I enjoy it, but I've been trying to make a plan for the future so I have a goal in mind. What kind of job should I shoot for first, and how do I go about finding that job? What do I need in order to be hired? I feel like no one can give me straight answers.
Great questions. Here's how I would answer them for my students.
What kind of job should I shoot for first?
If you are a competent coder, I recommend working for a startup your first few years. Startups let you wear all hats and are most likely to give you a chance.
How do I go about finding that job?
Use any normal job searching service like Indeed or Glassdoor or LinkedIn. Generally speaking, you can tell what companies look smaller. Shoot for those.
What do I need in order to be hired?
You have to be a competent coder with experience in the technology that they have. If they have Ruby on Rails, you have to be able to perform on that.
What's a competent coder?
Basically if I were to ask you to build a feature using technology you've never used before, could you learn and build it on your own? Competent coders are independent, write good code with minimal bugs. If you don't know how to get here, then find a school.
This career field is a vast landscape but start with reading the FAQ at r/cscareerquestions
Why not get a java cert? At the very least you'll have a pretty good understanding of java afterwards.
Also:
Build finished projects
Put your projects on GitHub
Make a good resume (lookup good cs resume examples
Apply a LOT. And potentially for months and months. It can take a long time to get your first job, but you're not alone.
Do firecode.io or leetcode (these can be very difficult in the beginning, but be patient with yourself)
I feel like no one can give me straight answers.
uh, go to university and get a degree in computer science ?

Comments from https://www.reddit.com/r/vscode/comments/v2q0ld/extremely_confused/:
Hi guys,
I just downloaded vscode. I used to use an IDE (jGrasp) for my college intro class. The next class uses vscode, so I wanted to get a head start. I downloaded the JDK thru vs, etc.
I don't know if I'm doing something wrong, but whenever I try to run something, this shows in my terminal. I'm just really confused on how to navigate this IDE, honestly how to even create a project or file etc. I use java strictly. Like, on my old IDE it was really simple to make a project and a new file, but here it's so confusing to me. Any tutorials you recommend?
And why was the code running on the vscode terminal and not outputting "Hello"?
The start is just VSC initiating your program. It switches and runs the code in the terminal at the bottom as thats where its set to run
It is a very robust program and can be very confusing to say the least. I recommend just playing with it and seeing what everything does so you get a better and deeper understanding. When all else fails hit up YouTube or Google ü§∑üèΩ‚Äç‚ôÇÔ∏èü§¶üèΩ‚Äç‚ôÇÔ∏èü§£ü§£
It does look like it‚Äôs working. It prints out the ‚ÄúHello‚Äù like you want. The stuff before it looks like the commands the Java extension runs. Your UI seems a bit off to me. Are you on a Mac by any chance?
what you have to realize is that VS Code is not an IDE. Everything that is happening here looks right. when you run code here all you are doing is using a shortcut to run a terminal command. you can do some research on more extensions to make the editor more like what you want.
Looks good. The next step is getting used to the terminal.
vs code is not ideal for java (i would definitely use intellij idea) but it should work
you need to know that vs code is an editor which makes it highly customizable and expandable but that also means it will show the command it runs in the terminal and similar things because it's not tailored for this special case
These videos give good explanations on how to setup a Java environment and run a Java program on VS Code. Let me know if this helps:
https://www.youtube.com/watch?v=ClU9N4ub_Ko
https://www.youtube.com/watch?v=KiDwLEikUho

Comments from https://www.reddit.com/r/learnprogramming/comments/1do8m5s/i_am_confused/:
Hiii guys. I've been doing DSA for a year now and ive been following courses and this is the approach I've been following
see the concept and study that.
Following tutorial for initial questions
Then for further questions of the concept, I firstly try myself for 30min to 1hr and even then if im not able to do it then i see the tut and move on.
Is this an okay approach?? And please tell me how do you guys study and what is like your daily routine??
Thank youü´Ç
What goals have you set? How do you measure success? 
This approach could work for some, might not work for others. You need to evaluate if it's helping you achieve your goals

Comments from https://www.reddit.com/r/CodingHelp/comments/1e781om/confused_choosing_between_java_and_javascript_as/:
Which would be a better one to start with?
I've been wanting to start with python but I've been reading a few comments stating that starting off with java/Javascript would be better because it's more difficult. So python would be much easier after.
Am I getting this right?
Thanks
Choose any language, but definitely not JavaScript. It has the weirdest pitfalls I ever experienced in about 25 years of programming.
On the other hand, if you don't quit programming after the frustration of JavaScript, you'll stay forever!
Also: if you want to learn Python, start learning Python. It has so many key differences to C-style languages. Don't learn a C-style language before Python or you'll be kinda confused as a beginner. And also jumping from one language to another isn't great as a beginner.
The bonus to learning JS first is that you‚Äôll be able to learn the front and backend at the same time.
Python is very easy to learn as it‚Äôs very human-readable, so is a great 2nd language to learn. That said, Java is also a great language and widely used, so honestly either are a great 2nd language to learn.
Personally I would start with JS, Node and React (as long as you‚Äôve already got HTML and CSS principals down)
What do you want to do?
Java is what I started with, i loved it mainly for it having OOP, a good way of organising code, that involves abstraction. The fact that you have to specify types. Then you would do class diagrams and stuff. Pretty good over all you'll learn a lot.
Want to do webdev? JS. Dont want to do webdev? Java.
What do you want to build? Why do you want to learn? That really influences what you should learn. For instance, if you want to build websites, learn HTML, CSS, and then JavaScript. But that's not what you should learn if you want to build games, or if you want to do electronics.
Many programming languages share similar principles in some parts, some are easier (Python), some are more difficult and some should not exist (JavaScript üòÖ). You might want to learn one that you will actually use, don't learn a language just to learn a different one. Check what languages are used in the field you want to do and pick according to that.

Comments from https://www.reddit.com/r/Cplusplus/comments/1d1vwmh/i_am_really_confused/:
I know this is a very common issue , but i am still confused. I don't know what branch to follow or what to do after learning a great portion of c++ .i have invested too much time(the whole summer) in learning even read a book on it(A Complete guide to Programming in c++ by Ulla Kirch-Prinz and Peter Prinz). I use visual studios and the amount of project types that i even don't understand half of is making me feel that i barley scratched the surface. Any advice on what to do next , or any textbook to consider reading .
It probably feels like you're barely scratched the surface because... you've barely scratched the surface. Try to build a simple project that is useful to you? Find other projects and repos that are interesting and figure out how to compile them, explore their code base, etc.
If I gave you learning materials on how to play video games, but I didn't give you a video game to apply it to, you'd be full of a bunch of word salad about camera movement and point of view and targeting recticals and inventory management and God knows what else, but it would mean nothing to you practically.
People used to ask me to "teach [them] Linux" because they felt like it was something they would need to know in the future. But they didn't have any Linux system and they didn't have anything they needed to do.
Very large topics cannot be learned without the practical side of performing the tasks in the topical area.
You cannot learn a programming language unless you write programs in it, and writing a program in it for arbitrary reasons doesn't have an element of need other than learning. As such, there is no structure to be implemented in a particular necessary way.
So when we go to school we get assignments to make programs of various complexity with specific requirements. It is that structure that makes those programs a useful task of learning. Because you're not writing a program, you're writing a particularly specified program to some degree or another. It's matching the language elements to the structure that makes it a meaningful exercise.
Necessity is not only the mother invention. It is the birth of understanding. You have not put yourself in a position where you have the need to integrate all the little tiny factoids you picked up in your studies.
And you will never encounter a reasonably sized task that requires you to use all of any language let alone c plus plus.
If you bought a 10,000 piece mechanics tool set, it would be years before you'd used half of the tools. Having the tools is about not having to stop work to go get the tools you don't have yet. But there's still a reason the Snap-On truck shows up at various auto shops because it's got the tools that noone thought to buy yet .
So all the tools is like all the language, it's not something you really need or want, you need or want a subset of it that you'll actually use, Plus the option to go and get more out of the book..
So you need to start actually using your c++ knowledge, and starting at hello world, and working your way up through a series of necessary tasks. It's the task that tells you what you actually need to learn next.
You think c++ is bad? Try erlang. It is my favorite puzzle language. It's fun to mess with, but if I don't keep messing with it constantly, which I don't, when I come back to my old code, it's a real head scratcher. And by old code I mean anything 6 months old or older.
So the problem is not learning the language. It's learning the practical set of the language you'll need in order to jumpstart your understanding. And to do that you need a task. You need to apply to something like robotics, or home lighting, or some sort of trivial game, or some actual task you need to accomplish with your network system or something. Just anything That imposes shape And goal..
Know that this isn't even vaguely tied to any one topic. All of science, once you get out of the telling stage, is about repeating the classical experiments so that you understand what's going on.
So you've learned about c++ but you haven't really learned the language yet because you haven't really used the language yet.
So you just need to find a reason to use it and then use it.
Disclaimer. I'm forced to use voice to text so sometimes this stuff gets a little mangled. Hahaha.
Try making some project. One thing I would recomend is if it would be possible for you, begin with c++ on linux. It makes it alot easier to do stuff like net sockets, threads, and many more.
Try to making some project, don't be afraid to google things.
Visual Studio will show you a lot of options for creating projects specific for Microsoft technologies. Ignore them. Unless you know you need one of them, you won't need them, and you may never need them. Think of a project that you want to program, and then focus on what you need to learn to accomplish that. If your goal is to focus on C++ itself right now, writing console applications will be all you need.
What I did was listen to my wife complain about some particular, data-related, time-wasting, and repeating issues at her job, that no one seemed willing or even interested in solving. After making suggestions about how she should convince her leadership to change the system, etc and realizing that her leadership would never do that, I realized that I could solve the problem using python. She brought it up to her leadership and they replied ‚Äúif he builds it, we‚Äôll buy it.‚Äù
That was the catalyst I needed to really sit down and make progress with learning, because if I don‚Äôt make this work, I‚Äôll miss out on that sweet income. Others in the thread have said, and I‚Äôll reiterate, find a real-world problem to solve and go solve it. You‚Äôll learn what you need to along the way, and you‚Äôll be better for it along the way because now you have a reason to apply all your learning. It will stick much easier.
I use visual studios and the amount of project types that i even don't understand half of
My dude, I've been at this since the 90s, and of Visual Studio project templates, I've only ever used the Win32 Console Application, the Windows Desktop Application, the Static and dynamic libraries, and MFC -a fancy C++ GUI framework.
That's it, that's all you need. You don't even need that many options - the project template wizard is only there to help you setup an initial project config, you can configure any of this yourself manually and get to the same place without the wizard. I've used WTL and DirecX, COM and other things that I'm sure the wizards would have gotten me there just the same, I dunno...
All I'm saying is Visual Studio is an IDE, it's servicing a whole bunch of different developers doing a whole bunch of different shit. Don't even try to learn it all, there's no point.
I've written video games, tools galore, I've built out and supported cloud infrastructure, databases, data caches, trading systems, critical infrastructure, kernels, drivers, custom hardware, DSPs, and more. I'm not missing out on anything and neither are you.
i barley scratched the surface.
That's true, but after 30 years myself, I can say same here. The more you learn, the more you realize how much you don't know and will never know. That's fine. That's normal. That doesn't mean you're not good. I've got my niche, I'm more than happy to let someone else specialize in some other niche. We each don't do it all.
Any advice on what to do next
Why did you get into software? What software do you want to create? Go do that.

Comments from https://www.reddit.com/r/javascript/comments/vers2r/askjs_confused_and_struggling/:
I'm 20 and a self taught, started last 4 months ago. I studied HTML & CSS on first month and by far, it's my favorite. It's fun, easy and exciting to work with. And then there's JS, it hit me and destroyed my confidence on coding. Till now, I can't build a JS website without having to look at tutorials. I'm taking frontend mentor challenges as of now and just building sites as much as I can but have to look for a tutorial on JS, they say you have to get your feet wet and put on work but I feel so lost on where to start from, I love coding but man, JS drains me so much.
4 months are really not that much. Don't despair and keep grinding. Try something like freeCodeCamp or Exercism and take it one step at a time. It takes months to become comfortable with programming at first, and a bit of frustration is inevitable. When you feel down just take a break. It will get easier after some time... The frustration will be rewarded ^
‚ÄúI can't build a JS website without having to look at tutorials‚Äù Bruh I‚Äôm a 15-year veteran of the software development industry and I can‚Äôt make a JS site without looking at tutorials and googling constantly üòÇ
I‚Äôve been a developer for 17 years. 60-70% of what I do involves regularly checking references. My years have taught me where to look to find answers, they haven‚Äôt caused me to memorize all the languages, frameworks, and libraries I use. Don‚Äôt despair, lean into being ok not knowing and find the sources that make coding feel less overwhelming.
4 months?
There a bootcamps that go for 6-12 months and people barely know the foundations.
It‚Äôs part of the process. Just keep at it. Maybe start with basic features i.e click a button to toggle a class that changes the background color of the body element. Gradually you can increase the difficulty.
Something that helped me was getting a pen and paper and writing out the steps that I think are needed to make something work. You may not get all the steps, but it‚Äôs a good exercise and starts training your mind to problem solve. Just try to do it by yourself for an hour, or so. If you can‚Äôt get it, no worries. That‚Äôs what google is for.
Don‚Äôt be too hard on yourself. Programming can be hard. Just keep at it.
Did anyone tell you that you should not be confused with only 4 months of experience? I mean seriously JavaScript opens up immense amounts of logic behind web development you couldn‚Äôt seriously be expecting it‚Äôd be straightforward..
You'll get the hang of it.
The problem is, a lot of JS tutorials usually don't really go into how a thing works. They'll tell you drop these bits of code here, but they don't really explain what they're doing. And that sabotages a lot of newbies.
A lot of programming professionally is reading code - and, moreover, looking up and understanding the APIs the code is referring to. And sometimes that alone is a day's work (because a lot of APIs are wrangling abstractions atop abstractions, and you have to grok what they're doing before you can make them do it effectively). Because in production environments, you can't change things without really understanding what you're changing.
Your best bet for finding where to start on a given thing is to ask a specific question. Maybe of someone you trust, maybe of Google, maybe of StackOverflow. And, not "how do I build this site", but "I've decided to build a thing in {framework}, and I know part of it should be {thing}; what's the minimum first step to achieving that?"
Another big part of professional coding is breaking a big problem into bit-size pieces. This can be "how do I get the first nibble?" (spiking out some minimal functionality) or building a whole dining plan (mapping out what you want, then implementing it piece by piece). And when planning, figure out exactly what you don't know first - even if you just document it with...
Do the thing (????)
Writing out pseudocode helps, too. Like when you know what you want to do, but have no idea what you need to do it...
For each bite in bites (how do I get the collection bites?),
Masticate bite (look up how to masticate things?)
Swallow (is there a library that handles swallowing masticated bites?)
Deliver waste to toilet (does my environment support toilets?)
Put something like that in a comment, then start writing code around it.
Meanwhile, I've been doing this for almost 30 years - only 17 professionally. Doing things does get a little faster as you build knowledge, but the process is basically the same: find where you want to be, or at least the rough direction, and take a step. Repeat until you're there. And, no, it's not going to be fast; it's going to take work.
On the up side, when you're spiking something that isn't for immediate production, you don't have to fully understand what you're doing. You can build a spaceship out of trash, then work on replacing the trash piece by piece when you've got something that'll actually take flight (but before you get in it, of course).
Last bit of advice: never underestimate the power of rubber-duck debugging: explain your problem to an inanimate object to the best of your ability, taking into account how stupid a rubber duck is. Look for holes in your explanation - things the rubber duck might na√Øvely ask you - and find answers for them. Nine times out of ten, the duck will inexplicably solve your problem for you (or, rather, you'll have figured out the problem by walking yourself through it, inspecting the pipes as you go).
And remember: you don't have to know everything; you just have to know how to research things and apply them. Never feel bad about using a tutorial or hitting up a search engine. They're tools of the trade.
Hell, I've forgotten more about programming than I currently know. I cut my teeth on x86 assembly, but I couldn't pull more than, like 5 opcodes out of my ass right now. I came across a piece of code I wrote two weeks ago, and it took me a full five minutes to remember what it was supposed to do (and like a good little remorseful idiot, I started dropping comments all over it so I'd remember more quickly next time).
It ain't easy, but that's why it looks like magic to non-programmers. And it also ain't hard; it's just work. You've got this.
[Edit: just realized 'spike' is probably jargon. A spike is code you write for the sake of understanding the problem, and that you'll probably throw out or re-write with lessons learned. To spike is to write a spike.]
Learning HTML/CSS is basically learning the rules/language for formatting a document. Meanwhile JS is an open-ended language of logic and data structures that allow you to express any logical process or algorithm. JS is ‚Äúinfinitely deep‚Äù - there is always room to be a better programmer, and the skills and thought processes carry over to other languages too. I feel like I kinda topped out on skills/interest in HTML/CSS years ago but I‚Äôm still becoming a better JS (and now Typescript) programmer every day (14 years on). So don‚Äôt beat yourself up, it‚Äôs hard! Just keep writing code and it keeps getting easier.

Comments from https://www.reddit.com/r/learnprogramming/comments/gcqw3w/to_any_of_you_confused_by_recursion_i_found_a/:
I was watching a video by Kevin Naughton Jr, and he gave the clearest analogy for recursion I have ever seen in my entire life.
Imagine you magically teleport into a movie theater and are placed in some arbitrary row. The seats in front of you are just high enough so that you cant see how many rows are in front of you.
How do you figure out what row you are in?
Tap the guy in front of you and ask him what row he is in and add 1 (1 row higher than the person in front). If he doesn't know, he will tap the person in front of him for his row. If the person in front of him doesn't know, he will ask the person in front of him... This will keep going on until you get to the person in the very first row of the theater and he will definitely know that he is in row 1, so he will tell the guy behind him that he is in row 1 and now the guy behind him knows he is in row 2. He tells the guy behind him that he is in row 2, so the guy behind knows that he is in row 3. As you keep going up the row starting from n, the guy above is in row n+1.
This is the explanation I needed when I was in highschool learning Java. Well put
It is a pretty good analogy.
However maybe it is just me, but I get the concept of recursion, but I still find it hard to use them in my codes (I have just started learning this year, so I hope it get easier in the future).
While this is a nice analogy, I think it doesn't capture the more important recursion use-case which is divide and conquer. I raise you this analogy:
You are tasked with counting how many people there are in the world. How do you do that?
Well, you ask all the countries how big their population is and add it all up. How do the countries count their population though? Well, each country asks all the counties, adds those numbers up and answers you. How does the county figure out the answer though? Sure enough, each county asks all the municipalities, each municipality asks each of its districts, each district asks all its houses, each house asks each of appartements in it. And finally, each appartement knows how many people live in it.
I wish i would have read this comment a few weeks before while I learned about recursion and left that after being frustrated with that concept....hats off mate, Thank you so much
Good analogy!
(Warning, long post trying to explain recursion)
To build on this and try to generalize it back a little bit there are three important things that were done here: Thinking how to reduce the problem to something simpler (Asking the person in the seat in front of me), mitigating the difference between their answer and my answer (adding +1) and finding the base case (the person in the front row).
the reduce and mitigate steps together are usually called the recursive step.
To rephrase the recursive step, it basically means: I don't know the answer for my problem (which row I'm in), but if I could get an answer for something else (which row the person in front of me is in), I mitigate the difference (by adding +1 to the answer I got from the person before me) and get the result.
The base case is saying: There is some case that does not require asking anyone else for the answer (The person in the front row) so if I reach it I can know the answer for other cases using the step.
When programming it usually looks something like:
For a more common example of recursion, now with this concepts in mind, Here is the factorial function with the input number n:
The base case: I know that for the number 1 the result is 1
The reduction: If I know what the result for factorial of n - 1 is, I could calculate the result for n by:
The mitigation: take factorial of n - 1 and multiply it by n
Fibonacci:
The base cases: we have two!
For 0, the answer is 1
For 1, the answer is also 1
The reduction: We need to ask two questions!
If I know what the answer is for Fibonacci of n - 1 and:
If I know what the answer is for Fibonacci of n - 2 then:
The mitigation: I could add the two result to get the answer for Fibonacci of n!
Is a number odd and is a number even:
odd:
The base case: I know that for the number 1 is odd
The reduction: If I know whether the number n - 1 is even or not
The mitigation: I know that my number, n, is the opposite of that
even:
The base case: I know that for the number 0 is even
The reduction: If I know whether the number n - 1 is odd or not
The mitigation: I know that my number, n, is the opposite of that
This came out much longer than I intended, but I will post it anyway hoping it is useful for someone.
Just imagine recursion as Matryoshka Dolls.
What‚Äôs so difficult about recursion? I honestly think people jsut over complicate it. It‚Äôs just a function within its own logic. So it call itself and keeps doing it until a given condition ends it.

Comments from https://www.reddit.com/r/AskProgramming/comments/8oomhi/how_do_programmers_remember_so_many_programming/:
Hi guys, 18y/o newbie here. I started getting into programming and coding around a year and a half ago, studying on my free time from high school. I read around some CVs and some people seem to have worked with every known programming language out there.. My question is: how??
You don't work with them at the same time. Most projects are mainly one, maybe two languages (luke a SPA where you have 50/50 JS and whatever you run server-side).
But if you do enough projects the list can get impressive.
You just have three o four languages which you remember straight without looking at the docs and which you feel yours and, for the other ones that you use once a year, it is a matter of understanding the idiomatic way of doing things in that particular language and then google the syntax if you don't remind it.
It is like maths: you don't remember long formulas by heart, but you make yours the art of problem solving.
Finally you have to consider that what it is written on a resume doesn't necessarily mean that I am the existing most proficient coder in that language, but that I have or have had an experience with it and it will be easy for me to bring it on again.
You don't. You learn the basics and then remember enough so you can google it.
I lost count of how many times I googled "String to Int Java"
You know why people can memorize all possible pokemons but hardly something more unusual from periodic table? Because they use it. You will experience how much you can memorize if you simply work with these things. Don't worry about remembering everything, you will do it automatically over time.
That's our secret, OP. We're always confused.
Brains are for thinking, not for remembering. That's why we have StackOverflow, Wikipedia, cppreference, Javadocs, MSDN...
We don't! The confusion is normal. I recently went back to C after using mostly Scala for a couple of years, and I forget semicolons all the time.
I remember time I used C, Python, Scala, Dart, JavaScript, Perl, PHP and Java all in the same month, and the one thing I keep having to look up is foreach syntax.
Firstly, most common languages share some huge similarities, with often few or even no syntax differences for structures such as conditions or loops, and even when there are differences on those, concepts remain the same.
You also work with few languages at a time, you're not doing one line of javascript, one line of c++ then 1 line of python (or it's really a weird project).
And most of all, if we don't use a language for like 6 month, we forget a lot, but we have google :)
The big intimidating thing when you first start out is the feeling that you're going to have to learn all these crazy, abstract concepts (loops, functions, control, variables etc) and all this crazy alien syntax, and then when you want to learn a new language, doing it all again.
The thing is, nobody tells you that the vast majority of languages all use virtually identical concepts and structures, with very little variation.
I found that once I'd learned C#, learning new languages wasn't even vaguely intimidating, because pretty much all that changes is the syntax.
Trust me, it gets way easier.
You don't remember syantax or different languages. It's all about the concepts of programming. A loop is a loop in any language. A variable assignment is the same too. Once you know the concepts you can google how things are done in the language you need to know about.
I get confused all the time and I am fine with that.
In the last 4 days, I used JavaScript, HTML, Python, Bash Shell Scripting, and Java. I forget the length of an array/list all the time. But the thing is that actual lines of code developed is actually not that great.
But in the end, looking something up isn't that hard. And the squiggly lines in Intellij or PyCharm will let you know what's wrong and you can just try another method. And despite what I thought when starting out, and what mostly people start out think, the actually writing of code isn't something you do 8 hours straight. A lot of looking, debugging, etc.

Comments from https://www.reddit.com/r/Frontend/comments/15uiyfe/confused_computer_science_student/:
Hello, I am a student who has completed the 1st year of Computer Science this year.
I want to choose a field and improve myself until I graduate in that field by getting internships, creating projects, getting certificates etc.
However, I am really undecided about which field to choose.
I'm interested in visual things and I really care about this. If I didn't study Computer Science, I would like to be a graphic designer. I am using programs such as Photoshop, Premiere Pro for a long time. In fact, I had a nice NFT project in 2021 and had really good sales. Because of these, it seems Front End would be a good choice for me, but I have some concerns.
As far as I can see, many graduates from departments that have nothing to do with Computer Science work in the Front End field. As I saw this, I started to think like "Isn't the knowledge taught in Computer Science important for Front End? Am I wasting time studying Computer Science then?"
This is my two cents as someone who completed a bachelor on translation studies, as AI was our most controversial topic regarding translation‚Äôs future as a career. I‚Äôm a bootcamp frontend dev like many people here, I guess.
I don‚Äôt think it will replace humans anytime soon, that‚Äôs a way too big and serious claim tossed out way too easily imo. However, it will and already started -eliminating the need- for the people at the lowest scale in terms of adaptability and skillset. I wanna say eliminating the need, because there will always be people who get lucky and land jobs in such state.
So with that, I suggest you stick to whatever you think, at this time, that you‚Äôll be doing five, ten years later without complaining.
Another bootcamp dev here; 6 years experience as a full-stack dev at a small business.
IMO, AI is going to have a hard time replacing subjective work, like front end *design*. Github CoPilot already suggests code to me as I type in VSCode... but what it doesn't do is suggest how to design a user interface that is easy to use, functional, and aesthetically pleasing to my fellow human beings. I think it will be much easier for AI to replace backend developers, since they aren't concerned with aesthetic decisions.
Speculation about AI job replacement aside, I would stick with front end if you're skilled at both graphic design and coding. You could end up miserable if you're working a backend-only job that doesn't involve graphic design in some way. Instead, you could be extremely valuable as a technical person who is also a skilled graphic designer.
3rd yr comp sci student here. I'm not the most knowledgable and have yet to work in the industry. But happy to share my experience and knowledge.
Don't look at salary. It's such a broad field that you can afford to do what you enjoy. Would you rather work 9-5 doing something that you hate or are not passionate about, or would you rather take the 10-20% (pulled this number out my ass as an example) pay cut to enjoy what you're doing while still earning comfortably.
If you haven't yet worked a full time job that you didn't like, then let me tell you it sucks big time.
Keep in mind front-end isn't just graphics design with CSS. There's a bit of everything. You have to know a bit of backend to know how the frontend you are working on interacts with the backend, databases to know how the form you implement in a web page sends info to the API, etc. (Don't make me start on JS, I need to learn some frameworks but have been dreading it because my interests lay in moreso backend related stuff) Even if the company you are working for is big and hires enough people to take care of backend/databases, when you are working on your portfolio you will still have to learn basic backend (essentially fullstack).
You're only in 1st year. Choosing an area to specialize in is probably the most difficult thing to do, atleast it is for me even now. You have plenty of time to decide what you want to do. Spent some time learning different technologies, most importantly is to have fun and study something that you are interested in. 95% of a comp sci degree is extra-curricular study which then leads to specializing in what you vibe with the most. Try everything, make projects, make websites, learn some stacks that you are comfortable working with.
In the end once you graduate, all you need is a strong portfolio, good GitHub history and contributions, then all that's left is DSA/leetcode for the coding interview and your diploma.
Hope this helps!
Side note: have fun and enjoy uni!
I believe frontend is only going to grow deeper with the advent of AI. It‚Äôs already so rich as a specialty and to do it well requires a lot of knowledge and experience. AI is a very helpful productivity tool but I don‚Äôt think it will replace human decision-makers and software engineers in our lifetime. If you didn‚Äôt understand what and how you‚Äôre trying to accomplish how can you expect chatgpt to solve it for you?
You‚Äôll be paid for your knowledge and subsequently your timely and effective solutions. And you will have to continually learn and adapt to the rapidly changjng environment of tech. In that regard I say focus on what you‚Äôre really passionate about within the field and you‚Äôll do just fine :)
Hey there. I have a bachelor's in C.S., about 10+ years work experience now as well.
A CS degree is mainly going to focus on how languages/compilers work, run-time complexity / algorithms, and how computers work from the ground up. Frontend work certainly benefits from some understanding of these topics but overall wont be too impacted.
Is a CS degree worth it for only frontend development, probably not if you are footing the bill for the degree but if you enjoy learning than so be it. I would disagree that front end devs are making more though. At small to medium sized business, a lot of the front end work is done by junior fullstack devs because its less complicated and typically less costly when things go awry. At big companies, you might see just a front end developer positions, but they are more rare from what I've seen.
Point is, yes its overkill for just frontend. However, I don't think you should just limit yourself to just frontend work. It is nice to swap things up, do some frontend some days, then logic the next. Secondly, you just have more options job wise down the line.
If you are footing the bill on your education, I would quickly make a decision if you enjoy the logic/math side of CS, or at least can tolerate doing it some days. If you don't like it, just do a bootcamp imo for way less cost than a 4 year. If you aren't footing the bill, I'd 100% get the CS degree to have more options out of the door.
There's nothing wrong with doing computer science and getting into Frontend. It'll actually give you an edge, imho. A comp-sci degree will get you into more engineering stuff, though. If you want to do the visual stuff, you might want to look at getting a minor in graphic design or something like that.
If you don't care about engineering at all and just like making cool user interfaces, you ought to look into a more UX focused program. UX Developer, UX Designer, that kind of thing.
I was probably 11 or 12 when I decided "I want to just make websites all day". I didn't care about engineering, so I got a BS in "Management Information Systems" (which is basically comp-sci but with business classes instead of math). I later got an MS in Human Computer Interaction Design (which is usually called UX design these days). I've been "just making websites all day" for at least 15 years. Turns out I don't like programming too much, and I'm now in management. However, in my later years as a front-end dev, I would have killed to have a more engineering background. IMHO, if you're programming all day, an engineering (comp sci) background would really help.
That being said, there are a lot of very successful front-end devs who just went to a bootcamp or something. So, it's kind of a crap shoot. You don't NEED to know engineering to do front-end. But front-end is also becoming more specialized. You have the guys coding the guts of the frontend and doing all the business logic, but you also have the guys coding just CSS to make things look good. It's all valuable and there are all kinds of specialties.
As for AI, I don't think AI is going to kill any professions. What will happen is that there will be 2 kinds of developers: Those who use AI to help with their work and those who don't. The AI-enhanced developers will end up succeeding. I encourage my team to use AI in their daily work. It doesn't do the work for them, but it helps in solving problems, trouble shooting, and getting them started down the correct path.
I say, do what your heart tells you, but keep your options open. It's much harder to switch to different industries (like video games or what not) with just FE experience. You'll probably be stuck as a web-dev for longer than you might like. (But if that's your passion, maybe that's a good thing).
Front end or web dev overall is the most popular option for people getting into tech with or without degree and that's why it's very saturated though still alot of jobs are there but the competition is also there also in my opinion and in opinions of industry experts this is probably gonna be the first field to get taken over by AI it's already happening you mentioned you have experience in NFTS so why not go for web 3.0 Dev , Blockchain dapps etc
Software engineer here. ~8 years of experience. Mostly in cloud infrastructure but also web application development.
Do what you're passionate about (and what you can get an internship in.) Computer Science is still useful for frontend, especially when you start getting into the realm of huge frontend applications (like Facebook's frontend) and facilitating large numbers of frontend applications. There are also lots of jobs where having the ability to do some frontend is a huge value-add -- being able to quickly put a good interface on top of a tool is an *incredibly* useful skill.
If you want to work on anything web-related -- and cloud infrastructure is very much web-related -- having a really solid handle on meat-and-potatoes website building will make it way easier to grasp the complicated backend stuff, because you'll understand what those features are for. Platform stuff can get pretty abstract. A new grad with a CS background and a passion for frontend is the ideal hire for some jobs at places like Heroku -- with both of those skillsets you'll pick up the details of cloud infrastructure much faster than someone with just one or the other.
Also, people change specialization all the time in tech, especially in the first ~5 years of your career. It's much more important to develop skills that are broadly useful and that you enjoy using. Computer Science is 100% in the broadly useful category, but so are HTML & CSS and the general structure of GUIs.
"Isn't the knowledge taught in Computer Science important for Front End? Am I wasting time studying Computer Science then?"
It is. And you are not. The thing about computing science in general (or software development, more specifically), is that the nature of the field means that you don't really need to have a formal education in it to learn the skills and land a job. The amount of available resources online make it possible for anyone with enough drive and interest to learn how to code. The same can't really be said for most other fields. This is why you see people from other disciplines in software.
I would argue that the flipside of this is that, if those people from these other fields decided to put in the work to enter the software industry, isn't that a pretty good reason to stay in computing science? It's obviously better here than it was there, at least to them.
Computing science teaches you a lot more than just how to code, it teaches you how to think about code, which is a much more important skill.
At the same time, as artificial intelligence develops in the future, I feel as if it will effect badly the front end field. Of course, there will still be front-end developers, but I think there will be a decrease in the number of jobs in general. Because of these, I started to think about whether I should head towards the backend or cloud field.
Again, this is just my opinion, but I believe that back-end development will take a much bigger hit from the emergence of AI than front-end. Front-end is all about designing something that looks good and feels good to interact with, while back-end is much more mathematical and algorithmic in nature. AI is much better at math than it is designing things, at least for right now.
By the way, when I looked at the salaries on the "ziprecruiter" website, I saw that those working in the front-end field in the USA were paid more.
Salaries vary wildly from place to place. So does cost of living. You'll make 200K a year starting in the San Francisco Bay Area, but you're also paying 4K USD in rent every month.
In short, my heart is telling me to choose the front end and do visual stuff and make websites all day. My brain says to choose an area where you will use all the information that you learned in Computer Science and an area which will have brighter future.
You don't actually have to make this decision any time soon. You can learn as much as you can about both fields, and then maybe you end up in a full-stack role anyways.

Comments from https://www.reddit.com/r/electrical/comments/1ckgb7k/confused_on_code/:
Hi all, we‚Äôre in CT and have redone our kitchen. Our electrician says we need a gfci on either side of our sink (along with the outlet that is below the sink for the garbage disposal, etc). We just installed a window that doesn‚Äôt leave much space for an outlet so we thought we could do one on the pantry side (left) and one in the drawer on the right. Our electrician said the one on the drawer doesn‚Äôt count. I‚Äôm just confused as what the requirement might be and if we just need to make two holes in our counter to add outlets to match code. Is there a way to counteract this somehow? Thanks
Need countertop outlets every 48". The way the code is written, one outlet will cover 24" to its left and 24" to its right, so for an unbroken countertop length you need one every 48" max. The reason is that typically countertop appliances have 24" cords.
Any countertop length 12" or wider requires an outlet.
The outlets must be served by at least two 20A circuits.
All countertop outlets must be GFCI protected.
These are classified as small appliance branch circuits, so they are intended to supply power to small appliances: toaster, coffee maker, blender, etc. So outlets in pantries or drawers or whatever don't count because they cannot be used for small appliances along a countertop.
Edit: your authority in the area can have more stringent codes in addition to the nec codes above.
You can‚Äôt have it in the drawer, it has to be above the counter, you can however put a ‚Äúpopup‚Äù receptacle in but they are ‚Äúpricey‚Äù
The edge of the sink is considered the start of a new section of countertop. You must have a receptacle within 2‚Äô of either side of the sink, above the counter. At my home it was impossible to wall mount these due to the window being 5‚Äô wider than the sink. I installed pop-up receptacles. They really weren‚Äôt that expensive. Bryant makes nice ones that have wireless phone charging built in to the tops of the pop ups.

Comments from https://www.reddit.com/r/learnprogramming/comments/1777633/whats_the_most_confusing_programming_language/:
Basically what the title says. A very confusing programming language.
The most confusing programming language that wasn't designed to be intentionally confusing is probably APL, primarily because it uses special characters but also because it uses multidimensional arrays as its primary datatype. For example, this is a line of APL code taken from the wikipedia page:
life ‚Üê {‚äÉ1 ‚çµ ‚à®.‚àß 3 4 = +/ +‚åø ¬Ø1 0 1 ‚àò.‚äñ ¬Ø1 0 1 ‚åΩ¬® ‚äÇ‚çµ}
Back in the early 80s my dad worked with a guy who wrote all his components in APL. He even had a special keyboard so he could type the special characters more easily.
++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.
In Brainfuck, that prints "Hello World". Brainfuck is the classic for this question.
https://en.wikipedia.org/wiki/Brainfuck
As u/UniqueID89 said, Malbolge is equally ridiculous. Here is their "Hello World"
(=<`#9]~6ZY327Uv4-QsqpMn&+Ij"'E%e{Ab~w=_:]Kw%o44Uqp0/Q?xNvL:`H%c#DD2^WV>gY;dts76qKJImZkj
https://en.wikipedia.org/wiki/Malbolge
C++
On the surface it's not too hard to learn, but there are so many subtleties with how various features interact (usually related to memory management) that even people with 10+ years of professional experience with C++ admit that they don't really understand it all.
Add to that a Turing-complete templating system PLUS the C preprocessor...
setting aside deliberately obfuscated ones like malbolge
personally i've never gotten the hang of haskell
and the deep intricacies of templates in c++ can get pretty arcane
Malbolge.

Comments from https://www.reddit.com/r/learnmachinelearning/comments/18st3ky/how_do_you_explain_to_a_nonprogrammer_why_its/:
to me it seems that AI is best at creative writing and absolutely dogshit at programming, it can't even get complex enough SQL no matter how much you try to correct it and feed it output. Let alone production code.. And since it's all just probability this isn't something that I see fixed in the near future. So from my perspective the last job that will be replaced is programming.
But for some reason popular media has convinced everyone that programming is a dead profession that is currently being given away to robots.
The best example I could come up with was saying: "It doesn't matter whether the AI says 'very tired' or 'exhausted' but in programming the equivalent would lead to either immediate issues or hidden issues in the future" other then that I made some bad attempts at explaining the scale, dependencies, legacy, and in-house services of large projects.
But that did not win me the argument, because they saw a TikTok where the AI created a whole website! (generated boilerplate html) or heard that hundreds of thousands of programers are being laid off because "their 6 figure jobs are better done by AI already".
Writing code is the trivial part. Figuring out what code to write is the hard part. LLMs etc. right now are good at understanding the syntax of code and translating small, general needs into code. But it still needs an explicitly defined context by the programmer. If a model should even be able to do the job of the programmer, we would have to include the AI in all the knowledge gathering (etc) that leads up to the coding, not just the coding itself. And in that case, the AI would still need a programmer to assure that the code works as intended.
How do you explain, to a non-programmer why it's hard to replace programmers with AI?
Well, all mathematician were replaced by calculators, so it's just a matter of time...
ChatGPT is great for small programming tasks. Let's say you need to implement an algorithm in a language you are not that familiar with in your project. GPT will then be able to give you a generally good solution, from there you need to fix up on some errors and modify it to work with your specific need. This is much faster compared to using google and looking through old forum posts (at least most of the time, but not always the case).
The programmer would still need to do a lot of coding, but GPT becomes a good tool for saving time.
You know the old trope where students procrastinate on a research paper in college? Hours before it's due a student will finally begin writing. They completely bullshit their way through it based on a few references they found online, and toss in lot of filler text without any consideration to the structure, the flow, or the cohesion. Ultimately, it's a passable paper without much meaningful information (or interpretations that offer additional insight).
That's where some NLP/Generative AI is today. Except it has an advantage a student doesn't, in that it's not being graded, and it can plainly plagiarize a lot of content without consequence. A poor paper can seemingly indicate comprehension, but with programming you need the structure, flow, cohesion, and meaningful interpretations. Generative AI isn't really great at inter-relating the purpose of concepts on a constructive level (although informative, and generative, not really constructive).
This is really a terrible analogy, but it's the best one I could think I would share with somebody who doesn't understand AI.
When Microsoft Excel came out it was said that it would replace accountants. I just stopped trying to convince people. Funny enough, the general trend around me is that people who are well educated seem to do their own research and reading about AI and come to their own conclusion that they don't think it'll replace actual programmers anytime soon. People who just like to parrot what other people say and don't do their own thinking are usually the ones who argue that I'll be out of a job soon.
Non-programmers often have poor understanding what job of a programmer even is. They usually imagine that it involves a lot of code writing, and it does, but it's sort of like saying that accountant is someone who writes the sum under the line or engineer is someone who draws lines on a paper. That is the final product of the work, but not really the meat of the job.
Software development is a job of abstract problem solving where you take the demands of a customer who doesn't really know what they need or want and turn it into a product that does what is needed. Job description often boils down to "we have this thing here, I'm not sure what it's supposed to do or how, but it's broken, make it work". State of art AI can't really give you anything on a task like that.
I do think that AI will be increasingly more useful for all sorts of work, including software development, but at the end of the day, it's just another tool enabling to get more done with less effort. There aren't many jobs that best AI today could just outright replace.

Comments from https://www.reddit.com/r/learnprogramming/comments/w18pav/programmers_isnt_learning_new_programming/:
Thanks for the helpers
No, the opposite. Languages share a lot of stuff, and the logic part is pretty much the same. Learning new languages is very easy when you know how to program, if you don't remember some syntax, you can just google it.
Nope, it's actually much easier because the fundamentals of programming remain the same
No - the difficult part is learning a new paradigm of programming.
Going from procedural to object oriented is a leap. As is going from one of the former to functional or the other way around. It's learning new concepts and ways of getting stuff done that require some mental reshaping, everything else is just syntax.
Yes, and no.
On one hand, there are differences that make it confusing, especially with languages with similar syntax. For example:
// Java
for(int x=0;x<10;x++)
// JavaScript
for(let x=0;x<10;x++)
Going from JavaScript to Java, you might forget the int.
On the other hand, once you know you need a loop, all you need to do is to find the correct syntax. You can even Google "for loop in JavaScript" to get the syntax.
I tell my students that coding is the easy part - solving the problem is the hard part. In other words, knowing you need a loop is hard, writing the code out is relatively simple.
It depends. It's fairly easy to distinguish most parts in my head. I'll occasionally mix up what a function is called or what its order of arguments is because multiple languages have the same function (like join). This is rarely an issue though.
The one that gets me is parenthesis placement for function calls. I spent years writing Clojure that has function calls that look like:
Whereas almost every other language in existence use the typical syntax:
That took a while to relearn. My fingers refused to type function calls properly automatically for a good like week after switching to C from Clojure.
TL;DR Yes, but only if you are new to programming.
I'll keep it short as most of it is explained by other. When you learn your first language I recommend not switching unless you have a general grasp of how programming works.
Programming is mostly knowing certain concepts, and these concepts are learned the easiest if you don't have to think about syntax all the time. Once you have a good understanding of these concepts (classes for example) then it is easy to switch out to another language and just Google the syntax.
No

Comments from https://www.reddit.com/r/learnpython/comments/1cqgsbk/oop_is_really_confusing/:
Mainly because I don't get it's purpose. Functions are just fine.
I assume when I get more advanced, I will understand. According to my understanding, I will attain beginner level as I have finished CS50P and am learning from Python Crash Course.
The CS50P lecture for OOP felt really rushed for a beginner. From where could I study this concept that is detailed enough for me to understand it?
One of the ways to understand OOP is that it lets you create new types. That is, a template for creating objects with bundled data/state and functions for working on that data.
Think about the types you use already. You know there is a str type with methods like .lower(), or a list type with .sort(), and so on. Clearly having types and methods is useful. How do these types and their methods come to be? OOP.
Of course, the idea of creating types isn't exclusive to OOP, nor is OOP limited to merely that idea. But it's a good start to understanding its purpose.
The worst part about trying to learn classes is that all the lessons and tutorials are like "let's make a Car class! A car has a color and a number of wheels and a make and model and year; a car can Go or Brake or open the door etc etc etc" but in reality you're never going to code a class for something so discreet and tangible.
Oop is how you contain or encapsulate attributes or methods that describe what an object is or does.
Sure you can write a library using ALL functions. But why would you import things about a car individually, for example. I wouldnt want my import line to be
"From car import fuel, battery, AC, drive, refill,..."
Its just too much when I can just import the car and call the methods that pertain to what the car does. Now add more cars, your library of just functions might be ok, but when you go to define gas2, AC2, gas3, etc. It gets really out of hand when you can just access a particular objects method to adjust characteristics.
Abstraction is when you have methods or things you want hidden and not called from a user. Python is a little weird about this, because you can just as easily access it by calling it: print(car.passkey) like the door padlock makes it rather insecure. In fact, I believe you can even call constructors using this if Im not too rusty, which will likely not cause many problems, but is not something youd typically do.
Polymorphism/inheritance is nice because imagine you have logins to a webpage, where EVERYONE can view webpages. So you may create a single method for the user class that allows them to view some shared attribute: the home page. This way, guests can also view without login. However, you may want to elevate a user's priviledges, so you make an admin class but dont want to duplicate your code to let the admin view the homepage, so you inherit from a user. However, maybe this was someone that used to not work for your codebase, so they were originally a user. Similar to the constructor recall, you wouldnt necessarily want to reinitialize this person as an admin, but rather just elevate the permissions. So this is great because you can keep the parent class type, "User", and change this person to an "admin".. again, i think something like this is better demonstrated in a language like Java, but the principle is the same where you basically overload and represent the person as a user initially, and at some point grant them or "elevate" them to the respective subclass.
For fun, lets say this admin gets fired or quits You may not want to delete all their data because they are a valuable customer, so you cant risk deleting their account and creating a new one for them, and copying all their data to a new account without admin perms is an expensive operation. This is the beauty of polymorphism and abstraction, where you set private attributes the user cant access, such as their admin/user rank, and can toggle this aspect as the developer so that they keep their account data, but the person no longer has access to those admin methods and attributes. However, theyre happy because they keep user data such as normal login, shopping carts, etc.
That is the power of OOP, with examples. Now imagine the code base for doing this without oop, and ill tell you it wont be long before you want to just give up because of all the functions, assertions, etc youd need to write to get even a fraction of the functionality of what OOP would do here in maybe just a couple hundred lines.
It's okay if you don't get it. It's not really important for surface level Python programming. However if you'd want to write libraries and modules of your own you **willl** use OOP. Just know how it works and the syntax is super easy.
I don't get it's purpose.
Classes are a way (but not the only way) to organize complex code.
Many people (but not all) who write large programs think this is a good method of organization.
Beginners have a hard time understanding the usefulness of OOP (the "why") because they don't have any experience trying to organize large projects.
good explanation here: "When to use classes in Python? When your functions take the same arguments"
bad explanations are stuff that go on about "Car inherits from Vehicle" or "Dog inherits from Animal", these are an old 90s cliche and have nothing to do with how OOP works in the real world.

Comments from https://www.reddit.com/r/learnprogramming/comments/1fedwtu/i_am_confused_if_i_can_code_at_all/:
I am in my 4th year of engineering. I really would like to secure a nice job before I graduate. I am terribly anxious as people I know are getting job offers already, and it is emotionally draining. I don't know where to start from.
For starters, my logical thinking is good but I can't seem to apply it to programming. Like when I look at a problem statement, I get so nervous, I immediately start looking for solutions. I started with web development. I also started making projects with the help of guided projects on Youtube. But I never completed any because it gets very tutorials at one point. I even tried making some projects of my own, but I left it midway as I was not confident with my code. I always felt inferior and full of peer pressure. I don't even know if it is correct for me or if it is something I want to continue doing in the future.
So should I still keep trying to code programs and make projects, or is it something I should give up?
This sounds like a psychological issue, you ought to talk with your school counselor about to see if they can help you.
Do some leetcode, this would be a great start

Comments from https://www.reddit.com/r/learnprogramming/comments/1c61616/confused_and_stuck/:
I am watching Love babbar dsa playlist of 146 videos...it has 250+ questions solved in his videos....so should I watch only his videos and try questions that he explains in his videos and later complete the entire playlist in this way... and after completing the playlist then should I solve LeetCode problems
How long have you been learning, what languages do you know, and what projects have you built so far?
Don't study DSA until you're comfortable coding in at least one language and you've made some projects by yourself without following a tutorial.
When you're ready for DSA, start with a structured course with lessons and exercises.
After that's done, if you want to practice for interviews, go for a DSA playlist and leetcode. Not before.
C and c++

Comments from https://www.reddit.com/r/CodingHelp/comments/t0n582/new_to_coding_confused_about_what_is_wrong_in/:
tab lines 6,13,20
I was like no way this is javascript
As an FYI, the answer will be case-sensitive. So if the person entered Central Processing Unit instead of central processing unit, it‚Äôll mark it wrong. You can use the .lower() command after the input string to avoid that. So line 3 would be answer = input(‚ÄúWhat does CPU stand for?‚Äù).lower()
Python will convert every letter entered to lower case to avoid any correct answers being marked as incorrect due to a capital letter
Have you googled the error code? That's always my first step if I'm stuck.
Put the score accumulator inside the if statements as well otherwise it will always be incremented, and not just when u get the answer correct

Comments from https://www.reddit.com/r/CodingandBilling/comments/1aevfoa/confused_about_what_certification_to_take/:
Hello all. I had a few questions to ask, first and foremost I am looking to change careers I only have a highschool diploma. I was looking into medical billing or coding. I want to work remote. This lady I know wants $700 for a course to get a CBCS certification. Is this certification valid? Also is there any other certification I can get instead of that? I‚Äôve looked into CCS is that the better certification? I‚Äôm all just really new to this and need guidance from those who actually are in the field. Thanks a lot!
Highly recommend CCS.
The CBCS is the equivalent of getting your GED. If you have the option, you always want to go with either the CCS or CPC,CRC, or COC depending on your interests.
I started with a CBCS which is Certified Billing and Coding Specialist. It's the very basics of billing/coding. Billing is usually a high turnover, and they're not paid nearly enough, and I'm not sure you need a certification for that??? I now have my CPC and my coding specialty is cardiology. I've only the basic knowledge of the billing aspect. It is hard to do, but if you want it, you can do it. Finding a job with no experience will be the hard part. It will be low paying, but as you get experience, you get the higher pay. Check at AAPC.com or AHIMA.com for your different options.
I am looking to take the billing and coding classes. Any suggestions?
CBCS is a waste of time and money. Go for CCS or CPC. These are harder to get tho. Medical billing doesn‚Äôt have as many remote options usually. Coding is where it‚Äôs at. Plus you make more money as a coder.
I‚Äôm in the same boat. I‚Äôm very interested in the answers you get.
I‚Äôve never heard of the cbcs certification. I‚Äôve only seen employers asking for an Ahima or AAPC certification. So I would go with an organization that is more widely recognized.
As a newly certified CPC, everything I see wants AAPC certification. But I can tell you there seems to be a lot of people applying to very few positions!  But good luck with whatever route you choose 

Comments from https://www.reddit.com/r/github/comments/1d9xaw3/im_a_confused_noncoder_i_need_of_help/:
I have a problem I'm trying to resolve for a client and can't tell if I've found a solution on this github request. OP's comment referencing the request's status change to closed makes be think someone was working on this solution, but I cannot tell if it's been dropped, completed, or in limbo.
If it is completed, how would I go about implementing this? I've set up child theme for my website and have added various strings to functions.php but nothing to this extent.
There's no reason stated for the close, it looks like it's abandoned though. You can use the branch if you want and figure out how to use it from source

Comments from https://www.reddit.com/r/learnprogramming/comments/1cfq6vy/feeling_confused_as_an_upcoming_sophomore_in/:
Hello, like the title says, I'm an upcoming sophomore in college currently double majoring in computer science and statistics who wants to get into data science. I learned the basics of Python my first semester in college, just the basics as it was an intro to programming class, and then I learned data structures and algorithms in Java my second semester. Now, I'm seeking advice on what to do over summer. I want to start coding projects but I have no idea how to and don't believe I have the proficiency to do so. To further build my knowledge, should I look at project tutorials on Youtube and replicate what they're doing?
I was thinking of learning SQL at a community college and taking Harvard's CS50's Introduction to Artificial Intelligence with Python. I've heard mixed feedback about CS50 courses, which all look very interesting. Are the CS50 courses worth doing to learn new programming languages or should I learn by taking classes in college, or through Youtube, or through courses on websites like Udemy? It seems like I have lots of options, so I want to pick the most efficient way to learn.
Sorry for asking a lot of questions. Programming is so interesting and I love learning new things and having this many options is a very overwhelming.
Honestly, you have enough to start building your own projects. I'm not saying it'll be crazy complex, but this is indeed feasible at the moment. If you're truly interested in data science, consider working on some sort of analysis for whatever topic interests you. For example, suppose you are fascinated by the weather (you sit by your window looking at the rain lol), you could produce some interesting stats such as temperature variability, ANOVA charts, correlations between month and rain frequency, etc. Afterwards, you could write up a short report on your findings with visuals from your analysis.
For context, I used to be a TA for Analytics (worked with Tableau, SQL, etc.).
Note: There's no need to learn SQL at a community college. Trust me when I say this, it's one of the easiest languages you can possibly study. It literally follows this format here:
SELECT <COLUMN> FROM <TABLE> WHERE <CONDITION> ORDER BY <COLUMN>;
Obviously there's joins, group by, etc, but it really doesn't get too complicated. I highly recommend this source for learning SQL quickly: https://www.w3schools.com/sql/
Let me know if you have any other questions!
u/captainAwesomePants posted this link about a year ago: https://data-puzzles.com/
CS50 generally has pretty good courses. You can start and see if you like it. Just because you start doesn't mean you're committed to finish if you don't care for the material.

Comments from https://www.reddit.com/r/C_Programming/comments/1dipbh2/trying_to_learn_c_but_fully_frustrated_and/:
hey i am 17(M) and am from india , i am studying Bachelor's in computer applications , and in my second semester out of 6 semesters, (yearly 2) 1st semester i wasted by doing nothing and just remebring things for my exam , and now in my second semester i have taken studying seriously , but am not able to understand c , can anyone please help me with it , like any good pdf, notes , resources, explanation , yt playlist, it would be great of you for the help ,
What don't you understand ?
Book, The C Programming Language
Just stay away far away from Turbo C and you ll be fine
This is a really good guide
https://beej.us/guide/bgc/html/split/
Good luck
Book: Effective C
Also read other people's code. Best way to learn IMO
It would help to know exactly what you're having trouble with -- syntax, types, library functions, program organization, pointers, arrays, ...?
There's a pretty comprehensive list of references at Stack Overflow.
I have yet to see a YouTube video on C that was worth a damn; a lot of them confidently promote bad information and bad practice.
Try to articulate and recognize what you dont understand no matter how dumb you think it is, asking for more resources would just add more confusions

Comments from https://www.reddit.com/r/AskProgramming/comments/ng3il9/how_to_learn_different_programming_languages/:
Hi programmers! I am a student of computer tecnology. During my university years, I've learned C, C++ and Java. Nowdays I'm studing Python for a project. Sometimes I get confused with Java ( I passed a lot of months in studing it).
Clarely, Python and Java are similar for some aspects but sometimes I am afraid to confuse syntax or declarations...
Have you ever experienced something like this? How can handle studing different programming languages?
I don't know. After the first three they start to seem kind of all the same.
Once you get exposed to procedural, imperative, and OO, all others in that vein seem familiar. Wait till you explore other paradigms that will bake your noodle like:
List based languages like Lisp or Tcl
Logic based languages like Prolog
Stack based languages like Forth
Functional Programming Languages like Haskell and Elm
Any language by Nicklaus Wirth like Modula and Pascal
Systems programming language that is not C or C++ like Rust, Nim, D, Zig
Practice, mostly.
As you use each language more, you learn its syntax and standard library better and make fewer mistakes. Whenever I learn a new language, I end up looking a lot of things up. C, C++, Java, and even Python share a lot in common, so it's often a matter of finding the equivalent keyword or library to do similar things.
If you're able, I find deeper knowledge in one language more useful than shallow knowledge in many. If you can, stick with one and learn it well because it's easier to transfer that deep knowledge to another. Learning too many languages at a shallow depth seems more frustrating than useful to me.
Also, don't be afraid of mistakes. If you use good tools, they'll highlight errors for you to correct. Mistakes are part of the learning process. Keep at it and you'll get better in time.

Comments from https://www.reddit.com/r/AskProgramming/comments/1cldexv/confused_about_career_path/:
I have been programming for 5 years now, and surely I enjoy it. I'm currently perusing my Bsc. Degree in CSE. However, in recent times I'm in a confusing state, as I can not set a clear goal on which career path, within Computer Science, should I consider.
First of all, I do not have any enthusiasm in web-development. I tried game development but I feel like I'm not suited in this sector. Personally, I have to solve problems, recently I tried to create a programming language, and of course it was not something "Next Leve", but I was able understand and write the basic prototype, it was fun!
I am having serious doubts what should I do next. There are so many things, cloud computing, AI, game development, app development and many more. I don't want to just learn and get stuck in tutorial hell. I have not been very much structured from the beginning. I want to fix this as soon as possible. What should my roadmap be?
Any advice is appreciated.
A boring but healthy take if you don‚Äôt have any field that you currently have a strong passion for is to check what is in demand in your area. More specific which companies seem good to work for and what field do they operate in and which tools do they use.
Visit job fairs or reach out to company recruiters on LinkedIn to get a good idea and start making contacts.
In a long career you will probably do several of these things. I've worked in:
Embedded systems
Backend work
Infrastructure/platform services
Unix CLI tooling
Large scale data analysis
Security engineering
Web front-end
Sure, my preferences for sector guide my choices, but my preferences also include, "what kind of organisation do I want to work in", "who do I want to work with", "where do I want to live" and "what kind of salary am I looking for".
If you‚Äôre essentially just drawn to problem solving. Then maybe you could consider giving embedded programming a go - or even game engine development a try?
Start a passion project -- it will guide your tool choices. It will be infinitely better for learning ${tools} than tutorials will.

Comments from https://www.reddit.com/r/Racket/comments/1avpulr/hello_i_am_very_confused_on_how_to_do_this/:
Best advice I can give: Ask your teacher.
Dang, there sure are a whole lot of professors in here!
‚ÄúThis is an individual assignment‚Äù‚Ä¶
Also I‚Äôd be willing to help if you showed me that you‚Äôre putting forth effort instead of asking everyone to do the work for you. You‚Äôre not going to understand this if you don‚Äôt try it yourself first.
I‚Äôd suggest you take a stab at it, and write down SPECIFIC questions about what you don‚Äôt understand, then make a separate post asking one question at a time. Posting the entire assignment is difficult for any one person to know which part is giving you trouble.
Best of luck ü´°. You got this!
Understand that existing code entirely. (Walk through parse and understand the results; then look at eval for simple expressions, and walk through how it works.)
Ask your teacher
Use the design recipe
Ask smart questions in the future to get better help online

Comments from https://www.reddit.com/r/computerscience/comments/sf7cyl/im_confused_i_cant_tell_the_difference_between_a/:
I want to teach a computer to do things based on what I code it to do. What is this called? Is this a Software Engineer or a Programmer? I am confused and don't know where to go with this. I know you can code apps to pick out what the user wants. I'm doing research and the more I research the more confusing it gets. I don't want to be responsible for what things look like, I just want to do all the back end stuff. I just want to make things work. Make it make sense, please. I want to get a job, but don't want to learn the wrong stuff.
I honestly wouldn‚Äôt focus so much on the titles, these can be really confusing as you have discovered. Focus on what a team is doing and what experience you need and that tells more or less the kind of work you‚Äôll be expected to do.
Programmer and software engineer if we pick apart the actual words would seem to mean that software engineers are more in the business of solving software problems in new ways. This can be creating or utilizing mechanisms to write solutions or algorithms creatively. Programmers may be more basic. But the lines are so blurred and I may very well be wrong on my intuition there.
Slightly different words for the same thing. Usually "software engineer" is the formal job title, "programming" is what you're doing. Informally, we call people who program "programmers".
I want to teach a computer to do things based on what I code it to do. What is this called?
It is called programming unless you want to do it well, in which case it is called software engineering. If you want to learn how and why either works, and find ways to improve upon that, it's called computer science.

Comments from https://www.reddit.com/r/cs50/comments/15i4mn0/what_is_happening_here_im_confused_af_why_cant_i/:
That appears to be compiling just fine. What happens if you type ./mariopset1?
Looks like it compiled successfully, terminal shows no errors, and the program is showing up in your file explorer on the left. Now try to run ./mariopset1 and find out if your code runs as expected!
Change for loop condition to i < height
snobbish trees command intelligent wakeful bear shaggy frightening languid poor
This post was mass deleted and anonymized with Redact
if you write ./mariopset1 it will work but your code seems very problematic.

Comments from https://www.reddit.com/r/developersIndia/comments/1fqtg0i/i_want_to_start_coding_but_confused_between_the/:
Should i do java with dsa or C++ with dsa.

Comments from https://www.reddit.com/r/unrealengine/comments/16q2fmp/ue52_confused_about_recompiling_my_code/:
Hello all, Unity Refugee here,
I've played around with UE 4.16 in the past and I just got around UE 5.2.
I have a C++ project properly configured for both Rider and VSCode (using VSCode since rider have an indexing bug that eats RAM) (Live Coding is off)
I build and launch MyProjectEditor win64 Development, everything is fine, my editor lauches. Game working.
I write some code.
How do I recompile my code since the editor doesn't have a compile button anymore ?
Which launch configuration to build with ? I'm stuck with restarting the editor everytime i change some code.
it doesn't make sense and Riticello called me "a fucking idiot" so I'm sure I'm doing something wrong.
Unfortunately, this is the way of Unreal Engine, when you do bigger changes you typically have to close out the editor and recompile, for small function level changes with live coding you can use ctrl+alt+f11 to recompile and patch your changes. (You shouldn't turn it off)
I can imagine coming from Unity there is a level of expectancy that you should be able to just reload the code - but this is different in unreal, so you will need to train your patience, as live recompile is typically only used for smaller, function level changes - if you change something like a header, usually you should go for a hard close of the editor and a recompile.
The main workflow is that non-performance critical, or otherwise "hot code" which you would be iterating on a lot, should go in Blueprint instead of C++, and the more "core" code that is systems level or performance critical should go to C++. This is obviously not an absolute rule and you could go fully C++, or fully BP, or whatever amount of inbetween you like, including even just abstracting specific functions in BP out to C++.
There is however, very large benefits to recompiling and gaining the patience for it - such as being able to make changes to the engine itself - which unity can't do, if you have an engine level function slowing your code down, you can just go and make it fast.
Hope this helps,Good luck on your Unreal journey <3
Use live coding (CTRL+ALT+F11), it works for most cpp changes and some .h changes as well. Anything else, you need to restart the editor. It's best to let the IDE handle the editor restart so you can do it with 1 button (f5 with rider will close the editor->compile->open the editor for example).
Live coding works great for logic iteration and fixing bugs. If you are changing class structures, or reflection properties (adding is fine), or static variables, then it has problems and you need a full exit recompile.
My workflow tends to be block out as much of my class and functions as possible. I tend to do more exit and recompiling in the early part of the process. After that changing code inside a cpp file can be just a 30 second build to refresh it and test.
I just started learning UE a week or so ago. I‚Äôm using Rider (I set Rider UProject as the default editor and it works flawlessly). In rider, you can use ctrl+shift+B to compile. If you turn off live coding, which I‚Äôve also done, the button in the bottom right of UE just compiles normally. There is also certainly a way to compile in VS or VSC but I don‚Äôt know the commands off the top of my head
You can build in Visual Studio, launch the editor to test changes, quit the editor, modify your code, build in Visual Studio again and launch the editor again. You want to avoid changing one line of code at a time. Write more code at once, build and test. Running the editor from the Visual Studio debugger and setting breakpoints in code will help you debug the code more efficiently.
If you are looking for help, don‚Äòt forget to check out the official Unreal Engine forums or Unreal Slackers for a community run discord server!
I am a bot, and this action was performed automatically. Please contact the moderators of this subreddit if you have any questions or concerns.

Comments from https://www.reddit.com/r/CodingHelp/comments/1flnmdd/confused_about_how_to_alter_this_code/:
I need to make this button bigger. Could someone please help?
<form target="paypal" action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="\_s-xclick">
<input type="hidden" name="hosted\_button\_id" value="VDGYJ2EGYCMYU">
<input type="image" src="https://www.paypalobjects.com/en\_US/i/btn/btn\_cart\_SM.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
<img alt="" border="0" src="https://www.paypalobjects.com/en\_US/i/scr/pixel.gif" width=‚Äú1‚Äù height=‚Äú1‚Äù>
</form>
See:
https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/image#essential_image_input_features

Comments from https://www.reddit.com/r/learnprogramming/comments/qsn2uz/is_it_going_to_be_too_confusing_learning_two/:
I'm gonna guess the answer is yes but I could do with some advice on the best thing to do.
Basically I have been learning coding/gamedev in Unity for a couple months on and off now and I've been learning c# and am enjoying it a lot. But in my school I am also taking Computer Science and they are teaching us Python and I don't know if I should put my learning at home with c# and Unity on hold while I learn in school or if ill be okay to do two different things at once
Any help would be appreciated and sorry if this is an obvious answer but I'm still new to this whole thing and don't want to be learning really inefficiently
I think it‚Äôs ok unless you find yourself not being able to be productive. It might actually be beneficial in my opinion because if you accidentally mix syntax/concepts between the languages you will be forced to understand each language better and remember how each work better in order to debug your programs. However if that gets overwhelming than obviously focus on school
I wouldn't worry about it.
Say you need to spend 10 hours per week doing classwork/Python to get an A. If you also spend 5 more hours doing C# - I think you'll do as good, or better, than if you just spent 10 hours doing Python.
(If you sacrifice time from your classwork/Python stuff to do C#, that's a different story)
I know when I was in college it was really common to have two (or more) classes that were in different languages at the same time. Plus, if you intend to write code professionally, there is a very good chance you'll be using/learning multiple languages all the time.
Lastly, I think exposure to different languages helps improve your overall understanding. Some things just seem easier to me in certain languages and comparing/contrasting two languages can sometimes help me. My university had a class on 'Programming languages' in general - it was great - and it highlighted all sorts of things about languages I just took for granted, and it was constantly showing examples from different languages that did things differently.
you're learning them separately. for different purposes.
i see zero problem. ü§∑‚Äç‚ôÇÔ∏è
just don't burn yourself out. don't hesitate to take a break from c#/unity if you're finding yourself feeling miserable since you probably want to do good in the school bit. misery isn't conducive to learning. self assess regularly.
make sure to get sleep too. maybe even take up meditation. heal them brain wires.
I appreciate all the advice and i think im going to continue learning both as most of you are saying but obviously focusing on the schoolwork and keeping the at home learning up when i have the time
It‚Äôs not going to be confusing. I would argue that if you learned Python first and then moved on to C#, it might be slightly confusing to wrap your head around static typing in C# after learning a dynamically typed language (Python). But the reverse is absolutely fine.

Comments from https://www.reddit.com/r/learnpython/comments/1ccrrin/confused_about_what_to_do/:
Hey, hope you programmers are fine. I am right now learning Python from FreeCodeCamp with the Scientific Computing with Python course . I am almost done with it. I am thinking of doing desktop dev but I also want to do something else. I want to do something that
Doesn't have a lot of math involved
is NOT web development related
So any suggestions?
Well, what are you interested in? Hard to give suggestions without knowing you, since you can do anything. I don't know much about scientific computing. If you like video games, you could make your own game with PyGame, or maybe an emulator (see r/EmuDev).
Consider data analysis or visualization! You can work with datasets, create interactive plots, and tell stories with data without heavy math. Python's a great language for this, and you can start with popular libraries like Pandas and Matplotlib.

Comments from https://www.reddit.com/r/learnprogramming/comments/try6h3/recently_had_a_programming_interview_but_am/:
Hello there,
I chose to take my interview in javascript and I ended up feeling like I did absolutely horribly. However, like any other of my failed interviews, I'd like to discover the solution so I can move forward with that knowledge so I am ready for the next interview that may ask for any similar information. SO with that said...
Given this data..
var data = [
['2004-08-01', '2008-05-01'],
 ['2008-07-01', '2014-06-01'],
 ['2012-06-01', '2015-06-01']
];
JavaScript has a Date object. So you could parse the strings as a date, and the date object to get the time between two dates. See here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date
Well. If this all information you were given on interview I'd start asking questions:
How long is month? Because different months have different days. Or we consider same day of next month as month?
Given example data can I assume start and end date always has first day of month?
Can I use Date from js to solve this problem?
Am I need handle errors or can assume input is always correct and well formatted.
üòÄ probably after this answers we can go to data comparison.
General logic. Iterate over array of dates. If month of next start date is greater than month of end date + 1 => more than month. Else If month of next start date equal to month of end date + 1 AND day of next start date greater than day of end date => more than month. Else less than month.
What position you were interviewed?
It's often helpful to try to rephrase the problem to a similar, easier problem and see if you can solve that first, then translate your solution to the more complex problem. Here's the variation that I'd recommend you try to solve first:
Given an array of dates (like the following) log the number of days between each date and the next.
tbh date comparisons are a weak area of JS, so you are not alone. There are no inbuilt date difference functions in JS plain and simple.
ONE of the ways, is that you convert those strings to date objects, convert to time in milliseconds numeric values, subtract the numeric values, then start dividing by milliseconds per day to solve this.
Another way is that you convert those strings to date objects, extract the years, multiply the full years difference by 12, and then add to that the difference in month values.
You can get the milliseconds between two dates date1 and date2 with new Date(date2).getTime() - new Date(date1).getTime()
You would first convert the strings to Date objects, here's an example:
var date = new Date('2004-08-01')
With a date object you can add/substract months and it already handles the tricky details for you,. For example if the current month is december (11) and you want to set the month to 11+3 it seems like this could be a problem but you just get march of the next year at the same day.
Also date objects can be compared like numbers. Knowing this two things the part about dealing with month offsets and comparing dates is trivial.

Comments from https://www.reddit.com/r/learnprogramming/comments/tqtr9i/im_totally_confused_with_how_people_can_manage_to/:
Currently i'm doing a javascript course and I feel like I got nothing in my head even after watching 175 of 449 video modules. I just did a test to join an IT Bootcamp but on one of the requirements is you need to know BASIC programming. Assuming I've followed many programming (python and javascript) tutorials I was thinking that I could pass the test. But I can't even finish a simple find max value from an array. I literally can't do it without any help cause the test is using a webcam to watch you do the test (It's using hackerrank proctoring feature). Failing that test makes me realize how stupid I am. As if I just wasted my time trying to learn programming.
How do you guys manage to be so good at this programming world. What kind of methods did you guys use? Or maybe it's just my capacity not meant to be in this field? I've loved computer since I was a child, I even graduated in CS degree last year. But this is my first time said to my inner self that I'm depressed and I really know nothing about programming.
Reading many motivation in this subreddit sometimes motivates me to study even harder but it's just me can't memorize anything I've learned and I really don't know what's the problem.
after watching 175 of 449 video modules.
Are you actually writing code yourself, or are you just watching videos? If it‚Äôs the latter, then that‚Äôs your problem.
You‚Äôre not going to learn programming by watching videos. You need to sit down and write code. I‚Äôd say you probably should be spending 80%-90% of your time practicing, and only 10%-20% watching videos or reading about programming.
You‚Äôre very unlikely to learn it without practical application.
It‚Äôs not just you, believe me, I was there once. My approach was similar to yours and it was all wrong.
You learn programming by doing and not just following videos. There is value to videos but I think many of these courses set you up to fail because they do not include exercises to reinforce your understanding. Telling someone to program is like saying, go to a country where you don‚Äôt speak the language. Watching videos is too passive. You have to write code.
Not sure what course you are doing but try to find one that gives you exercises. Another option is to code some personal project that interests you. But take note that getting better at programming is like watching paint dry. A good way to get better quick is to make several quick throwaway programs by building off of others code.
You are mixing learning a programming language and learning programming. They are two different things.
Learning a programming language is easy. It is just some limited vocabulary (the keywords) and some simple grammar (the syntax).
Learning programming is an entirely different beast. Learning programming means learning a different way of thinking. It means learning to think in minuscule, discrete steps to arrive at a solution - thinking in algorithms.
Learning programming is difficult. It will take time, practice, effort, determination, persistence, and hard work. Have I mentioned practice already?
How do you guys manage to be so good at this programming world.
Practice, practice, practice, and more practice. And since we didn't have it yet: practice.
Really. That's what it comes down. The more you practice, the better you become.
Programming is an acquired and trained skill.
What kind of methods did you guys use?
For me, personally, it was the hard way. BASIC (the programming language) manual that came with the computer and jumping into the cold water. I learnt programming way before the internet.
Today: good beginner tutorial with plenty practical exercises - best in textual form as videos tend to lead to passive watching instead of active programming.
After the beginner tutorial: practice - building programs
I feel like I got nothing in my head even after watching 175 of 449 video modules.
Watching will not cut it. Rushing through will even less help.
You need to program, program, program, and program more.
Just reading or watching programming tutorials will make you as much a programmer as reading tennis books and watching tennis will make you a tennis player. If you haven't stood on the court, you don't learn.
can't memorize
Don't memorize - understand.
How does program flow work? How does a conditional work? How do loops repeat? What happens when you change a variable?
The only place where memorization can help is syntax and this should actually happen automatically and transfer into muscle memory.
But I can't even finish a simple find max value from an array.
Explain. Why and where are you stuck?
Maybe take a more pragmatic approach to programming: plan before program.
Think through the problem. Devise a solution on paper - as you (not the computer) would do. Take notes of the steps to arrive at the solution. Go into details. Once you have a good step-by-step approach, start thinking of programming it.
Some literature:
"Think Like A Programmer" by V. Anton Spraul
"The Pragmatic Programmer" by Andrew Hunt and David Thomas
"Structure and Interpretation of Computer Programs" (SICP) by Abelson, Sussman, and Sussman - maybe a read for later.
what boot camp is forcing BASIC on folks? or were you just emphasizing that you needed to be able to do simple stuff in a language to join? Programming is just like reading and writing. The more you read, the better you understand, the more you write (not cut and paste) the more precise/deft your utilization becomes.
Don't watch too much videos, write code yourself, struggle, then you will learn by making and fixing your mistakes. The first language is the most difficult because you learn how to think like a computer or interpreter. The other languages will be easier because you'll have this knowledge and will be able to compare with the other languages you already know.
Switch up how you‚Äôre learning. Clearly watching videos isn‚Äôt doing it. Try reading a textbook and working through the exercises, try a course that has you programming to solve problem sets, try some basic problems on code academy.
Imagine programming is like normal language. What you just learn is basically the grammar and basic nouns. Then in an interview you said you know said languages, the interviewer asked you a problem in that language and expect you to answer it.
Problem is, you just KNOW the grammar and nouns. You don't know about the problem or about solving problem. So you can't answer it.
It's a different skill value, you never tried to solve problem with said language, you just learn how to create some stories.
Basically you're learning the wrong things.
The most important skill is breaking down problems. A video, if done correctly does this. But seems like all you've been practicing is copying hence, gestures broadly

Comments from https://www.reddit.com/r/CodingandBilling/comments/1d9x1r7/confused_about_schooling/:
Personally I didn't learn anything though their program, not even the coding. Everything I've learned was through experience and starting at the bottom somewhere.
honestly the best experience you‚Äôre going to get is on the job. apply for medical billing positions, they might not be remote but you‚Äôll get your foot in the door.
i did a program at my local community college and use was nothing like hands on actual experience doing billing.
once you get some hands on experience you can go through the aapc and get certified as a coder, you can do a course through aapc on that exam.
you dont need a certification to be a biller.
FYI, work from home is dependent on the company. Some are just not set up for remote. Some may have it for very experienced employees. Some have all remote. It can be very hard being remote and having questions. Work is not always cut and dry like in school, so who will you go to for answers at home.
I am currently under the school of UMA Ultimate Medical Academy so far it is my third month of an 18-month course and I have barely just begun the medical terminology to this and I have to say that I am not necessarily learning much. Everything seems to be pretty self-explanatory from what you can find in the chapters and in the textbook as well as on the goddamn internet and I do not know if this program is actually going to get me anywhere. All I know right now is that I am doing in the work because my financial aid paid full for it and I don't even know if it's going to teach me anything in the long run for me to get a job to work from home. I know it's a stupid dream and I probably got scammed into this but as of right now I got nothing else going for me and I am going head first into this program so I am hoping that it can and will be the outcome I was looking for. I did no research of this school and just jumped in, i have to say that I've been well taken care off. They call weekly to see how i am, feeling, any questions about the program. They have been understanding if you cant turn in work on time. Im not lost when doing my work. Though i have my doubts about the program I will say that I do not feel like I am being ignored or being taken advantage of or misled. Im just saying maybe its up to the person to really put in the work to learn and the rest will have to come from experience in the workplace.
the certification through purdue isn‚Äôt worth anything you would need to be certified through AAPC or AHIMA by taking their exam if you wanted to do coding. if you‚Äôre only looking to do billing you don‚Äôt even need to be certified and i honestly wouldn‚Äôt waste your time going to another school because there‚Äôs places out there who would hire you without schooling to begin with. just apply places and have confidence that you learned billing you will be trained on the job and learn everything then anyway.

Comments from https://www.reddit.com/r/learnjava/comments/1eytp8v/confused_on_how_it_all_fits_together_and_what_to/:
Hi everyone!
I‚Äôm currently a student studying computer science and my Uni is teaching Java and has covered stuff like methods and inheritance and classes and objects.
We also did basic html and css. And a bit of SQL.
I‚Äôm just confused on how to actually bring it all together to do self practice at home. I really want to make projects but I‚Äôm confused on how to integrate it all together. We haven‚Äôt covered spring boot or JavaScript. I‚Äôve made one website with just html and css and mysql and php.
I‚Äôm just wondering if anyone has any knowledge or advice on how to make something with all of this or any materials to learn Java and to understand more on its uses and how I can apply it.
And is The Odin project a good resource to teach this and full stack open for react and the front end?
Hey there, first of all congrats, you reached a new level so all this is natural, embrace it (i know it is hard) and move carefully.
Regarding the Odin Project, i have used it back in the day when i was a noob and it helped me both to understand Rails as well the MVC ways. in my opinion the latter is more important as it transfers across technologies.
Now, before i try to give you any sort of advice, lets try to focus on the fundamentals. If you want to work around programming and the web, the parts that you need to know about (and from there on to specialize in what you prefer) are Frontend (HTML, CSS, JS) and Backend (server side programming, Databases, Linux machines, etc). I know i sort of generalized it too much but in practice that is what my experience showed.
If you want my personal opinion, spend more time to understand the OS, how networks work and their protocols, how we design a Database and how we build our backend system in order to secure the endpoints and have our CRUDs running against a database.
I think this is the first part for you. Make sure to feel confident enough to build such a system and understand generally what happens in a Request/Response cycle.
Doing all this, you will see that you will feel confident in any language you will choose (you mentioned Java but this works in any language really) and strong enough to move forward in more advanced parts in the field that you will choose. For instance, if you want to specialize in the Backend, you will have to learn more on Databases (Indexes, Backups, etc), learn about Caching, KV stores and all these things that will leverage your system. Having said that, here is the time to start reading more about System Design in high level terms and slowly piece by piece implement some System Design learnings to improve.
Here are some links in case they could help you:
System Design Interview - Vol 1
System Design Interview - Vol 2
Designing Data-Intensive Applications
NOTE:
As you have noticed all this time i have not mentioned any specific technology. This is why learning the fundamentals will actually help you choose later on the technology that makes you happy. If you would like to use Java then the answer probably lies around Spring since this is very strong in almost all markets around the world but again, feel free to play around and see what fits you better.
You've reached the hard part. There's a million ways to bring it all together but there's no right answer. There are certainly bad ones, good ones, and great ones, but none are "right". You'll never know how to structure or design your code when you first start, no matter how many documents you read. The best way to get an understanding for that is with experience. I'd say the best way forward from here is to break whatever large project into smaller parts so you can start going at it. You will feel very uncomfortable and unsure, but you'll start to build experience from it. Take it one step at a time and don't worry about making mistakes.
That's how I went about it at least. You could probably buy some books on design patterns and such but do keep in mind that applying and understanding the patterns to their fullest still requires that experience. If I were you, I'd hold off on those until you're at least a bit more comfortable piecing the code together.
It seems that you are looking for resources for learning Java.
In our sidebar ("About" on mobile), we have a section "Free Tutorials" where we list the most commonly recommended courses.
To make it easier for you, the recommendations are posted right here:
MOOC Java Programming from the University of Helsinki
Java for Complete Beginners
accompanying site CaveOfProgramming
Derek Banas' Java Playlist
accompanying site NewThinkTank
Hyperskill is a fairly new resource from Jetbrains (the maker of IntelliJ)
Also, don't forget to look at:
The official Documentation
The official Java Tutorials
Our community resources thread
If you are looking for learning resources for Data Structures and Algorithms, look into:
"Algorithms" by Robert Sedgewick and Kevin Wayne - Princeton University
Coursera course:
Part I
Part II
Coursebook
Algorithms 4th Edition
Your post remains visible. There is nothing you need to do.
I am a bot and this message was triggered by keywords like "learn", "learning", "course" in the title of your post.
I am a bot, and this action was performed automatically. Please contact the moderators of this subreddit if you have any questions or concerns.

Comments from https://www.reddit.com/r/learnprogramming/comments/1eif4el/confusion_of_a_19_yr_old_guy/:
So I'm doing my bachelor's in electrical engineering, but there is a keen interest in programming, I know the two main work space, one the front end or web development and other is backend development, I studied some basics of programming language like c, c++. I know some html and css too, but some time, I don't know the exact reason may be peer pressure, I stuck between webd or dsa, some of my friends are doing dsa , practice on leetcode etc, and some are creating cool websites the visual stuff, I want to learn both, but don't know where to start, as I'm doing electrical major so that's little off the way to do coding stuff, but still want to do it. Please any suggestions!
If you‚Äôre doing electrical engineering then why not embedded programming? It requires a very good understanding of circuitry, schematics, radio, and low level programming.
Eh? You would get more out of the IEC61131-3 languages. You are doing electrical engineering, and you will possibly need C. Maybe python aswell but the front and back end forget about that.
You will be learning about motors, configurations, applied physics, etc.

Comments from https://www.reddit.com/r/learnprogramming/comments/d4v3hr/help_with_c_homework_confused/:
Hi, I am having trouble with my C++ programming class that I am taking at my college. This is my first assignment and I am very confused on what to do. I tried reading the textbook required for the course but I find it not very helpful on what or how to do the assignment. This is basically what is required but I am having trouble starting out. I am not a newbie to computers but I am to programming and it is so confusing it is stressing me out! lol :( basically this is what is being asked to do can someone please help me understand this. I would very appreciate it! basically I am stuck on the Pseudocode I have no clue of what to do.
Assuming the ocean‚Äôs level is currently rising at about 1.1 inches per year, write
a program that displays the following calculations (your program calculates this, you do not precalculate this and hard code it):
The number of inches higher than the current level that the ocean‚Äôs level will be in 3 years.
The number of inches higher than the current level that the ocean‚Äôs level will be in 6 years.
Okay, so ignore the code for a minute. How would you do this by hand? Can you explain how you'd do this on paper?
So a value to hold the current sea level (probably 0 since its a baseline)
a variable to hold the gain per year (you said this is 1.1)
3 variables that have a formula to store the calculated sea levels in 3,6,11 years respectively
3 print statements
Thats your simplified requirements. This might be your first assignment but merely getting the assignment is not likely the first thing to happen in class. If you are having problems already you should review all the material you've been given so far. Several times.
Programming might use math but its not a math skill. Its a language skill. And your brain has to rewire itself slowly till it thinks in the grammar and vocabulary of the language you are learning. This means your first programming language is only slightly easier to learn than learning klingon.
You absolutely will need to re-read your study material several times for things to click and become easier
Irrespective of what language you are writing in, one of the things I've found most effective is this:
Learn to interpret problems in English (or your language).
You'd be surprised how complicated things can get once we start considering variables, methodologies etc, and we can very easily lose focus from the "way" of getting something done to what we are actually aiming for.
Once you are absolutely confident that you can translate your problem at hand in simple English words, you will be one step closer to formulating a method that gives you a solution.
Always break bigger problems into smaller bite-sized ones, like CreativeTechGuyGames said, start by considering the very simplest: how would you actually solve this on paper - or if computers were not a factor? That's your first step :)
I know it sounds very simple and idealistic, but I've found myself having this very issue at work sometimes, I'll be sitting with my manager thinking of ways to solve an issue - I use Python mostly - and I often drift away to all the possible ways Python can help solve a problem, and swoop - before you know it I'm overwhelmed by the possibilities and have lost focus on the actual problem.
Always try to make things simpler than they initially seem ;) - Pseudocode (English) is your friend.

Comments from https://www.reddit.com/r/gamedev/comments/1d1vm9r/programming_coding_games_could_someone_explain_to/:
How do I understand the process of coding a complete video game project, like putting graphics on the screen, making things move, setting it all up, putting things together, making systems, deciding how to code the systems, putting FX... etcs
Are there any good videos that show the whole process of creating a project? I keep finding short tutorials that don't explain the bigger picture, or imcomplete tutorials, like I've seen a pong tutorial which did teach me some stuff, namely about invisible "collision boxes" that go over the graphics, when they hit eachother, they add to a score
I realize there's unity3d game engines and stuff that probably should be used, maybe I should try to find some tutorials on those...
I keep running into short tutorials but nothing that let's me see the bigger picture of it all, like how people decide to do this, how to complete a system in video game, how to connect it all together, how to make everything work and plan for it... How to connect the graphics to the characters, make systems work, how to code the systems ETCETC
If you actually want to start making games then you should probably start with an Engine like Godot or Unity and follow a simple tutorial from start to finish for a platformer.
I would not recommend starting with C++ and making a game engine essentially from scratch if your only experience is Hello World.
Once you have a platformer working in Godot or Unity you can try adding new levels, enemies or a fireball on your own. It will be a lot easier once you have the basic experience of following a tutorial.
They usually use an engine. I use godot currently, and Unity in the past.
They usually have experience as programmers. I started making games in high-school programming classes. I released my first game in 2nd year of university for Computer Science. I'll release my 2nd game next year with 4 years of industry experience and a completed Bachelor's in CS.(Note: these are small 2D games, even with this experience I am not making anything super ambitious) This isn't all necessary, but you need to learn programming to make games by yourself. Otherwise, you need to hire people that can program for you. That will cost at least 50k/year.
You don't understand how things work because you don't understand software yet. You can go headfirst and follow tutorials and experiment until you build some knowledge. You can look for resources for X engine/language for direction. Basically, there's a ton to learn, and you'll have to learn it at some point. If you're serious about making games, you'll push through it. If not, you'll likely give up at some point.
All the best. It's rough out here but sometimes rewarding.
You could check out the Harvard cs50 intro to game development mooc. It uses love2d and goes over making increasingly complicated games with a better look under the hood compared to making games with a big engine like unity. If your ultimate goal is to make a game I would absolutely recommend you use a game engine but if your goal is to understand game development better I think this will help.
https://pll.harvard.edu/course/cs50s-introduction-game-development
Short answer is definitely use an engine. It all comes down to code eventually, but the code that drives a game at the lowest level (like animation, rendering, input) can get super complicated - it's the kind of thing even experienced devs shy away from, let alone people just getting started. It's really interesting and cool, but I would avoid it until you feel pretty confident as a dev and have a reason to get low-level. 
Game engines are great, since they've already got all of that stuff done and ready to go - all you'll need to focus on is the code that actually makes your game fun, instead of the crazy stuff.
You'll figure out a lot of good practices and technique just by making things and trying different methods - make sure you keep the scope small! The more small projects you finish the better you'll be, and as you get more ambitious you'll start to naturally encounter and learn to solve a lot of these questions.
To actually answer your questions:
Single people make games with a lot of practice. Even better, they get degrees and then get lots of experience working in teams and on games. Once they've sucked up all that XP, they can go and create something cool 
There are a million great tutorials for setting up an engine and IDE. For a platformer I'd recommend Godot or Unity, but if you want to stick with C++ Unreal is great too 
You share and merge code with source control. Git is the go-to for small teams, with other solutions like perforce being used more professionally 
In big projects, you know what to do next by experience, or by asking someone else with experience when you don't have any. You can (and should) just do what sounds fun next on your own projects!
In your platformer example, graphics and input would be handled by an engine. You have code that waits for that input, starts an animation, and spawns in the fireball. You would also add some code on the fireball that waits for a collision event (engine's job), and then you get the colliding object and destroy it.
The planning portion is really based on experience, you do your first project and u realise what‚Äôs messy then u plan the next to be less so, this Is basically the architecture.
How low -level you want to go depends on you, you could go as low as using code to choose where to draw a pixel on a screen, or use a library, or an engine. Depends on what outcome you want, if it‚Äôs a game you want to make or an engine or everything, the main decision factor is usually time.
So taking an example of an ASCII game, where u use text in a console to represent things in your game. You type ‚ÄúP‚Äù in position line 0 character 0. Press the right arrow key, clear the screen, type ‚ÄúP‚Äù in line 0 character 1. That‚Äôs kind of what graphic does. You can expand from text to pixels, etc, etc, as you graduate to each tier you sort of understand how things need to connect together before long.
Usually people who solo dev from engine to game, have either been building the engine for a while for something else and decided to repurpose it for their new game.
There's not going to be a beginner friendly tutorial for how to program graphics in C++ because it's an advanced topic and not something one needs to understand to make a game in today's world.
If your goal is to make a game then use an engine. Godot, Unity, Unreal, Gamemaker, etc. There is still a lot of programing involved but it is more about describing game logic and the practical matters of how the game functions. But the lower level functionality such as rendering and input are provided by the engine. There ARE good resources out there for pretty much any engine that you choose.
It can be a little hard to conceptualize the big picture of how a game is structured and part of that is because there is not a set way of doing things. Even two games made with the same engine may have a very different design. It's best to start with small projects and try to understand the basics and go from there.
With c/c++ I use SDL.
https://lazyfoo.net/tutorials/SDL/
With SDL you can create windows, draws stuff on those windows, add sound, etc.
-Learn to create a window
-Learn to draw a character, a fireball and an enemy on that window
-Learn about user input and movement to make the fireball fly towards the enemy
-Learn about collision boxes to make the flying fireball to hit the enemy
-Make games
About the big picture, idk if people answered about that but, programming game is creating something that will wait for input from the player, and provide something to see and hear, according to those inputs. At the very core of the computer, it would: be read electrical signals for the inputs, and generate data that the video card and the sound chipset would interprete and transform into sounds and pictures. Operating Systems abstract a lot of those thing already, so you want to read from what it provides. For example, Windows is able to provide data coming through USB port, so if it's a controller, you have to interprete those data. And you can give graphical data to DirectX sw layer, and it will be outputed to the graphical card. But those entry point needs low level coding, or at least it is low level from the user point of view. There's a lot of software abstraction layer and Game Engine are one of those layers. but in the end, your program will connect those outputs and inputs.
I work on embedded microcontroller and I also make games. I'm able to understand those concepts but as you can see, I don't remember clearly because I don't care. That's why I use a Game Engine. But, if it's c++ or a Game Engine, the logic is somehow the same, if you want to read the "S" button from the keyboard, you must test for this button to be pressed, with an "if" statement, depending on what you are using. And if it's pressed, then you can throw a fireball, but then again the complexity of the task will depend on the engine.
If you want to learn low level, try to read stuff about arduino programming, with peripheral registers writing. If you want to keep it high level, try to use any Engine you find appealing. Learning general programming is a good stuff too, you can do simple calculator, text-based adventure, and little by little it will make sense you'll see.
Yeah okay.
I've noticed the problem you've described. The problem is that many of these tutorials are marked a s "beginner" but really they mean "basics". They assume you already have engineering knowledge that you can combine with the "basics" to make full games.
It's backwards imk. Instead, "beginner" videos should be much longer, and introduce programming practices, and engineering concepts.
If you don't mind taking the long way, I'd recommend that you learn programming from somewhere that's actually for beginners. I hear good things about Harvard's course: https://cs50.harvard.edu/x Also, learn about software engineering; I guess I learned this in school and on the job, but you might be able to study open source projects and stuff to help you get yourself there.
The trick is learning how to apply these concepts to games. Honestly I didn't really pick up on this until I started working at a commercial firm, but again, you might get by looking at other projects code.

Comments from https://www.reddit.com/r/developersIndia/comments/1funxqq/confused_and_lost_need_urgent_guidance_for_coding/:
Hey everyone, I'm currently in my 3rd year of CSE, and I‚Äôm feeling really lost about which programming language I should focus on for coding rounds. I come from a non-IT background, which makes it even harder because I have no one to guide me on what to do or not to do. I‚Äôve been hearing a lot of conflicting advice, and it's overwhelming.
Some people tell me that DSA using Python is the future and I should stick to it. But then others say that many service-based companies don‚Äôt even consider Python for DSA rounds and I should switch to C++ if I want to get placed. I honestly don‚Äôt know what to do.
I don‚Äôt just want a job ‚Äî I need it. I want to become a software engineer at a big tech company because I have a huge responsibility. I need to buy a house for my mom and secure our future, but I‚Äôm scared of making the wrong choice and wasting time. There‚Äôs so much pressure, and I feel like I‚Äôm running out of time to figure this all out.
I‚Äôd really appreciate it if anyone could give me some guidance or share their experiences. Should I stick to Python or switch to C++? How should I approach preparing for placements? Any advice would be life-changing for me right now.
c++ karle mere bhai, mai bhi third year me hu. Start sooner rather than later

Comments from https://www.reddit.com/r/learnpython/comments/10cz4bd/confused_about_virtual_environment_in_vs_code/:
I am trying to learn Python... I am writing my scripts in VS Code and I am trying to get / keep things organized and correct as I am learning.
In VS Code I have main heading in explorer called Python Projects. Below that I had all of the scripts that I had written, I felt that I should organize things a little so I created a folder for each script and moved each script to its respective folder. I read about having a virtual environment and it seemed to me this would be a good thing to set up. I have read the VS Code documentation and Googled it but having trouble understanding how I should implement it.
Should I have a virtual environment for each of the folders?
How do I link a script and its folder to that virtual environment?
How would I link a script to a new virtual environment, it had been linked to a previous environment that I had created and deleted while experimenting.
Thanks in advance!
I feel there is a lot here that could be solved with more reading and maybe watching some YouTube tutorials. You're asking some fairly basic questions. But here is a high-level overview.
Scripts should be grouped together that are related or closely related. Or if you have a bunch of one-off scripts that use similar libraries, that would be fine, too.
Once you create a virtual env, you tell VSCode about it.
Medium has good articles about it. Easy reading.
https://kodetorium.medium.com/setting-up-a-virtual-environment-in-vs-code-8c18fedcba1a
As a beginner myself, I just create different folders per chapter.
example: 1)string/integers manipulation, formatting... 2) lists, tuples, sets, adding, removing...
When I start VScode, I load the folder with the chapter that I'm learning.
Virtual environments are used to my understanding, when you try to code something for a different Python version and or system architecture, locals.
Check out https://code.visualstudio.com/docs/languages/python and look at the Environments section for some guidance.

Comments from https://www.reddit.com/r/TuringComplete/comments/1eqzn4d/hopelessly_confused_about_assembly/:
Disclaimer: I have no computer experience or coding knowledge whatsoever, this game is what I‚Äôm using to broach that field in a gameified and guided manner.
I just got to the three parallel levels shortly after unlocking Assembly and in particular I‚Äôm working on the Storage Cracker level.
I accidentally solved it with an ugly code that just sort of brute-forced it (I tried to get a loop going that it could jump out of when the input shifts to 1, but it just ran through the whole set of numbers twice which counted as a win). I want to solve it properly this time with an elegant code that loops properly, and in my efforts I‚Äôve come to realize I have no clue how to efficiently use Assembly.
Specifically, I don‚Äôt know how labels work, and I‚Äôm fairly certain I‚Äôm using the assembly codes on the left wrong (haven‚Äôt even started to worry about setting constants, though that seems straightforward enough).
The loop concept as it relates to setting labels is also getting me confused. I understand you can jump back to an arbitrary start point by priming Register 0 and then initiating the ‚Äúalways on‚Äù conditional setting, but breaking out of the loop is what‚Äôs giving me trouble.
Okay, let me start by commenting on the safe-cracker level: I always thought the level ends automatically as soon as you output the right password once? And brute-forcing is by goign through all numbers is the intended 'easy' solution, so there is nothign wrong with doign it.
Now to the assembly questions:
The only thing assembly really is is giving the numbers which are saved in your program a different name. For example your computer is constructed in such a way that the number 68 (or 01000100 in binary) makes the computer add the numbers in reg1 and reg2 and save the result in reg3.
But always writing 68 in your code makes it hard to understand. So we simply give the number the name 'add'. So whenever the program runs the command 'add' it will simply send the number 68 and do whatever the numbers makes it do.
Next what labels are: imagine you want to later jump to a specific line in your code. The issue is for the computer not the line matters, but rather the location in the program in which this line is saved. Now if you put the label 'here' in your code, the variable 'here' will simply be equal to the value of the location of the following command in your program. So example:
1
reg0_to_reg2
3
label here
reg1_to_out
add
here
jmp
Now the word 'here' will be defined in line 4 and have the value of the lcoation where line 5 is saved in your program.
In line 7 this number is being sent into reg0 now and the following jmp-command will jump to the value in reg0, thus to the line 5. So this (nonsensical and not optimal but working) example would always loop the instructions between lines 4 to 8 for all eternity.
Labels can be confusing because they are part of the assembly language, but not the machine language. A label does not create a line of code in program memory, it creates an entry in a virtual symbol table mapping the label text to the line number after it. The assembler (given to the player in TC behind the scenes) then replaces each instance of that symbol in the code with its associated line number. Here's an example:
Conditional jumps only change the program counter if the condition is true, otherwise they proceed to the next instruction like normal. So you want to keep in memory something to test at each iteration of the loop. Count to ten by looping over code that increments a number from 0 to 10, at each step testing whether we have reached ten yet. If it's ten we branch out (conditional) otherwise we keep looping (unconditional). You might have to adjust your math depending on if you test at the beginning or end of the loop. There might be some code nearby that is an unconditional counting loop ready to be made conditional to ten.
The math symbols are again a function of the assembler, and not anything the player builds. If you write 2+2 in the assembly code, it will replace it with 4 before it gives it to your CPU to execute. 0x80+8*3+2 means "copy from r3 to r2", funny right? If we save 0x80 as "copy" and 8 as "from" in the assembly codes, we can write copy+from*3+2. Now we're having fun, but the computer is still doing the same thing. Labels, math symbols, and assembly codes are all quality of life features added by the TC developer to make assembly coding less tedious. You can write all ones and zeroes if you please, or call the instruction that adds "SUBTRACT" in your assembly codes. The CPU in the game can't tell the difference.
Code is data. Data is code. Go back to the level log for the level "Turing Complete". Conditional jumping is a foundational idea in computer science so take a while to figure it out. If you're still not satisfied, check out the book Code by Petzold, a course called nand2tetris, and Ben Eater on youtube.

Comments from https://www.reddit.com/r/learnprogramming/:
I accidentally pulled an all-nighter üòÖ
I was studying for my exams, but got bored with the math and decided to play around with a project I‚Äôve been wanting to work on for almost a year.
I‚Äôd been procrastinating because I‚Äôm still a beginner at programming, so I always face a lot of friction trying to figure things out.
But this time, I actually made progress. Looking back at my previous struggles, I realized I‚Äôd learned something new without even noticing.
I started around 6:00 PM, so I‚Äôve basically been programming for about 11 and a half hours, which flew by in the blink of an eye üòÖ
I am currently studying CS in austria as an international student.
if i try my geniune hardest every year ,
And try getting internships, and create projects.
Will I be able to find a good programming job?
Or will i be unemployed like the rest of you.
Thanks in advance
I took a boot camp during Covid to learn full stack. I completed the course built a portfolio and a network. I got a job without a coding interview which I thought was odd. I won‚Äôt go into all the details, but the job was an unorganized mess that didn‚Äôt pan out. I ended up going back to my old job as a bartender which I started to code to get away from and have a solid career. I did it out of necessity. The start of this year I took a new boot camp because it was cheap and I hadn‚Äôt coded in a while. I finished the program and it was not very hands on. Most of the projects and class work was just following instructions and not actually thinking for yourself. I feel like I learned next to nothing. I still want to better my life and I‚Äôm struggling to get in a groove where I‚Äôm steadily learning. I want to apply for jobs with confidence and not feel like I‚Äôm fumbling through.

Comments from https://www.reddit.com/r/ProgrammerHumor/comments/srg4na/im_so_confused_right_now_and_it_seems_almost/:
Did you just say js/JQuery is hard?
There are teaching jQuery at school?
That's a good school cuz I didn't learn shit
If you want to understand Javascript and jQuery you will need to understand how the web works, at least from the client standpoint.
Javascript is a programming language made to manipulate webpages and webpages are composed by HTML, CSS, Javascript and all the other assets like images, videos, audios, etc. HTML is used to determine the structure of the user interface, like buttons, forms, navigation, links, etc. CSS is used to make that structure have a prettier design, by manipulating colors, backgrounds, text, positioning, etc. And finally JS will manipulate HTML to make things more interactive by adding or removing HTML elements, changing the attributes of these elements, adding extra styles to these elements, etc.
jQuery is a library on JS that is made to make all these HTML (which is actually called DOM after the browser reads it and transforms from code to actual graphical interfaces) manipulations easier.
Essentially, to understand JS and jQuery better you will need to know HTML and understand the DOM. You can find more info on the MDN docs. The MDN Docs are excellent for consulting about specific things of the web and it also has some tutorials.
Finally, don't stress it too much, as jQuery has become less and less used and the best tecnologies these days are much more structured by components (which are really similar to classes in OOP, but have the added responsibilities for HTML structure and CSS styles) and less about manipulating the DOM directly.
If you want to chat more about it, hit me up in my DMs and I'll try to help as much as I can. Best of luck in this developer journey.
Image Transcription: Meme
["Running Away Balloon" which features a person happily trying to catch a yellow balloon in the first panel and then being held in place looking concerned by a giant pink blob in the second panel. They are labeled as such:]
Person: ME IN SCHOOL
Yellow balloon: LEARNING JAVA/C#/PHP THINKING PROGRAMMING IS PRETTY EASY
Pink blob:
JAVASCRIPT
JQUERY
I'm a human volunteer content transcriber and you could be too! If you'd like more information on what we do and why we do it, click here!

Comments from https://www.reddit.com/r/computerscience/comments/1ee91wq/confusion_in_computer_network_learning/:
i have some basic knowledge of computer networks, that's because I have taken the course in my native language, but for a better understanding of networking, I decide to read the English original book. I think maybe my English is not bad tho and while I am trying to read these books (e.g. the book computer networks-5th edition),I find I have difficulty to understand some kinds of expression in this book. I am so confused wether i need to further improve my English and then preced to read these books or try other methods to gain a deeper understanding of computer networks.
That probably depends on what topics are confusing to you and why.
Feel free to DM me if you have any questions. I'm a network engineer and did some tutoring for other students when I was in school. I'm also learning a second language myself, so I sympathize with those struggles.
Hi, I‚Äôm Vetted AI Bot! I researched the Pearson Computer Networks 5th Edition and I thought you might find the following analysis helpful.
Users liked:
Comprehensive coverage of networking concepts (backed by 3 comments)
Clear and engaging writing style (backed by 3 comments)
Useful for all levels of knowledge (backed by 2 comments)
Users disliked:
Lacks in-depth explanations and examples (backed by 4 comments)
Assumes high level of prior knowledge (backed by 3 comments)
Poor quality materials and printing (backed by 3 comments)
Do you want to continue this conversation?
[Learn more about Pearson Computer Networks 5th Edition](https://vetted.ai/chat?utm_source=reddit&utm_medium=comment&utm_campaign=bot&q=Pearson%20Computer%20Networks%205th%20Edition%20reviews)
[Find Pearson Computer Networks 5th Edition alternatives](https://vetted.ai/chat?utm_source=reddit&utm_medium=comment&utm_campaign=bot&q=Find the best%20Pearson%20Computer%20Networks%205th%20Edition%20alternatives)
This message was generated by a (very smart) bot. If you found it helpful, let us know with an upvote and a ‚Äúgood bot!‚Äù reply and please feel free to provide feedback on how it can be improved.
Powered by [vetted.ai](https://vetted.ai/chat?utm_source=reddit&utm_medium=comment&utm_campaign=bot)

Comments from https://www.reddit.com/r/learnprogramming/comments/km6el9/cs_major_lacking_confidence_and_utterly_confused/:
EDIT: Aww, thank you so much for the awards! üíï
Not sure if this is the right place to be posting this, but I‚Äôm a CS major, and though I understand the syntax of programming languages and what not, I‚Äôm still not making the connection of, ‚ÄúOh! When I write code on this IDE, it can be turned into a software program!‚Äù And its driving me insane.
Granted, this is only my first year, and we just finished learning Java off ZyBooks. The language is graspable, and I basically learned how to compile a bunch of different things, but I can‚Äôt see myself being a full blown, confident programmer who creates things like Facebook, Google, or Amazon. I‚Äôm not looking to be a huge creator or anything, I just want to be competent enough for my future job as a software engineer (fingers crossed).
Will the confidence come as the years go by during college, or am I hopeless? I don‚Äôt want to be stuck compiling a ‚ÄúHello World!‚Äù program forever. Does it click along the way? I GET the language, but I‚Äôm lost when it comes to actually creating something with it.
Literally millions of software engineers who aren't Mark Zuckerberg live perfectly happy lives writing code for the billions of other tasks that aren't Facebook, Google, or Amazon.
Java is just a tool, you'll start to learn that the language is nearly irrelevant. What matters is that you understand the underlying problem, the one the code is being used to solve. You're getting a degree in Computer Science, not Java.
Here's a small project for you. You may PM any questions you have, and I'll help you the entire way. You can use Java, or another language if you feel more comfortable.
Write a program which queries the pokemon api: https://pokeapi.co/
I want to be able to provide a type as a string (e.g. "fire", "water", "normal", etc.) and receive a random pokemon back that has that type and prints out the following information:
(example)
Name: Cyndaquil
Type: Fire
Base HP: XX
Base Attack: XX
Base Defense: XX
If you feel that this project is over your head, I assure you, it's not. Although the application seems pointless, it will teach you several things.
Querying an API. You'll do this all the time in the real world.
Reading through data and learning how to parse it. The API will give you back a JSON object. You don't need everything it gives back, and you can create classes which will represent the sub-objects with only the relevant data. Again, I do this frequently for work.
Working with libraries. I don't expect you to write your own JSON parser. Chances are something exists. Search for it, use it.
String Formatting. The output string can be written as one string with newlines included and use formatting to use an object's properties.
It's your first year. You don't really learn more than the basics in your first year, and you aren't expected to know more than that. You'll gradually start making more and more complex programs as you progress in your studies. You'll get there, you just need to be patient!
This is how I exactly felt when I doing my CS major. As long as you are interested in computer science, then you should definitely stick with it. I was clueless half the time and I had zero confidence I could even be any sort of developer.
Everyone learns at a different rate. I did not fully understand what a class or an object were until my THIRD year of university. That was my "click" moment. After that, my confidence slowly ramped up and I made it out. Getting and holding a software developer job is another story but it really was just committing yourself to try and being persistent. Eventually, a lot of good things fell into place for me.
Good luck!
It will click! For a beginner I think understanding the syntax is more often the difficult part.
One helpful thing you could try is to go on github and start trying to read through code for some Java projects of various kinds. That can give you some rough idea what larger projects beyond class work look like
OP you definitely have to read this article :)
https://www.google.com/amp/s/www.freecodecamp.org/news/learning-to-code-when-it-gets-dark-e485edfb58fd/amp/
I think all students should read this article before going for CS major üòÉ.
You got this üí™
The language is graspable, and I basically learned how to compile a bunch of different things, but I can‚Äôt see myself being a full blown, confident programmer who creates things like Facebook, Google, or Amazon.
The experience of the hiring managers at Facebook, Google, Amazon, and basically everywhere is that when you hire a smart computer science graduate (or really basically a smart graduate in anything) it doesn't take very long to turn them into a capable programmer, provided they can read your codebase.
So the goal here isn't to get you to graduate as someone who knows how to build Facebook (although, humblingly, the kids who wrote Facebook wrote it before they'd even graduated. Ugh.) It's to get you to graduate as someone who can be turned into a programmer sometime during their first year of employment.
I don‚Äôt want to be stuck compiling a ‚ÄúHello World!‚Äù program forever.
Well, then don't. Write more code than that. They're giving you the tools; it's really up to you to use them or not.

Comments from https://www.reddit.com/r/DebateEvolution/comments/1faljrk/a_bit_confused_about_noncoding_dna/:
I've seen creationists (like SFT) often bringing up how parts of our non-coding DNA actually has uses. But how big is this percentage of actually somewhat useful non-coding DNA? And in general, how useful is it even? Is it the majority of the non-coding DNA or a minority?
Dr. Dan (PhD evolutionary biologist) debunks this stuff to the point of making creationists change their narrative: I Made Discovery Institute Change Their Junk DNA Argument : r/DebateEvolution
Here's a summary I've written before for the other subreddit:
In 2012 the project Encode declared to the world 'the idea of junk DNA is dead', but it turns out they committed many fallacies, and molecular biologists already knew most of the DNA is junk
Here's a 2022 academic review, Table 1 is nice for listing the fallacies committed: https://doi.org/10.1146/annurev-genom-112921-123710
Wikipedia offers a quick read on the drama: https://en.wikipedia.org/wiki/ENCODE#Criticism_of_the_project
Here's Encode's team backpedaling in 2014 in a paper that didn't have any publicity unlike their 2012 incorrect claim: https://www.pnas.org/doi/full/10.1073/pnas.1318948111
TL;DR: ~90% of our genome is useless junk.
What's in Your Genome (2023) by Dr. Moran is great for covering the full history too if you want further reading that explains all the nuances.
They are confusing things on purpose. There are two different things:
Non-coding DNA. This is all DNA that doesn't code for a protein sequence
Junk DNA. This is DNA for which there is strong evidence its sequence doesn't have any role in an organism.
Junk DNA is a subset of non-coding DNA. All junk DNA is non-coding DNA, but the opposite is not true. There is a lot of non-coding DNA that is NOT junk DNA.
We have been finding new roles for non-coding DNA from time to time. We haven't really for junk DNA. But creationists like to pretend that finding roles for non-coding DNA means we were wrong about junk DNA, when we really aren't. Which makes sense, because the only things classified as junk DNA were things we had good evidence were not playing a role.
I haven't followed this specific thing, but I don't get why the argument is even made.
Are there non-coding sections with no purpose? Alright, it's simply the case that the Fall corrupted DNA so it has non-coding sections without a purpose.
The opposite? Well, it's an example of God's creation being perfect.
They literally could win either way, surely
Non-coding DNA is basically anything that doesn't encode a protein: and we've known it can have function for well over 50 years at this point.
Much of the function offered is regulatory: it provides targets for other components to control protein synthesis from the genome; or it generates 'receipts' for metabolic functions that controls proteins in the cell.
However, I'm not sure if we have established what proportion of the genome is these elements: you can't readily differentiate them from less functional elements from sequence alone.
We don't really know how much of our noncoding DNA has a use, but the already provided figure of 90% not having a particular use is probably close to correct. A thing that lower level biology courses (even into college level) leave out is that proteins are very often not good at performing the function their perform. While it's true that the majority of the genome is transcribed at some level, it's very likely that a lot of that is just RNA polymerase screwing up. Additionally, you have to understand that creationism is a conspiracy theory. Conspiracy theorists will view any fact as evidence for their conspiracy. For them, if most of the genome does nothing, it's the mystery of Faith. If most of the genome does something, it's the perfection of God's creation.
To add to all the excellent replies: a lot of the human genome is not only non-coding, but also _repetitive_. Like, horrendously fucking repetitive. Just hundreds of copies of the same six base sequence, over and over again. ~60% of our genome is just repeats.
Some (but not all) of these can...serve function, in that they act as sites to facilitate recombination, given they're so fucking repetitive and recombination is notoriously sloppy, but that's a very, very generous concession: they absolutely do not need to be so massive, so widespread nor so variable between individuals to facilitate recombination.
Recombination is also notoriously sloppy (and so is DNA replication, for repetitive sequences) such that these long stretches of repeats can expand and contract massively between individuals. And also a lot of recombination events just straight up fucking render the cell inviable, which is "affordable losses" when you're playing the 'throw shit at the wall and keep whatever sticks' game.
If a creationist were to argue "god put these massive repeat segments into the genome because they're necessary to enable the ludicrously ham-fisted clumsy bullshit recombination mechanisms (that he designed to be clumsy and bullshit)" then that would...actually be an honest argument. Still a dumb argument, but a more honest one.
Instead, they argue that all these things have function, and that function is _essential_ and that clearly demonstrates design, and try to hope you won't notice that the function is
optional
not always associated with the locus anyway, and
really, just...really fucking clumsy
The creationists are wrong, and most of the genome isn‚Äôt coding and therefore ‚Äúuseful‚Äù according to the central dogma but I bristle at the value judgement of ‚Äúuseless‚Äù. It seems to connote there‚Äôs supposed to be a use or that it‚Äôs failing by not having one, which, like, says who?
Others have already brought up the with ‚Äúnon-coding‚Äù vs ‚Äújunk‚Äù distinction, another bit of terminology I‚Äôm not the hugest fan of. A stretch of DNA not being a coding segment doesn‚Äôt necessarily make it ‚Äúuseless‚Äù , because some of it plays structural roles in coordinating trans- and cis-acting elements like recruiting transcription factors to promoter complexes, and is the raw material for mutations to act upon. Probably provides jumping genes and other self-inserting sequences ‚Äúsafe‚Äùplaces to land without disrupting anything, on occasion, for whatever little that‚Äôs worth.
But that doesn‚Äôt make it a magical hallmark of design, it‚Äôs just proof that our lineage is pretty comfortable having a large genome that‚Äôs only partially coding. We aren‚Äôt a virus trying to min/max our transcriptome by running genes backwards and forwards on the same strand.
Whatever cost there is for replication clearly isn‚Äôt outweighing the neutrality or benefit of having big long stretches of the molecule that don‚Äôt ‚Äúdo‚Äù anything.
Functional non-coding DNA in the minority. The majority of non-coding DNA seemingly does nothing. The exact percentage is in flux, as new functions are always being discovered, but we have always known that not all non-coding DNA is junk, so unlike what creationists say, this does not represent some reversal.

Comments from https://www.reddit.com/r/AskProgramming/comments/18z14yo/confused/:
Angular and React use Javascript/Typscript , HTML and CSS so just keep going and learn some javascript later.
Will be a good start for a frontend dev
If you want to do any kind of web development, a solid understanding of HTML and CSS will be invaluable. HTML is not complicated, but CSS involves a lot more nuance and some tricky concepts. I would recommend getting the basics down, but not worrying too much over the details. Then move onto JavaScript.
The advantage of focussing on HTML, CSS, and JS is its ubiquity. You'll be able to develop with these technologies in pretty much any environment without having to worry about installing & managing tons of packages. You'll also be able to learn about related tools which are optional, but incredibly useful ‚Äî e.g. a good text editor, git, command line programs.
I wouldn't recommend trying to learn all those languages until you're comfortable with one. You'll get a lot more benefit understanding one language in-depth, alongside non-language-specific principles of programming, than you will trying to learn 4 or 5. Advice will vary, but in terms of simplicity and usefulness, I'd suggest this order: (JavaScript) -> Python -> Java -> C++ -> .NET
Choose something you want to achieve, something you want to do, no matter how crazy it is; be so an AI, your own website, a Videogame, etc...
Work towards that.
It may take years but once you are done, you will be far ahead the game than otherwise.
Whoever told you that just threw a load of languages out there without considering what you actually want to do.
If you want to be a web dev then HTML and CSS are good starting points. You will also need JS knowledge.
I‚Äôd forget C++ entirely as it‚Äôs not going to help as much, and I‚Äôd pick either Java or C# but not both (as a .net dev I‚Äôd recommend c#)
Things like react / angular / asp.net again I‚Äôd probably pick just one to start. React is very popular so probably go with that.
Keep working through the course if it‚Äôs working for you. Then look to learn new things later though. Don‚Äôt rush too far into a wide set of languages straight away.
HTML and CSS are really useful to know, but they are declarative languages. Most programming is done with imperative or functional languages. The difference gets complicated but basically:
Declarative - you say what you want at a higher level (HTML, XAML, SQL)
Imperative- you give a detailed set of instructions about how do do something
Functional - some languages are functional by design, like Haskell and F#. But it‚Äôs also a style that can be used in most languages. For example in C# Linq is a functional way to access data.
Whereas a graphic designer could use apps to make great web pages, and get that automatically turned into HTML and CSS, that‚Äôs much harder to automate with imperative code like you would write in JavaScript, C#, Rust or C++.
I think your friend is right, focus on something like C#/.NET that will get you working with imperative and later functional code. If you are on Windows, get Visual Studio 2022 Community. It‚Äôs free, even for commercial use (small teams) and has everything you need for web, command line, desktop, database and even mobile development.
Python and JavaScript are dynamically typed. Personally I think all good programmers need a good understanding of types, so I don‚Äôt recommend them to beginners. When you understand types a little, switching to those dynamic languages is easy but going the other way is a headache.
Be aware Visual Studio 2022 is very different from Visual Studio Code. VSCode is great (I use it for Python, Rust, PowerShell etc) but in languages supported by the full VS2022 it‚Äôs far superior (Web, C#, VB, C++).
well...
HTML and CSS are excellent to know if you're responsible for making things look good on a page. they are complimentary to literally everything you listed EXCEPT c++ (you don't need to learn c++ unless you're working for someone who needs c++).
if you want to be solidly employable, these are good languages: javascript/typescript, java, python (if you're in a data analysis type role). there's also plenty of work with php and ruby, but php is pure shit and you learn it just to get a job somewhere that's using it. .net is something you can learn on a job that uses it. the main thing is that you solidly understand programming principles. learning a new language is not a big deal, you just need to know one well.
for frontend dev, react/vue/angular are popular frameworks.
for backend frameworks, that's a very wide field.
honestly, the most bang for your buck (skill building, employability) is to know javascript/typescript, react/vue/angular, and nodejs. nextjs and remixjs are both front/backend javascript frameworks that'll get you and up-and-running site relatively easily.
in terms of backend skills, you'll need to understand how to fetch, process, and persist data. you should know some sql (mysql, postgres, whatever), and you should be familiar with document-oriented storage (mongodb)

Comments from https://www.reddit.com/r/learncsharp/comments/1eqy7ng/im_confused_with_the_for_loop/:
I have been learning C# for about a month, and I have been understanding everything and have done most of the exercises with relative ease, however this changed with the for loops. It's not that I don't understand the concept itself, I do understand it, and I even find some exercises easy. However, that changed when I entered this page: https://www.w3resource.com/csharp-exercises/for-loop/index.php. The first few exercises were pretty easy for me, but pattern exercises just make me want to throw the computer out the window. And looking at solutions only makes me more confused. I think I'm stupid. Any advice to improve?
If you took the time to read me, I appreciate it :). I am a beginner in this world and any advice would be welcome.
Are you talking about the ones with nested loops?
Yeah, it can be a bit confusing. Sometimes it helps to write things down on paper and try to think it through, created worded process. Look for a pattern in the process and try to make it look like "pseudo code", which is like writing words but with code like syntax.
It's okay to look at solutions. What you can do it look at the solution, copy the code and play around with it. Take it apart by commenting out sections of code and running them. And also, stepping through the code line by line, statement by statement, so you know whats happening. You can also add extra code like extra Console.WriteLines that show more information on what's happening to give you a better idea of how it works.
And, surprise! Even long-time programmers do that to understand code they are working on, even code they wrote!
since you can‚Äôt implicitly multiply an int by a string, you could nest another loop inside the first loop that would in turn have your print statement occur for each increment.
int rows = 4;
First of all, relax, you're a month in. This is a new way of thinking. It takes time. First thing you want to do is write down with a pencil and paper what a basic loop is doing. Make sure you are understanding everything about a basic loop before you move onto nested loops. And then, you want to do the same thing again. Make it work on paper. Go very very slow and try and recognise the pattern (again, on paper) that the stars is doing. What's happening in line1, then 2, then 3...whats the pattern ?
For each element of the outer loop, you loop through all elements of the inner loop. So if i= 1 then j=1 to n, then i=2 and j=1 to n. This kind of thing works well for sorts. It is order n squared so it is kind of slow. But with modern processors you probably won't notice the speed.
Spend more time on exercise 6 and 7 from your link and look closely at similarity / difference between those two. At some point it will click.
So the thing that might help to get in the right mindset for loops is to think about what you get if you AREN'T fancy, then think about what you want, then try to figure out how to use what you have to get what you want.
(The trick with these exercises is if you do them in order, what you learn from the last exercise is important to solving the next.)
This is "not fancy":
If you run this you get 0, 1, 2, 3, 4.
So look at exercise 9. This is a common one! It wants you to print:
Hmmm. What I see there it it printed 1 star, 2 stars, 3 stars, then 4 stars. That kind of matches what I have. But I'll need a fancier loop. How do I write code that prints a certain number of stars?
Well, how would I do it on paper? It's kind of easy. If I want to make 2 stars, I:
To do 3, I add a third step. Hmm. Can I do anything with strings that's like, "Add a new character to the end?" I can! I could get a 2-star string by:
But I can't get to that with a loop that's just making 0, 1, 2, 3, and so on. I need a fancier kind of loop for that. It looks like:
In this kind of loop, we have a variable that we change each time the loop runs, and we want to change it multiple times to get our result.
So we start with starCount at 1, and we end up with stars being "*". Next, starCount will be 2, and we end up with stars being "**". Next, starCount will be 3, which fails the loop condition so we stop looping.
Hmm. We just had "*", then we had "**". That's actually the first two strings we wanted. What if...
Aha! That will print what we want. It's not the solution the website came up with, but I was working my way towards it. There are many ways to solve this problem.
So let's look at (11). It wants:
Hmm. To do this on paper I would:
Draw 1 "1".
Draw 2 "2"s.
Draw 3 "3"s.
Draw 4 "4"s.
This is very suspiciously a pattern like 1, 2, 3, 4, which I already know how to generate. And I just learned how to make a string that gets longer as the loop goes. But, hmm. Last time I had to make a string out of "*", which was the same every time. This time the line changes each time. I can't just reuse stars like I did before or I'll end up with a string like "1234" and I need that to be "4444". Hmm. Let's treat this as two problems.
I know if I want to print "1", I just print it.
I know if I want to print "22", I can:
Start with an empty string.
Add "2".
Add "2".
Print it.
If I want to print "333", I do the same as above but add one extra step. Oooh. When I see this process getting one extra step each time, I understand my loop. Printing "333" should look like:
This time I had to start with a blank string, add characters to it, but WAIT to print it until I'd added all of the characters. If I change the length variable to 2, I'll get "22". Neat. So this is like a reusable piece of code. I need to somehow make this code set length to 1, 2, 3, 4... HEY, that's another loop!
now each time the "outer" loop runs, length will have a different value, and I know the rest of the code makes the right string.
This is kind of the way to approach these problems, and honestly they aren't problems that come up often in real programming. Real problems with loops tend to be much more straightforward and more related to "do something for each item in this list" than "print something interesting to the console". That's why I stopped here. The problems starting at 12 and onwards are a LOT harder. Here's some hints.
(12)
Notice that overall, you are printing the numbers 1-10. That's probably one loop.
But also notice, the number of items on each line is 1, 2, 3, 4... that's another loop.
But the tricky thing here is if you try two loops like I said, it gets messy. When things seem hard it's better to start over.
So think about the line with "4 5 6".
What if you wrote some code that said, "Starting with 4, print 3 numbers."?
If you had that code, then you can write:
Starting with 1, print 1 number.
Starting with 2, print 2 numbers.
Starting with 4, print 3 numbers.
Starting with 7, print 4 numbers.
I see a 1, 2, 3, 4 in there, but 1, 2, 4, 7 is a little tougher.
What if you have a variable that is "the last number I printed"?
Or, what if you just generate a big list of the numbers you need first so you can ask for "the next number"?
(13)
I'd have asked you to do 14 first, 14 is easier.
To properly center things, you need to know how many lines you're printing first.
Notice that this still has 1, 2, 3, and 4 characters in order, and it's the same numbers as (12).
But this time you need to add extra spaces to the front. How many?
3, 2, 1, 0... that's a backwards loop!
The height is 4, and we're counting down from 3.
(14)
This is an easier (13).
Take a crack at them, but don't get too bent out of shape. Some of these would challenge an expert. (I'd have to spend 10 or 15 minutes on (12), I'm still not 100% sure how I'd approach it.) I'd argue as long as you can figure out (5) and (6), you're ready to move on and can treat the other exercises as fun challenges.
So, I also am bad at nested loops, or were.
This is my pattern to for loops or anything in general:
Write pseudo code in the loops, or anywhere, as subroutines or functions.
foreach itm in Items (can use this with for / loop)
updateItem(itm);
printItem(itm);
somethingElse(itm)
//if you want to nest something, it also becomes easier
foreach itm in Items
taskhere(itm);
taskhere(itm);
foreach subitem in itm.Items
taskhere(subitem);
taskhere(subitem);
subitemtask(subitem)
This way, you can reuse the same processes, should you need to.
Also let's you modify or insert or remove each 'task' you do to the item; And also allows you to keep things scoped out, so you don't have 20 things in your mind that you are trying to figure out.
Outlining:
How I do programming, much more, is by outlining what I am about to program.
I also heavily use Xmind, which is free, to keep track of what is going on. I can then write notes in it, write pseudo code. This helps me 100% cause I would get lost if I don't give myself breadcrumbs. Especially when I am in the zone but then have to call it quits. I make sure I outline / note where I left off.
Final
A lot of programming is more the meta of programming than the code itself.
Figure out how you would do it in real life. How do you sort? How do you process "this"?
Believe it or not, you know how to program, cause you do problem solving all the time, logistics.
You'll get it. Keep the faith.
This code:
Is the same as
man, some of the code in the solutions is pretty awful, but there's not much that can be said other than to practice identifying patterns.
and just know that there is rarely only one way to skin a cat in the programming world. here's a random way to implement 9 that uses a single for loop for example:

Comments from https://www.reddit.com/r/learnprogramming/comments/rmof0w/feeling_confused_with_programming/:
Hey all,
I need some guidance on some of my programming decisions vs. thoughts recently. I‚Äôve been in and out of programming for roughly 1 year, like most people, struggling to get past the read everything I can phase and actually build something on my very own.
In that year I‚Äôve tried out a few languages like Python, Java, JavaScript. I enjoyed Java a bit, barely remember Python, and kind of feeling puzzled with JS. JavaScript has been my home-base language for a while, and I‚Äôve tried to learn react, node, and understand JSX but I just can‚Äôt seem to grasp it enough to create something on my own.
Anyway, I know some people working on a project and I was able to join and do whatever ‚Äúdev work‚Äù I can as practice without getting in the way (most of it get finished for me or re-written better). It‚Äôs nice because I‚Äôm an organized dev environment and get to read and understand their code and get familiar with file structures and libraries.. but often the code still confuses the hell out of me, and I find myself basically trying to copy paste/change code from other areas that work similarly. This is all react, node, jsx, js stuff. There are also a lot of basic things I forget when coding on my own, like applying or not knowing where to apply loops and other things.
I think that part of the problem is that you‚Äôre trying to use frameworks (e.g react etc) from the get-go, before completing a project without them.
If loops and other fundamental ideas are still tricky for you (and to be clear, no judgement there, it‚Äôs how everybody learns), you don‚Äôt need another layer of abstraction confusing things. It‚Äôs overwhelming; you end up doing cargo cult programming (copy paste and change) in order to get anything done, and you don‚Äôt learn much as a result.
Your goal while learning should be to be confused by exactly one thing at a time.
For example, react js is a library for manipulating the DOM (document object model), which is a data structure that defines a web page. It has lots of clever stuff in it to hide all of the complexity of the DOM from the programmer, which is great for building things but terrible for learning.
If you want to understand why react js exists, and have some intuition about why it‚Äôs designed the way that it is, then you need to come to terms with the problems that it is solving.
That means creating a website using only HTML, and then manually using JavaScript to do stuff to the page. It‚Äôll be hard to achieve simple goals, and that‚Äôs the point - it‚Äôll illustrate to you why someone bothered to make react js, and teach you about exactly how the DOM works under the hood. Then, later, this fundamental knowledge will help you understand what react js is doing, and use it effectively.
You need practice, don‚Äôt abandon JavaScript it is an amazing language, and you will be taking yourself back if you have to start from scratch another language. I would suggest practice. Create a simple react application, a calculator, a todo app, and watch other people create react apps on YouTube, simple apps max an hour. Double the watching speed if you know what he/she is coding and just watch, stop and listen when you don‚Äôt understand something. DON‚ÄôT CODE ALONG, you wanna get the entire picture of the app architecture in your head after you finish watching. Try to explain what they did. Then, after you fully understand. Try to make the app yourself. It‚Äôs hard, but never ever ever stop when it gets hard, if you stop when it gets hard, you‚Äôll never learn programming or anything in life for that matter, when it‚Äôs hard is when you are learning. Like, if you go to the gym that last few lifts are the hardest and that‚Äôs when you are making those muscles work. If you go to the gym and whenever you feel the resistance you stop your muscle will never grow, it‚Äôs the same for neurons. You are literally creating new neural pathways when you are learning totally new thing, so when you reach that point always remember, you get into the LEARNING ZONE. Good luck, and forget about time, get better every day and you will see yourself getting good.

Comments from https://www.reddit.com/r/learnpython/comments/1f5rwav/new_dude_confused_abt_which_coding_software_to/:
i am trying to learn to code (i am pretty, most impressive thing ik is how to make piecharts)
should i use pycharm or jupyternotebook?
i previously have used python IDLE only lol (learnt from school)
PyCharm, vscode, or Jupyter notebook are all fine places to get started. The important thing is not to get so hung up on which tool to use and to get started.
I personally like vscode because it can addapt to any language and it's quite clean. You can check out all the extensions, I even got vscode to compile my LaTeX files.
PyCharm, Jupyter Notebook VS Code and some others are just text (code) editors. It is like Word, Apple Pages, and Google Docs to work with text. You can choose one of them, or try all of them and decide which one to use. Just install PyCharm, VS Code and try them for couple of days and see if you like them. And choose one. That is it.
Important thing here is of course your actual python code, not the tool you use to write it. (well, to certain extend, however that is another topic)
No wrong choice in any of them. To be honest. Best of luck and enjoy!
VS code
I love using notebook because it can display image and play sound.
If my code is large, I use code editor to write it because it have auto-completion.
Notebook can also use code file via import command.
It kinda depends what you're trying to do. Jupyter Notebooks are mostly used for data analysis so if you want to do data analysis then carry on with that, but if you want to make a web app then that would be the wrong tool. 
I mostly work with web apps so I use VSCode because it's easier to jump between python, Vue, html & CSS. I also have Pycharm installed so sometimes I use that. Hell, if I'm only writing a small script I might even go old school and use Notepad++.
Basically my point is that it's not like you choose one IDE and use it for the rest of your life. Pick one to start with and once you get more confident you can try them all and see which you prefer.

Comments from https://www.reddit.com/r/developersIndia/comments/1eigfhx/confused_about_choosing_a_language_for_coding/:
Hello everyone. I have in total 8+ years of experience was planning to switch jobs. I have experience in C#,Javascript and Python. Not so good in coding without googling. I was solving some problems in leetcode in Javascript initially as I like it the most but then I got to know issues with Javascript for coding and problems one could face with LLD AND OOPS rounds. So bit confused what to do here. I use very less of python at work and it's mostly Js and C#. If I practice coding in C# then it would be useful for leetcode and lld rounds.but you have to type more and remember syntaxes. It's much more easier to solve problems in python/js but can face problems with LLD rounds. Now this is making me bit confused .What to do here ? Goal is to gain confidence to get any interview. .not targeting any specific company. Please suggest what would be the logical approach here ?

Comments from https://www.reddit.com/r/Btechtards/comments/1dbugmt/i_am_about_to_join_college_and_confused_about/:
So I already know a decent bit of coding as I had Java in class 9-12. Now before joining college I want to start learning and practicing DSA on my own to have a upper hand in college. But do I need to learn a new programming language before that? As I have seen people saying(in this sub itself) that c++ and python are the most useful programming languages to learn. Is it possible to do DSA in JAVA?
Tldr: can I start learning DSA in Java or do I need to learn a different programming language first
go for it bhai, java is one of the standard languages to practice dsa problems in, along with python and c++ moreover it is the concepts that matter in the long run, coding language toh badal bhi sakta hai within a matter of a week, go ahead bro

Comments from https://www.reddit.com/r/csharp/comments/zsdv6d/totally_new_to_anything_programming_beginner/:
I am 21 and totally new to all things programming. I have an interest in learning to make basic games, with the ideal dream to be able to one day make a simple game on my own. Ive been at it all of 2 days and i feel like im starting to see how tall the mountain i want to climb really is.
I have been watching a handful of the classic youtube ‚ÄúC# for total beginners!‚Äù Videos, started sololearn, and have been doing googling on what the good resources to learn with are. My issue is that i feel like even the basic intros are confusing me way more than i thought they would. I can‚Äôt really even understand the basic terms. Everything says ‚Äúthis is what a function is. This is what a variable is. This is what blah blah is‚Äù and i still have no idea what these things actually are or what theyre supposed to mean.
I feel like the tutorials start at step 1 and i need to start at step negative 3. I feel like i need a C# for dumber dummies book.
All the tutorials also say ‚Äúyou learn by doing! So go write some code!‚Äù And i cant even write one thing while reading along a guide. When i try to follow along guides and write something wrong, i cant even understand what the program im using says when it tells me what the error in my code is or understand how to fix it/what to change.
Download and install Visual Studio. Not VSCode but Visual Studio.
Follow these guides here:
https://learn.microsoft.com/en-us/users/dotnet/collections/yz26f8y64n7k07?WT.mc_id=dotnet-35129-website
Start from the very beginning and it breaks down what syntax is, what variables are, what a compiler is, and holds your hand through writing some code.
You need to learn from a course/book which is specially designed for total beginners. The one I usually recommend to people is called "How to design Programs". Book is available at https://htdp.org/ . The video course is also free at https://www.youtube.com/channel/UC7dEjIUwSxSNcW4PqNRQW8w/featured .
This uses Racket programming language rather than C#. But once you understand the basics, learning C# will become easier.
EDIT: EdX course is at https://www.edx.org/course/how-to-code-simple-data
For me, experimentation is key. And really, start with the basics if you really have no clue about programming.
Do simple console apps first.
create a new Console application.
Play around with printing text.
Play around with variables.
Understand what strings, ints, doubles, floats are and how/when to use them.
"Oh, I can store only whole numbers in ints!"
Maybe ask someone to mentor you in the basics of you can.
See if this is helpful:
https://www.w3schools.com/cs/index.php
So, I have good news and I have bad news. The bad news is that, yes, the mountain is tall. The good news however is that it is not insurmountable tall. But it can be difficult to start out if the material you are reading or watching just isn't clicking for you. That doesn't make you're dumb or incapable of learning C#. It just means that you probably need a different angle to get that a-ha! moment.
I agree with one of the other commenters that having a mentor might be more beneficial for you and I would be happy to give it a shot. I sent you a PM with some details.
You can try this series if you want - https://youtube.com/@thecodeblogger8647
If you want to know how computer works, perhaps you must choose another {low level} programming language- Assembler. You will learn how to work with CPU registers, interruptions, RAM, video memory etc. After assembler you could switch to high level language-c#, java, python etc.
What sort of questions do you have about the things you're reading?
I'll make super basic explanations so hopefully you can make some more specific questions. Let's start with Console.WriteLine("Hello World!):
Console is a class. Inside of the Console class is a method/function (either works) called WriteLine which takes in a parameter, in this case a string (text). You know it's a method because of the 2 parenthesis and the parameters inside of it.
WriteLine is a void method, which is to say that it returns nothing. It is purely functional, with no "output" value.
"Hello World!" is a string literal, a string being assigned directly from text inside of 2 quotes.
You could do the same thing by assigning a variable of type string to the value "Hello World!". That would look like this:
Notice the order of type -> name -> = -> value, then the semicolon to indicate that you've completed the statement of assigning the variable. Then you would call Console.WriteLine with the newly created variable:
Ask about literally anything. Why this, why that, how this, how that, and I'll answer when I wake up.
Ive been at it all of 2 days and i feel like im starting to see how tall the mountain i want to climb really is.
I've been doing it for 50 years. All I found out after climbing that mountain is the mountain range across the valley.
Look for beginning c# tim corey on YouTube. He has a video about being a developer.

Comments from https://www.reddit.com/r/cscareerquestions/comments/1dy6hrq/senior_devs_in_my_compant_writing_confusing_code/:
I'm a fresh graduate but I've several years of freelancing experience under my belt and I've always sought to make clean and understandable code.
I started a new job in a mid sized company in my country, and I am dissatisfied with how the Senior devs here code. It is very common to find files 2k blocks long and on some occasions there are 10k. Very big if blocks with lots of nesting. Once found 7 if conditions nested inside each other and 5 foreach loops nested as well. I told the team lead he has to do code reviews with his team he says he'll get to it but he never does.
There are functions 300 lines long...
It's not good but it's also very common in the industry, especially with older codebases that have had lots of different people work on it which have then left.
Try to remember that it often goes like this:
Hey dev, add this feature.
Dev goes into 5000 line file and adds 2 lines. There are no tests and it's hard to refactor and what's 2 lines anyway.
Repeat that another 2000 times and now it's a 10k line file.
Trying to fix issues like this as a junior is pretty futile, easier to join another company if you want to work on a better codebase. You would need buy in from the tech lead and the entire team to make a dent in it.
There are rarely excuses for that long methods or codes.
Only thing comes to mind that I have done that takes over 300 lines is setting fields for a legacy database table that I had to work with.
But I will never forget the 5000 lines single method legacy code that I had to rebuild that had about 30 "running variables" and a total of about 100 class variables, that changed 1-50 times. Of course named "RunningVariable12" and such.
Horror stories of other people code.
Unpopular opinion. Many seniors write terrible code. 1) Years of being told to do things quickly rather than well. 2) Came up in a time before modern coding standarda
How old is the code base? The metrics and guidance for quality code have changed over the years. I work on what most would consider a legacy code base with single classes with >10k LOC and seemingly unwieldy methods are quite common. However the actual quality of the code is really good. It's well documented, relatively easy to follow and well tested. Sometimes I actually get frustrated with navigating through a tree of methods and prefer the gigantic method ideology.
It is reasonable to ask them about this. Sometimes code is inherited from past teams and restructuring or rewriting it at scale can be very disruptive. Sometimes you just tweak and maintain the code until you either have time to rewrite it or it becomes obsolete and you can get rid of it.
I was ready to be like ‚Äúit‚Äôs probably just inexperience with big codebases on your part‚Äù
Until you said 7 nested if conditions.
Sometimes files library code can get large.
From what you have described, I would also find this annoying though and I don‚Äôt think you‚Äôre in the wrong for having second thoughts.
How often do the senior devs leave?

Comments from https://www.reddit.com/r/developersIndia/comments/1evg8x8/how_to_start_coding_im_confused_dont_know_which/:
I'm 18yr, I'm getting into a engineering college but I don't know which language to start, I've chosen AI AND DATA SCIENCE course in tht college so any tips which language to start with. I've studied python in 12th as it was in cbse syllabus it was very much of a basic and MySql too. I just want help and guidance which which lang i need to develop and which language I need to start with.
if you already know the basics of python, you may try numpy, pandas and matplotlib. try and master openCV.
you may try learning how nlp works and the nuances of sentiment analysis.
read and learn about RESTful architecture, like what is frontend, backend and orms etc. you can use mysql workbench to execute queries for mySQL.
once you're done with it, learn fastAPI or flask both are frameworks for backend development.
keep a target to build a small project or multiple small projects which uses AI using the backend that you have learnt.
If you have time learn c++
It will make your core concepts strong
Then learn java
After that you will figure out further things
I personally started with python -> c++ -> HTML -> CSS -> JavaScript -> sql -> java
I would suggest you to choose any one lang from python, java or c++ and start practising on hackerrank to improve your coding practice , then move to leetcode for problem solving , once you are good in it you can also try more harder platforms like codeforces if interested in competitive programming. but no matter what is your interested domain you should practice atleast one question daily on leetcode related to problem solving , because most of the companies ask for dsa no matter what are job requirements also if you are too good in it you can get placed in faang , also parallely you can start learning basic machine learning algos and move to gen ai , computer vision , nlp etc if you are interested . Many other opportunities are there like devops you can try entering as less people in it and demand more , other than this you can go for web dev. There can be other things as well to start but as i much i knew i told :)))
I'd say start with python. Its the easiest to learn and make sure that you focus more on the concepts rather than semantics. And tbh language doesn't really matter later on since you never learn only one language. Python is pretty close to english so it makes learning advance concepts easier. And later on when you're ready you can learn a new language much faster because you'll only need to learn semantics and some tricks as you'd have the bases covered.
Also for ai and data science, python is the most used language, but sometimes R is also used. Your college might even teach you C++ or java in the first semester since most colleges have combined classes for different batches in the first year before separating into specialized subjects. Even if your college teach you other language, you should focus on python along with that on your own time. Finally its also a great language for coding interviews since it reduces the time to write the code.
kaggle has great course for you to start. You don't need to look much further.

Comments from https://www.reddit.com/r/AskComputerScience/comments/bzt93t/do_you_ever_get_confused_by_your_own_code/:
This happens too often to me. Anyone else who experiences this or am i just dumb lol
Everyone does. My favorite is when you say "What the hell? This code is nonsense. What idiot wrote this garbage?"
"Oh. It was me. I'm the idiot."
Lord yes. Over the course of my PhD I learned how to code and at least once a year I would go back over my code base and get absolutely furious at past me. There were a few months where everything was object oriented for no discernible reason... a few months where I got really into bizarre obfuscated bash scripting... a few months where I rewrote a bunch of algorithms from scratch because I guess I wanted a less clear version of things that were already available in other packages? All horribly documented and spread across fifty one-use scripts, of course.
But the nice thing is that I did eventually figure out how stupid all of those things were and start using better practices. But I have no doubt that the next time I reach back to refactor my code I‚Äôll be able to see some dumbass thing I‚Äôm doing right now.
Past me is an idiot, but at least current me seems to be learning.
Well I do competitive programming a lot so it's not that much of a problem.
But when I worked on some web scraper in Python and checked code year later, I didn't even know what was I doing. Comment your code, please. If you don't want to have a lot of comments in your actual code, create a Notepad file and do line number (for example: line 1-10: do something). That way you stay organized :D
Coming back to old code you wrote is just like reading other people's code. If it's good code, it'll be easy to understand. If it's bad code, it's going to annoy you. That's why code quality is important even for small projects.
Of course, code quality is not an easy thing, it takes experience and dedication to improve it. But if you feel that code you write and come back to not too long later is difficult to grasp, maybe it's a sign you could work on your code quality.
Some people talked about commenting. Usually it's not even doing that. Properly naming variables, applying good practices and design patterns, acknowledging code quality as important and taking the time to work on it, this kinds of stuff are usually enough to dramatically improve your code.
Only if I go to lunch after I wrote it and try to look at it afterwards.
If you haven‚Äôt been confused by your own code, just keep writing more code. One day, you‚Äôll look at your old code and wonder what the hell you were thinking. Everyone gets to that point.
And once you reach that point, you never leave. It‚Äôs like that for the rest of your career.
oh definitely
Sometimes I code drunk. It usually works out, but when I fuck up, I fuck up proper. Like, complete nonsense with nasty bugs introduced everywhere.
I've been writing something to help interface with network switches at my job and I've already forgotten what half of it does. Doesn't help that I refuse to write comments because "I'll remember"

Comments from https://www.reddit.com/r/pycharm/comments/qdzc8i/newb_i_am_so_confused/:
How tf do I run packages in pycharm?? Do I type it into the python console or terminal?? I want to use things like PIL and turtle but this is so confusing. I‚Äôm new to programming and stuff. But I‚Äôm an artist that wants to try and get into procedurally generated art. Is pycharm even the right program to use??
There's a couple layers you need to understand.
At the bottom there's Python. Which you need to install.
And then there's PyCharm which is essentially a text editor. When running code in PyCharm, it can help direct your code behind the scene to use Python you installed above.
To see which Python your PyCharm project is set to use, go to
File > Settings >> Project: <your project> > Python Intepreter.
You'll want the very top option, the Python Interpreter, to point to your python.exe.
Then to run your code, you can right click inside you editor and pick run, or click the run icon on the top right, or use ctrl+shift+F10 key
I think python suited for this thing. And it is very easy to learn, compare to other languages. You may run simple app by copying this code from turtle docs:
I suggest checking out thonny as a way to start getting into python. Very easy, and has examples using turtle. https://thonny.org/

Comments from https://www.reddit.com/r/learnpython/comments/1fmooyx/confused_and_self_doubt/:
I have good knowledge of python but I think that I'm lacking behind in applying logic or may be I'm almost there but I couldn't crack it so how should I overcome it ? From where should I start now or build my logical thinking ?
Note the part below about what projects to work on ...
Practice! Practice! Practice! That is the only way. Programming (whatever the language) is a practical problem-solving skill. You have to make, and learn from, a lot of mistakes (much like learning another human language).
I know it can be frustrating at times, especially when faced with code you want to reuse but cannot understand.
Only you can find the motivation. Why are you learning to programme in the first place?
Is your learning objective SMART - specific, measurable, achievable, (sometimes agreed), realistic (or relevant) and time-bound, (or timely)? If it is something soft, like "upskilling" then it will probably not help you much.
It is hard to learn anything in the abstract, not least because it is difficult to feel passion for what one is doing.
I strongly suggest you look to your interests, hobbies, obligations (family business, charity activities, work) to look for opportunities to apply Python.
You will learn far more about Python and programming when you work on something that resonates for you and that you have some domain knowledge of (or incentive to gain such knowledge in).
When you are copying tutorials/examples, don't just copy. Experiment. Break the code and understand why it has broken.
The interactive python shell is your friend, I found it the best learning aid because you can quickly try snippets of code and get immediate feedback.
(Consider installing ipython which wraps the standard shell for more convenience.)
Start very simply and regularly refactor the code as you learn new things. Enhance as you see opportunities.
If you haven't already, take a look at Automate the boring stuff with Python (free to read online).
At first, the tasks you automate will be trivial and hardly worth the effort BUT because it is about the problem and not Python, it will be more rewarding for you.
Many beginners are mixing up coding (writing instructions in a programming language) with problem-solving (creating an algorithm) and their lack of knowledge of the programming language and how to use it is a distraction from the problem-solving.
For most programmers, the coding part is the final and easy bit.
Order:
Actually making sure the problem is properly understood. Often we start with only a vague understanding of the problem.
Ensuring we know what outcome is required. What does good look like? How will the information be presented, will it be on-screen or in a file, or a database.
Determining the data representation. Exactly what data is required, in what forms, where from. It is a one-off or lots of cycles or combining lots of information.
Work out how to do things manually in the simplest possible way, explaining every little step (assume you are giving instructions to someone with learning difficulties),
Computers are really dumb, and humans make lots of intuitive leaps and take short-cuts
This is one of the hardest things to grasp when first learning to programme
Computers don't mind repeating very boring things, so the simplest but repetitive manual approach is often a good approach to start with for a computer
Later, you will learn different ways of selecting / developing an algorithm which doesn't depend on a manual approach
In general, when learning and working on something new, where you are following some kind of tutorial, where others have provided an answer,
follow the steps I laid out above looking for a solution (so make sure you understand the problem first, figure out what the outcome should be, etc)
try to solve the problem yourself before looking at someone else's solution
look briefly at someone else's solution and try to understand what they've done at a high level and see if you can solve it that way
fully review someone else's solution, try it out, play with it (break it, improve it) - be super critical (watch ArjanCodes YT videos on code reviews)
update your algorithm and implement a new solution (including testing, if you can)
write some notes, not on low level detail but on principles, approaches, key algorithms, and summarise what you learned (I keep my notes in markdown format in Obsidian, synced between devices)
You will hear a lot of mixed opinions about the Agile software development methodology but most problems are because of poor adoption rather than it being inherently bad.
Fundamentally, it is about delivering value early and often, failing fast, and working closely with the intended consumers/customers/users for rapid feedback. A key concept, often abused/over-used, is minimum viable product, MVP, which is about developing and delivering the smallest useful (sic) product that you can evolve. This still needs to be done in the context of the large problem being solved, but most problems can be broken down into smaller problems, and the most useful / easiest / proof of concept elements identified to focus on.
Why do you think you're lacking?
i too struggle with this

Comments from https://www.reddit.com/r/learnpython/comments/15cmip6/confusion_regarding_starting/:
Hello, I wanted to start programming with Python since that is beginner friendly and easy to understand, but some suggested me to start with C, C++ or java so that I can know the OOPS concept easily and it will be easy to migrate to python. What do you think? should I know C or C++ so that I will get more logical understanding in programming?
No, that's like saying you want to learn to ride a bicycle, but you should start by learning to drive a car so you learn the principles of the road.
Learn the thing you want to learn: if that's Python, then go for it. Python is undoubtedly simpler to get started with than C or Java.
This sub is obviously biased, but I disagree. C, C++, and Java all have extra stuff that make them harder to understand. Python is a very good programming language to start with. JavaScript is also good.
This question often sparks a lot of debate. It boils down to what your goals are. If you're keen to get started quickly, create projects, and get a feel for programming, Python is a top choice. It's super beginner-friendly and you can still learn OOP (Object-Oriented Programming) concepts with it.
On the other hand, starting with C or C++ can give you a deep understanding of how computers work, like memory management, which is hidden away in languages like Python. Java's also great for OOP concepts and is widely used in industry.
Here's the catch though: C, C++ and Java have steeper learning curves. They're not as beginner-friendly as Python and it might take longer to get to a point where you're building things.
In the end, the most important thing is to start programming in any language. You'll pick up the logical thinking skills no matter which one you go for. Remember, the language is just a tool. Your problem-solving skills are what really matter. Happy coding!
I would start with python. Programming in python needs to be just as logical as any other language, so you don't gain anything by starting with another language, and it's simpler to get started with python. Learning OOP in python exposes you to the same basic principles as in C++ or Java, just the details are different. There is no OOP in the C language itself.

Comments from https://www.reddit.com/r/ChatGPTCoding/comments/13e9r3c/is_there_a_way_to_stop_it_from_getting_confused/:

Comments from https://www.reddit.com/r/CodingHelp/comments/1f6ajof/language_confusion/:
If the problem continues, contact the site owner.

Comments from https://www.reddit.com/r/csharp/comments/1dtm3ur/coding_with_csharp_on_linux_as_a_beginner_is_very/:
If the problem continues, contact the site owner.

Comments from https://www.reddit.com/r/CodingandBilling/comments/1e113tq/new_confused_overwhelmed_and_i_think_i_messed_up/:
If the problem continues, contact the site owner.

Comments from https://www.reddit.com/r/learnprogramming/comments/16wgm9e/confused/:
If the problem continues, contact the site owner.

Comments from https://www.reddit.com/r/learnprogramming/comments/1eqpmes/need_some_advice_im_confused/:
If the problem continues, contact the site owner.

Comments from https://www.reddit.com/r/computerscience/comments/18q08b9/confused_on_what_to_learn/:
If the problem continues, contact the site owner.

Comments from https://www.reddit.com/r/MedicalCoding/comments/1etvesa/a_little_confused/:
If the problem continues, contact the site owner.

Comments from https://www.reddit.com/r/learnprogramming/comments/1cpd2mr/im_confused/:
If the problem continues, contact the site owner.

Comments from https://www.reddit.com/r/scala/comments/1e4yxjq/confused_about_vs_code_metals/:
If the problem continues, contact the site owner.

Comments from https://www.reddit.com/r/ComputerEngineering/comments/1czzoz5/i_am_confused_about_my_career/:
If the problem continues, contact the site owner.

